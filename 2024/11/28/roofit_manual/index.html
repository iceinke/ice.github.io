

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/Z001.ico">
  <link rel="icon" href="/img/Z001.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Feng Zhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="这个是roofit官网的使用手册的翻译和笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="roofit manual">
<meta property="og:url" content="http://iceinke.github.io/2024/11/28/roofit_manual/index.html">
<meta property="og:site_name" content="Feng Zhu&#39;s Blog">
<meta property="og:description" content="这个是roofit官网的使用手册的翻译和笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://iceinke.github.io/img/post13.jpg">
<meta property="article:published_time" content="2024-11-28T04:16:27.498Z">
<meta property="article:modified_time" content="2024-12-30T15:18:23.422Z">
<meta property="article:author" content="Feng Zhu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://iceinke.github.io/img/post13.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>roofit manual - Feng Zhu&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"iceinke.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":250,"cursorChar":" ","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Feng</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post3.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">roofit manual</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">roofit manual</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年12月30日
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <link rel="stylesheet" href="/css/downloadbutton.css">

<p><a href="/download/roofit_manual.pdf" class="download-button">下载文章</a><br><a href="/download/RooFit_Users_Manual_v2.9.pdf" class="download-button">RooFit Manual</a></p>
<h2 id="1-安装和设置roofit"><a href="#1-安装和设置roofit" class="headerlink" title="1 安装和设置roofit"></a>1 安装和设置roofit</h2><h3 id="1-1-安装root和roofit"><a href="#1-1-安装root和roofit" class="headerlink" title="1.1 安装root和roofit"></a>1.1 安装root和roofit</h3><p>roofit库是标准root发行版的一部分，并且预编译在二进制发行版中，可以通过<code>root.cern.ch</code>获取。如果您从源代码发行版编译 ROOT，则必须在运行 configure 时使用标志 –enable-roofit</p>
<h3 id="1-2-设置交互式root环境"><a href="#1-2-设置交互式root环境" class="headerlink" title="1.2 设置交互式root环境"></a>1.2 设置交互式root环境</h3><p>只要在命令行引用了 RooFit 类之一，ROOT 就会自动加载 RooFit 库 libRooFitCore 和 libRooFit。方便起见，建议你ROOT登录脚本中添加下面的命令<code>using namespace RooFit;</code>，这样你就能在命令行中使用RooFit命名空间中的辅助函数了。这个命令也会自动加载RooFit库。这篇指导的所有例子都是建立在你已经加载RooFit命名空间的基础上的。  </p>
<blockquote>
<p><code>using namespace RooFit;</code></p>
</blockquote>
<p>一般情况下你需要将你的程序写入到一个程序文件中，在这个程序开头你需要加入一些头文件和命名空间，这样你在使用<code>root yourprogm.C</code>的时候就能加载RooFit库库了</p>
<h2 id="2-动手做"><a href="#2-动手做" class="headerlink" title="2 动手做"></a>2 动手做</h2><p>这部分会带你做简单的模型去拟合数据。目的是让你熟悉一些基本概念，并且能快速地做一些有用的事情。在接下来的小节中我们会更仔细地探索RooFit几个方面。</p>
<h3 id="2-1-构建模型"><a href="#2-1-构建模型" class="headerlink" title="2.1 构建模型"></a>2.1 构建模型</h3><p>RooFit中一个关键概念是以面向对象的方式构建模型的。每个RooFit的类都有一个对应的数学对象：<code>RooRealVar</code>表示一个变量，<code>RooAbsReal</code>表示一个函数，<code>RooAbsPdf</code>表示一个概率密度函数（probability density function），等等。就算是最简单的数学函数也包含了很多对象——函数本身与其变量——RooFit模型也因此由许多对象组成。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span> ;<br>RooRealVar <span class="hljs-title function_">mean</span><span class="hljs-params">(<span class="hljs-string">&quot;mean&quot;</span>,<span class="hljs-string">&quot;Mean of Gaussian&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigma</span><span class="hljs-params">(<span class="hljs-string">&quot;sigma&quot;</span>,<span class="hljs-string">&quot;Width of Gaussian&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span>;<br>RooGaussian <span class="hljs-title function_">gauss</span><span class="hljs-params">(<span class="hljs-string">&quot;gauss&quot;</span>,<span class="hljs-string">&quot;gauss(x,mean,sigma)&quot;</span>,x,mean,sigma)</span>;<br></code></pre></td></tr></table></figure>
<h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note 1"></a>Note 1</h4><ul>
<li><p>概率密度函数（Probability Density Function，PDF）是用于描述连续型随机变量的概率分布的函数。 随机变量 X 落在区间 [a, b] 的概率是：$P(a \leq X \leq b) &#x3D; \int_a^b f_X(x) , dx$，并且还需要满足归一性和非负性。</p>
</li>
<li><p>对于一个函数来说，需要自变量x和参数，对于自变量来说你需要设定一个范围，也就是函数的定义域，而对于参数来说，因为你需要用这个函数去拟合一些数据，那么就不可能一开始就确定这个函数，而是给他一个大致的范围让他去拟合，这个范围还需要根据你的拟合结果进行调整，也就是调参的过程。</p>
</li>
</ul>
<p>在<code>gauss</code>用到的每个变量都用几个属性进行初始化：name, title, 范围和可选的初始值。用<code>RooRealVar</code>描述的变量有更多的属性在这个例子中没有展现出来，例如与变量关联的对称误差以及指定变量是常量还是浮动的标志。本质上，类<code>RooRealVar</code>收集所有与变量有关的属性。</p>
<p>代码的最后一行创建了一个高斯分布的概率密度函数，由<code>RooGaussian</code>实现。类<code>RooGaussian</code>描述了所有概率密度函数的共同属性。PDF 高斯有一个名称和一个标题，就像变量对象一样，并通过构造函数中传递的引用关联到变量 x、mean 和 sigma。</p>
<h3 id="2-2-模型可视化"><a href="#2-2-模型可视化" class="headerlink" title="2.2 模型可视化"></a>2.2 模型可视化</h3><p>通常我们最先想到的是看到这个模型。RooFit采取了比普通ROOT稍微正式一点的可视化方法。首先你需要定义一个“视图”，本质上是一个空的框架，包含<code>RooRealVar</code>中变量之一x作为横坐标轴，然后你要把你的模型gauss放进这个空白框架中，最后你再把这个视图画在ROOT TCanvas上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">RooPlot* xframe = x.frame() ; <br>gauss.plotOn(xframe) ;      <br>xframe-&gt;Draw();            <br></code></pre></td></tr></table></figure>

<p><img src="/postfigure/roofit_manual/image-20241230194318643.png" srcset="/img/loading.gif" lazyload></p>
<center>Figure 1 - 高斯pdf</center>


<p>结果看图1。需要注意的是，在定义或创建一个视图的时候并不需要特意去设置范围，会根据<code>RooRealVar</code>中定义的变量的范围自动设置，当然你也可以重新设置范围。另外，将gauss画在框架中时，也不用说明gauss是x的函数，可以在框架中找到这个信息，就很智能。</p>
<p>一个框架可以可视化多个对象（曲线，直方图），我们可以画两个不同sigma值的高斯曲线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">RooPlot* xframe = x.frame() ; <br>gauss.plotOn(xframe) ; <br>sigma = <span class="hljs-number">2</span> ; <br>gauss.plotOn(xframe,LineColor(kRed)) ; <br>xframe-&gt;Draw(); <br></code></pre></td></tr></table></figure>

<p>这个例子中，在画完第一个gauss图像之后，我用赋值运算符改变了<code>RooRealVar</code>sigma的值。第二条曲线的颜色通过添加<code>LineColor(kRed)</code>参数传递给plotOn()变为红色。LineColor 是“命名参数”的一个示例。命名参数贯穿整个 RooFit 的使用，它提供一种方便且可读的方式来修改一些默认值。命名参数将在后面的部分中更详细地介绍。第二个代码片段的输出如图 2 所示。</p>
<p><img src="/postfigure/roofit_manual/image-20241230195113004.png" srcset="/img/loading.gif" lazyload></p>
<center>
Figure 2 - 不同宽度的高斯pdf
</center>

<p>这个例子同时也展示了plotOn()方法会对PDF进行一个“冻结”的快照，如果一个pdf在画进去之后改变了形状，之前已经画进去的曲线不会发生改变。图2还展示了无论数值如何，<code>RooGaussian</code>总是归一化的。</p>
<h4 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary 1"></a>Summary 1</h4><blockquote>
<p> RooGaussian::RooGaussian (const char * name, const char * title, RooAbsReal &amp; _x, RooAbsReal &amp; _mean, RooAbsReal &amp; _sigma)</p>
<p>RooRealVar::RooRealVar (const char * name,const char * title, double minValue, double maxValue,const char * unit &#x3D; “” )</p>
<p>RooRealVar::RooRealVar (const char * name,const char * title, double value, double minValue, double maxValue,const char * unit &#x3D; “” )</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span>; <span class="hljs-comment">//设置自变量x，并设置定义域为[-10,10]</span><br>RooRealVar <span class="hljs-title function_">mean</span><span class="hljs-params">(<span class="hljs-string">&quot;mean&quot;</span>,<span class="hljs-string">&quot;Mean of Gaussian&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span>; <span class="hljs-comment">//设置参数</span><br>RooRealVar <span class="hljs-title function_">sigma</span><span class="hljs-params">(<span class="hljs-string">&quot;sigma&quot;</span>,<span class="hljs-string">&quot;Width of Gaussian&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span>;<br>RooGaussian <span class="hljs-title function_">gauss</span><span class="hljs-params">(<span class="hljs-string">&quot;gauss&quot;</span>,<span class="hljs-string">&quot;gauss(x,mean,sigma)&quot;</span>,x,mean,sigma)</span>; <span class="hljs-comment">//给RooGaussian传入三个参数，自变量x，中心值mean，宽度sigma</span><br>RooPlot* xframe = x.frame();	<span class="hljs-comment">//创建一个以x这个变量为坐标的空坐标图，这个会直接获取你之前设置的x变量的范围定义你的坐标的范围，这里就是 -10～10</span><br>gauss.plotOn(xframe);	<span class="hljs-comment">//将你之前创建的gauss函数画到你的坐标图中</span><br>xframe-&gt;Draw();	<span class="hljs-comment">//将你这个图通过TCanvas“打印”出来  </span><br>sigma = <span class="hljs-number">2</span>;	<br>gauss.plotOn(xframe,LineColor(kRed)) ; <br>xframe-&gt;Draw(); <br></code></pre></td></tr></table></figure>

<center> Summary 1 - 构建一个高斯分布的概率密度函数</center>

<h3 id="2-3-输入数据"><a href="#2-3-输入数据" class="headerlink" title="2.3 输入数据"></a>2.3 输入数据</h3><p>通常来说，数据有两类：未分bin的，用ROOT中的TTree类表示，和分bin的，用ROOT中的TH1，TH2，TH3表示。RooFit可以处理这两种数据。用做统计身高做例子的话，unbinned 就是把每位同学的身高都记录下来，binned 就是画成条形统计图，分为不同区间去计数，每个区间就是一个bin。</p>
<h4 id="2-3-1-分bin的数据（直方图）"><a href="#2-3-1-分bin的数据（直方图）" class="headerlink" title="2.3.1 分bin的数据（直方图）"></a>2.3.1 分bin的数据（直方图）</h4><p>在RooFit中，分bin的数据由<code>RooDataHist</code>类表示，你可以将任何ROOT直方图的内容导入到<code>RooDataHist</code>对象中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">TH1* hh = (TH1*) gDirectory-&gt;Get(<span class="hljs-string">&quot;ahisto&quot;</span>);<br>RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span>;<br>RooDataHist <span class="hljs-title function_">data</span><span class="hljs-params">(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;dataset with x&quot;</span>,x,hh)</span>;<br></code></pre></td></tr></table></figure>

<center>
example 2 - 从TTree中导入数据并将其画在TCanvas上
</center>


<p>note：代码从当前目录 (gDirectory) 中获取名为 “ahisto” 的直方图，并将其强制转换为 TH1* 类型的指针。在ROOT中，TH1 是表示一维直方图的类。  </p>
<p>创建了一个名为 “data” 的 RooDataHist 对象。它表示一个数据集，可以在RooFit中用于拟合或其他统计分析。<br>数据集用名称 “data” 和标题 “dataset with x” 构建。<br>此数据集根据变量 “x”（我们之前定义的变量）进行分箱，并使用先前获得的直方图 hh 填充。这意味着 hh 中的值将用于填充数据集的箱子。</p>
<p>当你导入ROOT直方图的时候，原直方图的bin是如何定义的同样也被导入了。<code>RooDataHist</code>比普通直方图更进一步的是，它将直方图的内容和一个或多个<code>RooRealVar</code>类型的RooFit变量关联起来。通过这种方式，它总知道直方图中存储了什么样的数据。</p>
<p><code>RooDataHist</code>可以和gauss函数一样被plotOn在画布上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">RooPlot* xframe = x.frame() ; <br>data.plotOn(xframe) ; <br>xframe-&gt;Draw() <br></code></pre></td></tr></table></figure>

<h4 id="2-3-2-未分bin的数据（树trees）"><a href="#2-3-2-未分bin的数据（树trees）" class="headerlink" title="2.3.2 未分bin的数据（树trees）"></a>2.3.2 未分bin的数据（树trees）</h4><p>未分bin的数据可以以同样的方式导入到RooFit，并存储到<code>RooDataSet</code>的类中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">TTree* tree = (TTree*) gDirectory-&gt;Get(<span class="hljs-string">&quot;atree&quot;</span>);<br>RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span>;<br>RooDataSet <span class="hljs-title function_">data</span><span class="hljs-params">(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;dataset with x&quot;</span>,tree,x)</span>;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，假设 tree 有一个名为“x”的分支，因为 RooDataSet 构造函数将从与作为参数传递的 RooRealVar 同名的树分支中导入数据。RooDataSet 可以从类型为 Double_t、Float_t、Int_t、UInt_t 和 Bool_t 的分支导入数据，用于一个 RooRealVar 可观测量。如果分支不是 Double_t 类型，则数据将转换为 Double_t，因为这是 RooRealVar 的内部表示形式。无法从数组分支（如 Double_t[10]）导入数据。可以将整数类型的数据作为离散值观测量导入到 RooFit 中，这在第8章中会更详细地解释。</p>
<p>绘制未分 bin 的数据与绘制分 bin 的数据类似，不同之处在于现在您可以以任何您喜欢的 binning 来显示它，默认情况下是100个bins，下面设置了25个bins的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">RooPlot* xframe = x.frame();<br>data.plotOn(frame,Binning(<span class="hljs-number">25</span>));<br>frame-&gt;Draw();<br></code></pre></td></tr></table></figure>

<h4 id="2-3-3-working-with-data"><a href="#2-3-3-working-with-data" class="headerlink" title="2.3.3 working with data"></a>2.3.3 working with data</h4><p>在一般情况下，在RooFit中处理分组数据和未分组数据非常相似，因为RooDataSet（用于未分组数据）和RooDataHist（用于分组数据）都继承自一个共同的基类RooAbsData，该基类定义了一个通用的抽象数据样本接口。除少数例外，所有RooFit方法都接受抽象数据集作为输入参数，使得分组和未分组数据可以互换使用。本节中的示例始终处理一维数据集。然而，RooDataSet和RooDataHist都可以处理任意维数的数据。在接下来的章节中，我们将重新讨论数据集并解释如何处理多维数据。</p>
<h4 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary 2"></a>Summary 2</h4><p>下载测试用的root文件<a href="/download/chapt2.root" class="download-button">chapt2.root</a> 里面包含了两种类型的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">root -l chapt2.root</span> <br>root [0] <br>Attaching file chapt2.root as _file0...<br>(TFile *) 0x12758ae30<br>root [1] .ls<br>TFile**         chapt2.root<br> TFile*         chapt2.root<br>  KEY: RooDataSet       unbinnedData;1  Generated From gaussian PDF<br>  KEY: TH1F     binnedHist;1    Binned Histogram of X<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)</span>;<br>TFile *file = TFile::Open(<span class="hljs-string">&quot;./chapt.root&quot;</span>); <span class="hljs-comment">//打开root文件</span><br>TH1F *hist = (TH1F*)file-&gt;Get(<span class="hljs-string">&quot;binnedData&quot;</span>); <span class="hljs-comment">//从文件中获取名为 &quot;binnedHist&quot; 的 TH1F 对象</span><br>RooDataHist <span class="hljs-title function_">binnedData</span><span class="hljs-params">(<span class="hljs-string">&quot;binnedData&quot;</span>, <span class="hljs-string">&quot;binnedData&quot;</span>, x, hist)</span>;<br>TCanvas* c1 = new TCanvas(<span class="hljs-string">&quot;c1&quot;</span>, <span class="hljs-string">&quot;binned Data&quot;</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>c1-&gt;cd();<br>RooPlot* x1frame = x.frame();<br>binnedData.plotOn(x1frame); <span class="hljs-comment">//生成这个数据的时候的bin是20</span><br>x1frame-&gt;Draw();<br><br>TCanvas* c2 = new TCanvas(<span class="hljs-string">&quot;c2&quot;</span>, <span class="hljs-string">&quot;unbinned Data&quot;</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>c2-&gt;cd();<br>RooDataSet* unbinnedData = (RooDataSet*)file-&gt;Get(<span class="hljs-string">&quot;unbinnedData&quot;</span>);  <span class="hljs-comment">// 从文件中获取名为 &quot;unbinnedData&quot; 的 RooDataSet 对象</span><br>RooPlot* x2frame = x.frame();<br>unbinnedData-&gt;plotOn(x2frame,Binning(<span class="hljs-number">40</span>),MarkerColor(kRed)); <span class="hljs-comment">//如果不设置bin的话默认画出的图的bin是100</span><br>x2frame-&gt;Draw();<br></code></pre></td></tr></table></figure>

<p><img src="/postfigure/roofit_manual/image-20241230224832893.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /><img src="/postfigure/roofit_manual/image-20241230224846866.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<center> Summary 2 - 画出binned和unbinned的数据</center>

<blockquote>
<p><em>你也可以用下面的生成程序，自定义生成出你自己的root数据文件play一下</em></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C">RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)</span>;<br>RooRealVar <span class="hljs-title function_">mean</span><span class="hljs-params">(<span class="hljs-string">&quot;mean&quot;</span>, <span class="hljs-string">&quot;mean of gaussian&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigma</span><span class="hljs-params">(<span class="hljs-string">&quot;sigma&quot;</span>, <span class="hljs-string">&quot;width of gaussian&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span>;<br><br><span class="hljs-comment">// Create Gaussian PDF</span><br>RooGaussian <span class="hljs-title function_">gauss</span><span class="hljs-params">(<span class="hljs-string">&quot;gauss&quot;</span>, <span class="hljs-string">&quot;gaussian PDF&quot;</span>, x, mean, sigma)</span>;<br><br><span class="hljs-comment">// Generate unbinned data</span><br>RooDataSet* data = gauss.generate(x, <span class="hljs-number">500</span>);<br><br><span class="hljs-comment">// Generate binned data</span><br>TH1F* binnedData = new TH1F(<span class="hljs-string">&quot;binnedData&quot;</span>, <span class="hljs-string">&quot;Binned Histogram of X&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">10</span>);<br>data-&gt;fillHistogram(binnedData, RooArgList(x));<br><br><span class="hljs-comment">// Create a ROOT file to save the datasets</span><br>TFile <span class="hljs-title function_">outFile</span><span class="hljs-params">(<span class="hljs-string">&quot;./output.root&quot;</span>, <span class="hljs-string">&quot;RECREATE&quot;</span>)</span>;<br><br><span class="hljs-comment">// Write datasets to the file</span><br>data-&gt;Write(<span class="hljs-string">&quot;unbinnedData&quot;</span>);<br>binnedData-&gt;Write(<span class="hljs-string">&quot;binnedData&quot;</span>);<br><br><span class="hljs-comment">// Close the file</span><br>outFile.Close();<br></code></pre></td></tr></table></figure>

<h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note 2"></a>Note 2</h4><ul>
<li>当我们想进行一些精细的拟合的时候往往需要unbinned的拟合，因为binned的数据会丢失部分数据细节，但相对的，拟合速度也会下降</li>
<li>unbinned的数据按道理来说像是分得无限细的binned的图，因此画出直方图的时候并不会这样操作，而是给他一个默认的bin值，从而更好地显示unbinned的数据。但是在拟合的时候还是会一个个数据点进行拟合。</li>
<li>如果你仔细看画出来的图你会发现，在低统计下的误差棒不是对称的。RooFit 默认显示泊松统计的 68% 置信区间，通常是不对称的，尤其是在低统计量下，如果直方图内容来自泊松过程，则可以更准确地反映每个箱中的统计不确定性。你可以选择将<code>DataError(RooAbsData::SumW2)</code>添加到<code>data.plotOn()</code>行来显示$\sqrt{N}$误差。这个选项只会影响数据集的可视化。</li>
</ul>
<h3 id="2-4-用模型拟合数据"><a href="#2-4-用模型拟合数据" class="headerlink" title="2.4 用模型拟合数据"></a>2.4 用模型拟合数据</h3><p>将模型拟合到数据中涉及从模型和数据构建检验统计量——最常见的选择是χ²和负对数似然——并针对所有未固定的参数最小化该检验统计量。RooFit中的默认拟合方法是对无分箱数据进行无分箱最大似然拟合，对分箱数据进行分箱最大似然拟合。</p>
<p>无论哪种情况，测试统计量都是由RooFit计算的，并且测试统计量的最小化是通过ROOT中的TMinuit实现的MINUIT来进行最小化和误差分析的。整个拟合过程的易用高级接口由类RooAbsPdf的fitTo()方法提供：<br><code>gauss.fitTo(data)</code><br>这条命令从高斯函数和给定的数据集中构建一个-log(L)函数，将其传递给MINUIT，MINUIT对其进行最小化并估计高斯参数的误差。fitTo()方法的输出在屏幕上产生熟悉的MINUIT输出：</p>
<center>
![alt text](image-48.png)
</center>

<p>拟合结果——新的参数值及其误差——会传回到表示高斯参数的RooRealVar对象中，如下面的代码片段所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mean.<span class="hljs-built_in">Print</span>() ;<br>RooRealVar::mean: <span class="hljs-number">-0.940910</span> +/- <span class="hljs-number">0.030400</span><br>sigma.<span class="hljs-built_in">Print</span>() ;<br>RooRealVar::sigma: <span class="hljs-number">3.0158</span> +/- <span class="hljs-number">0.022245</span><br></code></pre></td></tr></table></figure>

<p>因此，之后绘制的高斯函数将反映拟合后的新形状。现在我们在一个框架上绘制数据和拟合函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooPlot* xframe = x.<span class="hljs-built_in">frame</span>() ;<br>data.<span class="hljs-built_in">plotOn</span>(xframe) ;<br>model.<span class="hljs-built_in">plotOn</span>(xframe) ;<br>xframe-&gt;<span class="hljs-built_in">Draw</span>()<br></code></pre></td></tr></table></figure>

<p>该代码片段的结果如图4所示。</p>
<center>
![alt text](image-49.png)
</center>

<p>请注意，PDF 的归一化（本质上归一化为一）会自动调整为图中事件的数量。RooFit 的一个强大功能和其创建的主要原因之一是示例3中的拟合调用对分组数据和未分组数据都有效。在后一种情况下，会执行未分组的最大似然拟合。未分组的 -log(L) 拟合在统计上比分组拟合更有力（即，您将获得更小的均值误差），并且避免了由选择分组定义引入的任意性。这些优势在拟合小数据集和多维数据集时尤为明显。</p>
<p>拟合接口高度可定制。例如，如果您想在拟合中固定一个参数，只需将其指定为 RooRealVar 参数对象的一个属性，那么这个代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mean.<span class="hljs-built_in">setConstant</span>(kTRUE) ;<br>gauss.<span class="hljs-built_in">fitTo</span>(data) ;<br></code></pre></td></tr></table></figure>

<p>将参数 <code>mean</code> 固定为当前值重复拟合。同样，您可以选择将浮动参数限定在允许值范围内：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sigma.<span class="hljs-built_in">setRange</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">3</span>) ;<br>gauss.<span class="hljs-built_in">fitTo</span>(data) ;<br></code></pre></td></tr></table></figure>

<p>所有这些拟合配置信息都会自动传递给 MINUIT。可以通过传递给 <code>fitTo()</code> 命令的可选命名参数来控制 MINUIT 的高级方面。这个示例启用 MINOS 方法来计算不对称误差，并将 MINUIT 的详细级别设置为最低值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">gauss.<span class="hljs-built_in">fitTo</span>(data, RooFit::<span class="hljs-built_in">Minos</span>(<span class="hljs-literal">true</span>), RooFit::<span class="hljs-built_in">PrintLevel</span>(<span class="hljs-number">-1</span>)) ;<br></code></pre></td></tr></table></figure>

<h3 id="2-5-范围拟合"><a href="#2-5-范围拟合" class="headerlink" title="2.5 范围拟合"></a>2.5 范围拟合</h3><p>通过同样的接口可以影响似然函数的构建方式。要将似然（以及拟合）限制在指定范围内的事件子集上，可以这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">gauss.<span class="hljs-built_in">fitTo</span>(data, <span class="hljs-built_in">Range</span>(<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>)) ;<br></code></pre></td></tr></table></figure>

<p>随后对该拟合的绘图默认只会显示拟合范围内的曲线。</p>
<p>关于拟合中似然函数的构建、进阶使用选项以及 $\chi^2$ 拟合的构建细节将在第12章中详细介绍。所有可用的 <code>fitTo()</code> 命令参数的参考指南见附录E以及方法 <code>RooAbsPdf::fitTo()</code> 的<a target="_blank" rel="noopener" href="https://root.cern.ch/doc/v632/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5">在线代码文档</a>。</p>
<h3 id="2-6-从模型生成数据"><a href="#2-6-从模型生成数据" class="headerlink" title="2.6 从模型生成数据"></a>2.6 从模型生成数据</h3><p>所有 RooFit 的概率密度函数 (p.d.f.) 都有一个通用接口，用于从其分布中生成事件。各种从分布中采样事件的技术已实现并在附录A中描述。RooAbsPdf 的内部逻辑会自动为每个使用案例选择最有效的技术。</p>
<p>最简单的形式中，可以从 p.d.f. 生成一个 RooDataSet，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooDataSet* data = gauss.<span class="hljs-built_in">generate</span>(x, <span class="hljs-number">10000</span>) ;<br></code></pre></td></tr></table></figure>

<p>这个示例创建了一个包含 10000 个事件的 RooDataSet，这些事件的可观测量 x 是从 p.d.f. gauss 中采样的。</p>
<h3 id="2-7-参数和可观测量"><a href="#2-7-参数和可观测量" class="headerlink" title="2.7 参数和可观测量"></a>2.7 参数和可观测量</h3><p>在本章的简单示例中，我们一直使用高斯概率密度函数（p.d.f.），并且明确假设变量 (x) 是可观测量，而变量 (\mu)（均值）和 (\sigma)（标准差）是我们的参数。这一区分非常重要，因为它直接关系到对象的函数表达式：概率密度函数相对于其可观测量是单位归一化的，但相对于其参数则不是。</p>
<p>然而，RooFit 的 p.d.f 类本身在参数和可观测量之间没有固有的静态区分概念。这乍看之下可能令人困惑，但为我们在构建复合对象时提供了必要的灵活性。参数和可观测量之间的区分总是有的，但它是从每个使用上下文中动态产生的。以下示例展示了如何将高斯函数用作可观测量均值的 p.d.f.：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooDataSet* data = gauss.<span class="hljs-built_in">generate</span>(mean,<span class="hljs-number">1000</span>);<br>RooPlot* mframe = mean.<span class="hljs-built_in">frame</span>();<br>data-&gt;<span class="hljs-built_in">plotOn</span>(mframe);<br>gauss.<span class="hljs-built_in">plotOn</span>(mframe);<br></code></pre></td></tr></table></figure>

<p>鉴于高斯函数的数学表达式在 (x) 和 (m) 的互换下是对称的，因此不出所料，这在以 (x) 和 (\sigma) 为参数时，得到的是一个以 (m) 为可观测量的高斯分布。沿着同样的思路，也可以将高斯函数用作 (\sigma) 的 p.d.f.，以 (x) 和均值为参数。在许多情况下，不需要明确说明哪些变量是可观测量，因为其定义是从使用上下文中隐含地得出的。具体来说，只要一个使用上下文同时涉及 p.d.f. 和数据集，可观测量的隐含和自动定义是那些同时出现在数据集和 p.d.f. 定义中的变量。这种自动定义在拟合中很有效，因为拟合涉及一个显式的数据集，但也适用于绘图：RooPlot 框架变量始终被认为是可观测量。在其他所有涉及区分的上下文中，必须手动提供哪些变量被视为可观测量的定义。这就是为什么调用 <code>generate()</code> 时必须在每次调用中指定你认为的可观测量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooDataSet* data = gauss.<span class="hljs-built_in">generate</span>(x,<span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure>

<p>然而，在高斯函数的所有三种可能的用例中，它相对于（隐含声明的）可观测量都是一个适当归一化的概率密度函数。这突显了 RooFit “动态可观测量”概念的重要后果：RooAbsPdf 对象没有唯一的返回值，它取决于可观测量的局部定义。通过在 <code>RooAbsPdf::getVal()</code> 中的一个显式的事后归一化步骤实现了这种功能，这个步骤对于每种可观测量的定义是不同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Double_t gauss_raw = gauss.<span class="hljs-built_in">getVal</span>(); <span class="hljs-comment">// 未归一化的原始值</span><br>Double_t gauss_pdfX = gauss.<span class="hljs-built_in">getVal</span>(x); <span class="hljs-comment">// 用作 x 的 p.d.f 时的值</span><br>Double_t gauss_pdfM = gauss.<span class="hljs-built_in">getVal</span>(mean); <span class="hljs-comment">// 用作 mean 的 p.d.f 时的值</span><br>Double_t gauss_pdfS = gauss.<span class="hljs-built_in">getVal</span>(sigma); <span class="hljs-comment">// 用作 sigma 的 p.d.f 时的值</span><br></code></pre></td></tr></table></figure>

<h3 id="2-8-计算模型上的积分"><a href="#2-8-计算模型上的积分" class="headerlink" title="2.8 计算模型上的积分"></a>2.8 计算模型上的积分</h3><p>在 RooFit 中，概率密度函数（p.d.f.）和函数的积分被表示为独立的对象。因此，与其将积分定义为一个动作，不如说积分是通过一个继承自 RooAbsReal 的对象来定义的，其值是通过积分操作计算得到的。这样的对象可以通过 <code>createIntegral()</code> 方法或 RooAbsReal 来构造。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooAbsReal* intGaussX = gauss.<span class="hljs-built_in">createIntegral</span>(x);<br></code></pre></td></tr></table></figure>

<p>任何 RooAbsReal 函数或 RooAbsPdf 都可以通过这种方式进行积分。注意，对于 p.d.f.s，上述配置会对 gauss 的原始（未归一化）值进行积分。实际上，gauss 的归一化返回值 <code>gauss.getVal(x)</code> 恰好是 <code>gauss.getVal() / intGaussX-&gt;getVal()</code>。</p>
<p>大多数积分由 RooRealIntegral 类的对象表示。构造此类时，会确定执行积分请求的最有效方法。如果被积分函数支持对所请求的可观测量进行解析积分，则会使用解析实现【5】；否则，将选择数值技术。实际的积分并不是在构造时进行的，而是在调用 <code>RooRealIntegral::getVal()</code> 时按需进行。一旦计算出来，积分值会被缓存，并在积分参数的值发生变化或者（一个或多个）积分可观测量的归一化范围发生变化时失效。</p>
<p>你可以通过打印积分对象来检查选择的积分策略：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">intGaussX-&gt;<span class="hljs-built_in">Print</span>(<span class="hljs-string">&quot;v&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--- RooRealIntegral ---</span><br>Integrates g[ x<span class="hljs-operator">=</span>x mean<span class="hljs-operator">=</span>m sigma<span class="hljs-operator">=</span>s ]<br>operating mode <span class="hljs-keyword">is</span> Analytic<br>Summed discrete args <span class="hljs-keyword">are</span> ()<br>Numerically integrated args <span class="hljs-keyword">are</span> ()<br>Analytically integrated args <span class="hljs-keyword">using</span> mode <span class="hljs-number">1</span> <span class="hljs-keyword">are</span> (x)<br>Arguments included <span class="hljs-keyword">in</span> Jacobian <span class="hljs-keyword">are</span> ()<br>Factorized arguments <span class="hljs-keyword">are</span> ()<br><span class="hljs-keyword">Function</span> normalization <span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">none</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>

<p>这一输出说明了以下几点：</p>
<ul>
<li>被积分的函数 ( g ) 和涉及的参数 ( x, \mu, \sigma )。</li>
<li>操作模式为解析积分（Analytic）。</li>
<li>无需求和的离散参数。</li>
<li>无需数值积分的参数。</li>
<li>( x ) 参数使用了模式 1 的解析积分。</li>
<li>雅可比矩阵中包含的参数为空。</li>
<li>无需因式分解的参数。</li>
<li>无设置的函数归一化。</li>
</ul>
<h3 id="2-9-归一化概率密度函数-p-d-f"><a href="#2-9-归一化概率密度函数-p-d-f" class="headerlink" title="2.9 归一化概率密度函数(p.d.f.)"></a>2.9 归一化概率密度函数(p.d.f.)</h3><p>也可以构造归一化p.d.f.的积分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooAbsReal* intGaussX = gauss.<span class="hljs-built_in">createIntegral</span>(x,<span class="hljs-built_in">NormSet</span>(x)) ;<br></code></pre></td></tr></table></figure>

<p>这个例子并没有太大实际用途，因为它总是返回1，但使用相同的接口，也可以在观测变量的预定义子区间上进行积分，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x.<span class="hljs-built_in">setRange</span>(<span class="hljs-string">&quot;signal&quot;</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>) ;<br>RooAbsReal* intGaussX = gauss.<span class="hljs-built_in">createIntegral</span>(x,<span class="hljs-built_in">NormSet</span>(x),<span class="hljs-built_in">Range</span>(<span class="hljs-string">&quot;signal&quot;</span>)) ;<br></code></pre></td></tr></table></figure>

<p>以提取模型在“信号”区间内的部分。诸如“信号”之类的命名区间的概念将在第3章和第7章详细阐述。归一化p.d.f.积分的返回值自然位于[0,1]范围内。</p>
<h3 id="2-10-累积分布函数"><a href="#2-10-累积分布函数" class="headerlink" title="2.10 累积分布函数"></a>2.10 累积分布函数</h3><p>积分p.d.f.的一种特殊形式是累积分布函数（c.d.f.），其定义如下，并且可以通过专门的方法createCdf()从任何p.d.f.构造：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooAbsReal* cdf = pdf-&gt;<span class="hljs-built_in">createCdf</span>(x) ;<br></code></pre></td></tr></table></figure>

<p>图6展示了从高斯p.d.f.创建的c.d.f.的一个例子。对于这种形式的积分，createCdf()相对于createIntegral()的优势在于前者能够更有效地处理需要数值积分的p.d.f.：createIntegral()在一个或多个参数变化后会从头开始重新计算整个数值积分，而createCdf()则会缓存数值积分采样阶段的结果，只重新计算求和部分。有关积分和累积分布函数的更多细节见附录C。</p>
<h2 id="2-信号和背景-–-复合模型介绍"><a href="#2-信号和背景-–-复合模型介绍" class="headerlink" title="2 信号和背景 – 复合模型介绍"></a>2 信号和背景 – 复合模型介绍</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>数据模型通常用于描述包含多种事件假设的样本，例如信号和（一个或多个类型的）背景。为了描述这种性质的样本，可以构建一个复合模型。对于事件假设‘信号’和‘背景’，复合函数M(x)可以通过描述信号的函数S(x)和描述背景的函数B(x)构建，如下所示：</p>
<p>$ M(x) &#x3D; fS(x) + (1 - f)B(x) $</p>
<p>在这个公式中，( f ) 是样本中信号事件的比例。多个假设的通用表达式为：</p>
<p>$ M(x) &#x3D; \sum_{i&#x3D;1}^{N-1} f_i F_i(x) + \left(1 - \sum_{i&#x3D;1}^{N-1} f_i \right) F_N(x) $</p>
<p>这种方式添加p.d.f.的一个特性是，M(x)不需要特意地归一化为1：如果S(x)和B(x)都是归一化为1的，那么通过这种构造，M(x)也是归一化的。RooFit提供了一个特殊的‘加法运算符’p.d.f.在RooAddPdf类中，以简化构建和使用这种复合p.d.f.。</p>
<h4 id="扩展似然方法"><a href="#扩展似然方法" class="headerlink" title="扩展似然方法"></a>扩展似然方法</h4><p>测量结果通常以事件数而非事件比例的形式引用，因此，直接用信号和背景事件的数量而不是信号事件的比例（和总事件数）来表示数据模型是很有用的。具体表达如下：</p>
<p>$M_E(x) &#x3D; N_S S(x) + N_B B(x) $</p>
<p>在这个表达式中，( M_E(x) ) 不是归一化为1，而是归一化为 ( N_S + N_B &#x3D; N )，即数据样本中的事件总数。因此，这不是一个严格的概率密度函数，而是两个表达式的简写：分布的形状和期望事件数。</p>
<p>$M(x) &#x3D; \left(\frac{N_S}{N_S + N_B}\right) S(x) + \left(\frac{N_B}{N_S + N_B}\right) B(x) $</p>
<p>$\text{Expected } N &#x3D; N_S + N_B $</p>
<p>在扩展似然方法中，可以联合约束这些表达式：</p>
<p>$-\log L(p) &#x3D; -\sum_{\text{data}} \log M(x_i) -  \log \text{Poisson}( N_{\text{expected}} - N_{\text{expected}}) $</p>
<p>在RooFit中，普通的加和 ( ( N_{\text{coef}} &#x3D; N_{\text{pdf}} - 1 ) ) 和扩展似然加和 ( ( N_{\text{coef}} &#x3D; N_{\text{pdf}} ) ) 都由运算符类RooAddPdf表示，后者会自动构建扩展似然项。</p>
<h3 id="2-2-构建具有分数系数的复合模型"><a href="#2-2-构建具有分数系数的复合模型" class="headerlink" title="2.2 构建具有分数系数的复合模型"></a>2.2 构建具有分数系数的复合模型</h3><p>我们首先从简单（非扩展）复合模型的描述开始。以下是使用分数系数通过RooAddPdf构建复合概率密度函数（PDF）的一个简单示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)</span>;<br>RooRealVar <span class="hljs-title function_">mean</span><span class="hljs-params">(<span class="hljs-string">&quot;mean&quot;</span>, <span class="hljs-string">&quot;mean&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigma</span><span class="hljs-params">(<span class="hljs-string">&quot;sigma&quot;</span>, <span class="hljs-string">&quot;sigma&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">10.</span>)</span>;<br>RooGaussian <span class="hljs-title function_">sig</span><span class="hljs-params">(<span class="hljs-string">&quot;sig&quot;</span>, <span class="hljs-string">&quot;signal p.d.f.&quot;</span>, x, mean, sigma)</span>;<br><br>RooRealVar <span class="hljs-title function_">c0</span><span class="hljs-params">(<span class="hljs-string">&quot;c0&quot;</span>, <span class="hljs-string">&quot;coefficient #0&quot;</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.</span>, <span class="hljs-number">1.</span>)</span>;<br>RooRealVar <span class="hljs-title function_">c1</span><span class="hljs-params">(<span class="hljs-string">&quot;c1&quot;</span>, <span class="hljs-string">&quot;coefficient #1&quot;</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">-1.</span>, <span class="hljs-number">1.</span>)</span>;<br>RooRealVar <span class="hljs-title function_">c2</span><span class="hljs-params">(<span class="hljs-string">&quot;c2&quot;</span>, <span class="hljs-string">&quot;coefficient #2&quot;</span>, <span class="hljs-number">-0.1</span>, <span class="hljs-number">-1.</span>, <span class="hljs-number">1.</span>)</span>;<br>RooChebychev <span class="hljs-title function_">bkg</span><span class="hljs-params">(<span class="hljs-string">&quot;bkg&quot;</span>, <span class="hljs-string">&quot;background p.d.f.&quot;</span>, x, RooArgList(c0, c1, c2))</span>;<br><br><span class="hljs-comment">// model(x) = fsig*sig(x) + (1-fsig)*bkg(x)</span><br>RooAddPdf <span class="hljs-title function_">model</span><span class="hljs-params">(<span class="hljs-string">&quot;model&quot;</span>, <span class="hljs-string">&quot;model&quot;</span>, RooArgList(sig, bkg), fsig)</span>;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们首先构建一个高斯概率密度函数(sig)和一个平坦的背景概率密度函数(bkg)，然后使用信号分数(fsig)将它们加在一起构成模型。请注意，使用容器类RooArgList来作为函数的单一参数传递对象列表。RooFit有两个容器类：RooArgList和RooArgSet。每个容器类可以包含任意数量的RooFit值对象，即任何继承自RooAbsArg的对象，如RooRealVar、RooAbsPdf等。区别在于列表list是有序的，可以通过位置引用（第2个，第3个等）访问元素，并且可以包含多个同名对象，而集合set是无序的，但要求每个成员有唯一的名称。</p>
<p>RooAddPdf实例可以将任意数量的成分相加，要用两个系数添加三个概率密度函数，可以写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// model2(x) = fsig*sig(x) + fbkg1*bkg1(x) + (1-fsig-fbkg)*bkg2(x) </span><br>RooAddPdf <span class="hljs-title function_">model2</span><span class="hljs-params">(<span class="hljs-string">&quot;model2&quot;</span>,<span class="hljs-string">&quot;model2&quot;</span>,RooArgList(sig,bkg1,bkg2), RooArgList(fsig,fbkg1))</span> ;<br></code></pre></td></tr></table></figure>


<p>要构建一个非扩展的概率密度函数，其中系数被解释为分数，那么系数的数量应总是比概率密度函数的数量少一个。</p>
<h4 id="使用RooAddPdf递归"><a href="#使用RooAddPdf递归" class="headerlink" title="使用RooAddPdf递归"></a>使用RooAddPdf递归</h4><p>请注意，RooAddPdf的输入p.d.f.不需要是基本的p.d.f.，它们本身可以是复合p.d.f.。请看下面这个使用了Example 7中的sig和bkg作为输入的例子：</p>
<p>例子5 – 通过递归添加两项来添加三个p.d.f.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 构造第三个pdf bkg_peak</span><br><span class="hljs-function">RooRealVar <span class="hljs-title">mean_bkg</span><span class="hljs-params">(<span class="hljs-string">&quot;mean_bkg&quot;</span>,<span class="hljs-string">&quot;mean&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">RooRealVar <span class="hljs-title">sigma_bkg</span><span class="hljs-params">(<span class="hljs-string">&quot;sigma_bkg&quot;</span>,<span class="hljs-string">&quot;sigma&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0.</span>,<span class="hljs-number">10.</span>)</span></span>;<br><span class="hljs-function">RooGaussian <span class="hljs-title">bkg_peak</span><span class="hljs-params">(<span class="hljs-string">&quot;bkg_peak&quot;</span>,<span class="hljs-string">&quot;peaking bkg p.d.f.&quot;</span>,x,mean_bkg,sigma_bkg)</span></span>;<br><br><span class="hljs-comment">// 首先将sig和peak以fpeak的比例相加</span><br><span class="hljs-function">RooRealVar <span class="hljs-title">fpeak</span><span class="hljs-params">(<span class="hljs-string">&quot;fpeak&quot;</span>,<span class="hljs-string">&quot;peaking background fraction&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.</span>,<span class="hljs-number">1.</span>)</span></span>;<br><span class="hljs-function">RooAddPdf <span class="hljs-title">sigpeak</span><span class="hljs-params">(<span class="hljs-string">&quot;sigpeak&quot;</span>,<span class="hljs-string">&quot;sig+peak&quot;</span>,RooArgList(bkg_peak,sig),fpeak)</span></span>;<br><br><span class="hljs-comment">// 然后将(sig+peak)以fbkg的比例与bkg相加</span><br><span class="hljs-function">RooRealVar <span class="hljs-title">fbkg</span><span class="hljs-params">(<span class="hljs-string">&quot;fbkg&quot;</span>,<span class="hljs-string">&quot;background fraction&quot;</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.</span>,<span class="hljs-number">1.</span>)</span></span>;<br><span class="hljs-function">RooAddPdf <span class="hljs-title">model</span><span class="hljs-params">(<span class="hljs-string">&quot;model&quot;</span>,<span class="hljs-string">&quot;bkg+(sig+peak)&quot;</span>,RooArgList(bkg,sigpeak),fbkg)</span></span>;<br></code></pre></td></tr></table></figure>

<p>最终的p.d.f.模型表示如下表达式：<br>$M(x) &#x3D; f_{\text{bkg}} B(x) + (1 - f_{\text{bkg}}) \left[ f_{\text{peak}} P(x) + (1 - f_{\text{peak}}) S(x) \right] $</p>
<p>也可以通过单个RooAddPdf的递归模式构建这样的递归加法公式。在这种构造模式下，系数的解释如下：<br>$M(x) &#x3D; f_1 P_1 + (1 - f_1) \left[ f_2 P_2 + (1 - f_2) \left[ f_3 P_3 + (1 - f_3) P_4 \right] \right] $</p>
<p>例如，要构建与上面模型对象功能等价的模型，可以写成：</p>
<p>例子6 – 使用RooAddPdf的递归模式递归地添加三个p.d.f.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">RooAddPdf <span class="hljs-title">model</span><span class="hljs-params">(<span class="hljs-string">&quot;model&quot;</span>,<span class="hljs-string">&quot;recursive addition model&quot;</span>, RooArgList(bkg, bkg_peak, sig), RooArgList(fbkg, fpeak, fsig), kTRUE)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这样，最终模型的形式与例子5中的递归加法表达式等效。<br>$M(x)&#x3D;(f_1F_1+(1-f_1)(f_2F_2+(1-f_2)(f_3F_3+(1-f_3)(f_4F_4+(1-f_4)F_5))))$</p>
<h3 id="2-3-绘制复合模型"><a href="#2-3-绘制复合模型" class="headerlink" title="2.3 绘制复合模型"></a>2.3 绘制复合模型</h3><p>复合p.d.f.的模块化结构允许你处理各个单独的组件。例如，可以在模型上绘制复合模型的各个组件，以可视化其结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooPlot* frame = x.<span class="hljs-built_in">frame</span>();<br>model.<span class="hljs-built_in">plotOn</span>(frame);<br>model.<span class="hljs-built_in">plotOn</span>(frame, <span class="hljs-built_in">Components</span>(bkg), <span class="hljs-built_in">LineStyle</span>(kDashed));<br>frame-&gt;<span class="hljs-built_in">Draw</span>();<br></code></pre></td></tr></table></figure>

<p>上述代码片段的输出如图7所示。组件图以虚线样式绘制。有关绘图样式选项的完整概述，请参见附录C。</p>
<p>你可以通过对象引用来识别组件，如上所示，或者通过名称来识别组件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">model.<span class="hljs-built_in">plotOn</span>(frame, <span class="hljs-built_in">Components</span>(<span class="hljs-string">&quot;bkg&quot;</span>),<span class="hljs-built_in">LineStyle</span>(kDashed)) ;<br></code></pre></td></tr></table></figure>

<p>如果你的绘图代码无法访问组件对象，例如，如果你的模型是在一个只返回顶级RooAddPdf对象的独立函数中构建的，那么后一种方法非常方便。</p>
<p>如果你想绘制多个组件的和，也可以通过两种方式实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">model.<span class="hljs-built_in">plotOn</span>(frame, <span class="hljs-built_in">Components</span>(<span class="hljs-built_in">RooArgSet</span>(bkg1, bkg2)), <span class="hljs-built_in">LineStyle</span>(kDashed));<br>model.<span class="hljs-built_in">plotOn</span>(frame, <span class="hljs-built_in">Components</span>(<span class="hljs-string">&quot;bkg1,bkg2&quot;</span>), <span class="hljs-built_in">LineStyle</span>(kDashed));<br></code></pre></td></tr></table></figure>

<p>请注意，在后一种形式中，允许使用通配符，因此如果选择一个合适的组件命名方案，例如，可以这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">RooAddPdf <span class="hljs-title">model</span><span class="hljs-params">(<span class="hljs-string">&quot;model&quot;</span>, <span class="hljs-string">&quot;bkg+(sig+peak)&quot;</span>, RooArgList(bkg, peak, bkg), RooArgList(fbkg, fpeak), kTRUE)</span></span>;<br>model.<span class="hljs-built_in">plotOn</span>(frame, <span class="hljs-built_in">Components</span>(<span class="hljs-string">&quot;bkg&quot;</span>), <span class="hljs-built_in">LineStyle</span>(kDashed));<br>model.<span class="hljs-built_in">plotOn</span>(frame, <span class="hljs-built_in">Components</span>(<span class="hljs-string">&quot;bkg*&quot;</span>), <span class="hljs-built_in">LineStyle</span>(kDashed));<br></code></pre></td></tr></table></figure>

<p>如果需要，可以在逗号分隔的列表中指定多个通配符表达式。<br><img src="/postfigure/roofit_manual/image-53.png" srcset="/img/loading.gif" lazyload alt="alt text"></p>
<h3 id="2-4-使用复合模型"><a href="#2-4-使用复合模型" class="headerlink" title="2.4 使用复合模型"></a>2.4 使用复合模型</h3><h4 id="拟合复合模型"><a href="#拟合复合模型" class="headerlink" title="拟合复合模型"></a>拟合复合模型</h4><p>拟合带有分数系数的复合模型与拟合任何其他模型没有区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">model.<span class="hljs-built_in">fitTo</span>(data);<br></code></pre></td></tr></table></figure>

<p>模型的参数包括组件p.d.f.的参数以及由加法运算符类引入的分数参数。</p>
<h4 id="使用多个分数拟合的常见陷阱"><a href="#使用多个分数拟合的常见陷阱" class="headerlink" title="使用多个分数拟合的常见陷阱"></a>使用多个分数拟合的常见陷阱</h4><p>在涉及直（非递归）加法多个组件的模型中定义分数参数的允许范围时，需要注意一些事项。如果两个组件通过一个分数相加，那么该分数的自然范围是$0,1$。但是，如果添加了多个组件，就会有多个分数。尽管将每个分数的允许范围保持在$0,1$是合法的，但这可能会导致系数之和超过1的配置，例如当$f_1 &#x3D; f_2 &#x3D; 0.7$时。如果发生这种情况，最后的系数（自动计算为$1 - \sum_{i&#x3D;1}^{N-1} f_i$）将变为负数。</p>
<p>如果在拟合过程中出现这种配置，RooFit将在每次发生时打印警告消息，但只要在似然评估的每个点上RooAddPdf的返回值仍为正，就不会采取任何措施。如果你想避免这种配置，有几种选择。</p>
<p>一种方法是使用RooRealVar::setRange()收紧所有分数的允许范围，使它们相加时永远不会超过1。这种方法需要一些关于你拟合的分布的知识，以避免禁止最佳拟合配置。</p>
<p>另一种方法是使用递归加法，在这种方法中，分数值范围$0,1$的每种排列都会生成有效的正定复合pdf。这种方法改变了系数的解释，但对要建模的分布形状不做任何假设。</p>
<p>第三种方法是使用扩展的似然拟合，其中所有系数都明确指定，没有隐式计算的剩余分数变为负数的可能性。</p>
<h4 id="使用复合模型生成数据"><a href="#使用复合模型生成数据" class="headerlink" title="使用复合模型生成数据"></a>使用复合模型生成数据</h4><p>使用复合模型生成事件的接口与使用基本模型生成事件的接口相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 生成10000个事件</span><br>RooDataSet* x = model.<span class="hljs-built_in">generate</span>(x,<span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure>

<p>在内部，RooFit将利用p.d.f.的复合结构，并将事件生成委托给组件p.d.f.的方法，这通常更有效。</p>
<h3 id="2-5-构建扩展复合模型"><a href="#2-5-构建扩展复合模型" class="headerlink" title="2.5 构建扩展复合模型"></a>2.5 构建扩展复合模型</h3><p>为了构建可以与扩展似然拟合一起使用的复合p.d.f.，需要为每个组件指定相应的系数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">RooRealVar <span class="hljs-title">nsig</span><span class="hljs-params">(<span class="hljs-string">&quot;nsig&quot;</span>,<span class="hljs-string">&quot;signal fraction&quot;</span>,<span class="hljs-number">500</span>,<span class="hljs-number">0.</span>,<span class="hljs-number">10000.</span>)</span> </span>; <br><span class="hljs-function">RooRealVar <span class="hljs-title">nbkg</span><span class="hljs-params">(<span class="hljs-string">&quot;nbkg&quot;</span>,<span class="hljs-string">&quot;background fraction&quot;</span>,<span class="hljs-number">500</span>,<span class="hljs-number">0.</span>,<span class="hljs-number">10000.</span>)</span> </span>;<br><span class="hljs-function">RooAddPdf <span class="hljs-title">model</span><span class="hljs-params">(<span class="hljs-string">&quot;model&quot;</span>, <span class="hljs-string">&quot;model&quot;</span>, RooArgList(sig, bkg), RooArgList(nsig, nbkg))</span></span>;<br></code></pre></td></tr></table></figure>

<p>示例 7 – 使用两个事件计数系数添加两个 p.d.f.</p>
<p>在这个例子中，系数参数的允许范围已经调整为可以容纳事件计数而不是分数。从实际角度来看，示例 7 和示例 4 构建的模型之间的区别在于，示例 7 中的 RooAbsPdf 对象模型可以通过其成员函数 <code>expectedEvents()</code> 预测预期的数据事件数（即 nsig + nbkg），而示例 4 中的模型不能。示例 7 形式通过将每个系数除以所有系数的总和来得到组件分数。</p>
<p>还可以构建两个或多个已经是扩展 p.d.f. 的组件 p.d.f. 的和，在这种情况下，无需提供系数来构建扩展和 p.d.f.。这些输入可以是之前构建的 RooAddPdfs（使用扩展模式选项）或通过 RooExtendPdf 实用程序 p.d.f. 扩展的普通 p.d.f.。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">RooRealVar <span class="hljs-title">nsig</span><span class="hljs-params">(<span class="hljs-string">&quot;nsig&quot;</span>, <span class="hljs-string">&quot;signal fraction&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">10000.</span>)</span></span>;<br><span class="hljs-function">RooRealVar <span class="hljs-title">nbkg</span><span class="hljs-params">(<span class="hljs-string">&quot;nbkg&quot;</span>, <span class="hljs-string">&quot;background fraction&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">10000.</span>)</span></span>;<br><span class="hljs-function">RooExtendPdf <span class="hljs-title">esig</span><span class="hljs-params">(<span class="hljs-string">&quot;esig&quot;</span>, <span class="hljs-string">&quot;esig&quot;</span>, sig, nsig)</span></span>;<br><span class="hljs-function">RooExtendPdf <span class="hljs-title">ebkg</span><span class="hljs-params">(<span class="hljs-string">&quot;ebkg&quot;</span>, <span class="hljs-string">&quot;ebkg&quot;</span>, bkg, nbkg)</span></span>;<br><span class="hljs-function">RooAddPdf <span class="hljs-title">model</span><span class="hljs-params">(<span class="hljs-string">&quot;model&quot;</span>, <span class="hljs-string">&quot;model&quot;</span>, RooArgList(esig, ebkg))</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="范围内信号事件产量"><a href="#范围内信号事件产量" class="headerlink" title="范围内信号事件产量"></a>范围内信号事件产量</h3><p><img src="/postfigure/roofit_manual/image-54.png" srcset="/img/loading.gif" lazyload alt="图8"></p>
<p>假设你对图 8 中模型的范围$4,6$内的信号事件产量感兴趣：</p>
<p>你可以通过将总信号产量乘以信号 p.d.f. 形状在范围$4,6$内的分数来计算这一点，但仍然需要手动传递信号产量和形状分数积分的误差到最终结果。RooExtendPdf 类提供了在预期事件数的计算中立即应用转换的可能性，以便似然函数，从而拟合结果，直接以 nsigWindow 表示，并且所有误差都会自动正确传播。</p>
<p>这种修改的效果是 esig 返回的预期事件数变为：</p>
<p>$N_{\text{sig}}^{\text{expected}} &#x3D; N_{\text{sig}}^{\text{ window}} \int_{4}^{6} S(x) , dx $</p>
<p>这样，在最小化扩展最大似然后，nsigw 等于信号窗口中事件数的最佳估计值。关于范围内积分和归一化操作的更多详细信息，请参见附录 D。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x.<span class="hljs-built_in">setRange</span>(<span class="hljs-string">&quot;window&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>RooAbsReal* fracSigRange = sig.<span class="hljs-built_in">createIntegral</span>(x, x, <span class="hljs-string">&quot;window&quot;</span>);<br>Double_t nsigWindow = nsig.<span class="hljs-built_in">getVal</span>() * fracSigRange-&gt;<span class="hljs-built_in">getVal</span>();<br><span class="hljs-comment">//先计算窗口区的信号比例，再用总信号数*窗口区比例=窗口区的信号数，但不能传递误差</span><br><span class="hljs-function">RooRealVar <span class="hljs-title">nsigw</span><span class="hljs-params">(<span class="hljs-string">&quot;nsigw&quot;</span>, <span class="hljs-string">&quot;nsignal in window&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10000.</span>)</span></span>;<br><span class="hljs-function">RooExtendPdf <span class="hljs-title">esig</span><span class="hljs-params">(<span class="hljs-string">&quot;esig&quot;</span>, <span class="hljs-string">&quot;esig&quot;</span>, sig, nsigw, <span class="hljs-string">&quot;window&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>通过这种方式，您可以在拟合时直接得到信号窗口内的事件数及其误差。</p>
<h3 id="使用扩展复合模型生成事件"><a href="#使用扩展复合模型生成事件" class="headerlink" title="使用扩展复合模型生成事件"></a>使用扩展复合模型生成事件</h3><h4 id="从扩展模型生成事件"><a href="#从扩展模型生成事件" class="headerlink" title="从扩展模型生成事件"></a>从扩展模型生成事件</h4><p>一些额外的特性适用于为扩展似然形式构建的复合模型。由于这些模型预测了一定数量的事件，因此可以省略请求生成的事件数量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooDataSet* x = model.<span class="hljs-built_in">generate</span>(x);<br></code></pre></td></tr></table></figure>

<p>在这种情况下，将生成由概率密度函数（p.d.f.）预测的事件数量。您还可以选择通过 <code>Extended()</code> 参数引入泊松波动到生成的事件数量中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RooDataSet* x = model.<span class="hljs-built_in">generate</span>(x, <span class="hljs-built_in">Extended</span>(kTRUE));<br></code></pre></td></tr></table></figure>

<p>如果您在研究中生成了许多样本并查看拉量分布，这是非常有用的。为了使事件计数参数的拉量分布正确，生成的事件总数应存在泊松波动。关于拟合研究和拉量分布的详细内容，请参见第14章。</p>
<h4 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h4><p>复合扩展概率密度函数（p.d.f.）只有在包含扩展似然项进行最小化时才能成功拟合，因为它们在参数化中有一个由该扩展项约束的额外自由度。如果一个概率密度函数能够计算扩展项（例如任何扩展的 <code>RooAddPdf</code> 对象），则扩展项会自动包含在似然计算中。您可以通过在 <code>fitTo()</code> 调用中添加 <code>Extended()</code> 参数手动覆盖此默认行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">model.<span class="hljs-built_in">fitTo</span>(data, <span class="hljs-built_in">Extended</span>(kTRUE)); <span class="hljs-comment">// 可选</span><br></code></pre></td></tr></table></figure>

<h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h4><p>扩展似然模型的可视化默认程序与常规概率密度函数相同：用于归一化的事件计数是添加到绘图框架中的最后一个数据集的事件计数。您可以选择覆盖此行为并使用概率密度函数的预期事件计数进行归一化，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">model.<span class="hljs-built_in">plotOn</span>(frame, <span class="hljs-built_in">Normalization</span>(<span class="hljs-number">1.0</span>, RooAbsReal::RelativeExtended));<br></code></pre></td></tr></table></figure>




                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/15/VS_Code_and_extension/" title="VS Code and Extension">
                        <span class="hidden-mobile">VS Code and Extension</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      
<i class="iconfont icon-love"></i> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
