

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/Z001.ico">
  <link rel="icon" href="/img/Z001.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Feng Zhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文涉及较为深入的高能物理的代码解析和理论知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="multilep learning note">
<meta property="og:url" content="http://iceinke.github.io/2024/10/11/multilepnote/index.html">
<meta property="og:site_name" content="Feng Zhu&#39;s Blog">
<meta property="og:description" content="本文涉及较为深入的高能物理的代码解析和理论知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://iceinke.github.io/img/post5.jpg">
<meta property="article:published_time" content="2024-10-11T13:13:02.842Z">
<meta property="article:modified_time" content="2024-10-15T11:16:41.002Z">
<meta property="article:author" content="Feng Zhu">
<meta property="article:tag" content="multilep">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://iceinke.github.io/img/post5.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>multilep learning note - Feng Zhu&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"iceinke.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":250,"cursorChar":" ","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Feng</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post3.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">multilep learning note</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">multilep learning note</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年10月15日
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p><a href="/download/multilepnote.pdf">下载文章</a></p>
</blockquote>
<h2 id="0-序"><a href="#0-序" class="headerlink" title="0-序"></a>0-序</h2><p>终端中的vim编辑器面对这样的大型代码会异常难用，特别是像lpc这种延迟很高的服务器，强烈建议使用vscode和各种插件方便你的工作！<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">下载vscode</a> </p>
<p><img src="/postfigure/multilepnote/image-18.png" srcset="/img/loading.gif" lazyload> </p>
<p>这三个插件可以ssh登录到集群，推荐登录hepthu集群体验会很好，下面的插件可以选择安装</p>
<p><img src="/postfigure/multilepnote/image.png" srcset="/img/loading.gif" lazyload alt="" style="zoom:150%;" /><img src="/postfigure/multilepnote/image-1.png" srcset="/img/loading.gif" lazyload></p>
<p>本篇note只会介绍程序的逻辑关系以及需要用到的变量设置，会有很多未涉及的细节部分，比如这个变量为什么要这样用，为什么这个函数要加这个变量等。对于这些问题一部分是我并不清楚该如何解释，还有大部分是底层代码的关系，你可以在<a target="_blank" rel="noopener" href="https://cmsdoxygen.web.cern.ch/cmsdoxygen/">CMSSW Reference Manual (cern.ch)</a>中查到对应的变量的用法。比如你可以在pat::Muon里面找到MuonID的函数，会发现<code>isSoftMuon</code>里面需要一个<code>reco::Vertex</code>的变量，而<code>isLooseMuon</code>则不需要，你还能在里面找到更详细的关于MuonID的介绍。你还可以在<a target="_blank" rel="noopener" href="https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookCMSSWFramework">WorkBookCMSSWFramework &lt; CMSPublic &lt; TWiki (cern.ch)</a>中找到更详细的关于CMSSW work。</p>
<p><img src="/postfigure/multilepnote/image-20240809212857446.png" srcset="/img/loading.gif" lazyload alt="" style="zoom:50%;" /><img src="/postfigure/multilepnote/image-20240809213052779.png" srcset="/img/loading.gif" lazyload><img src="/postfigure/multilepnote/image-20240809213635011.png" srcset="/img/loading.gif" lazyload alt="" style="zoom:50%;" /></p>
<p>Tip: Here are the empty files in following path, you can copy it to your work directory using <strong><code>cmsrel CMSSW_13_0_13</code></strong> cms-software version because of the root file we will use. I also dropped some hints in the corresponding folder named as ‘_hint’. So, if and only if you are stuck, you can get some helps with it.<br>ps: hepthu集群在cmsRun时会出现问题，推荐在lxplus集群上进行下面的工作</p>
<blockquote>
<p>&#x2F;home&#x2F;storage0&#x2F;users&#x2F;zhufeng&#x2F;formymultilep_learning&#x2F;UserCode<br>&#x2F;afs&#x2F;cern.ch&#x2F;user&#x2F;z&#x2F;zhuf&#x2F;public&#x2F;UserCode&#x2F;MuMuEEPat&#x2F;</p>
</blockquote>
<h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1-文件结构"></a>1-文件结构</h2><p>MuMuEEPat.h 头文件用于声明函数变量等，不包含具体实现的细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MuMuEEPat</span> : <span class="hljs-keyword">public</span> edm::one::EDAnalyzer&lt;edm::one::SharedResources&gt;&#123;<br><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//public成员可以从类的外部访问,任何对象或者函数都可以访问类的public成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MuMuEEPat</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::ParameterSet&amp;)</span></span>; <span class="hljs-comment">//初始化</span><br>  ~<span class="hljs-built_in">MuMuEEPat</span>();<br>  <br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//private成员只能从类的内部访问。只有类的成员函数可以访问类的private成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">beginJob</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">beginRun</span><span class="hljs-params">(edm::Run <span class="hljs-type">const</span> &amp; iRun, edm::EventSetup <span class="hljs-type">const</span>&amp; iSetup)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp;, <span class="hljs-type">const</span> edm::EventSetup&amp;)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endJob</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//你可以不用理解上面在干什么，copy it directly!</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>MuMuEEPat.cc 源文件中就是具体分析过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++">MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>&#123;<br><span class="hljs-comment">//进行变量的初始化</span><br>&#125;<br><br>MuMuEEPat::~<span class="hljs-built_in">MuMuEEPat</span>()<br>&#123;<br><span class="hljs-comment">//未知（清除缓存？</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::beginJob</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//在进行analyze的循环之前运行的部分，这里就需要定义你需要的变量了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::beginRun</span><span class="hljs-params">(edm::Run <span class="hljs-type">const</span> &amp; iRun, edm::EventSetup <span class="hljs-type">const</span>&amp; iSetup)</span> </span>&#123;<br><span class="hljs-comment">//未知</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span> </span>&#123;	<br><span class="hljs-comment">//主要的分析程序，会自动循环  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> </span><br><span class="hljs-function"><span class="hljs-title">MuMuEEPat::endJob</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//analyze的循环过程中会不断在你定义的tree中填入数据，循环结束后你就需要把这个tree给写入到一个文件中，并进行必要的缓存清理</span><br>&#125;<br><br><span class="hljs-built_in">DEFINE_FWK_MODULE</span>(MuMuEEPat);<br></code></pre></td></tr></table></figure>

<p>Tips: 你需要在UserCode的上一级目录下用下面的命令编译你的代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">scramv1 b ProjectRename <br>scramv1 b clean <span class="hljs-comment">#当你进入到一个新的工作目录的时候你需要上面两行</span><br>scramv1 b 			<span class="hljs-comment">#当你修改了你的代码的时候用这一句就可以编译了</span><br></code></pre></td></tr></table></figure>

<h2 id="2-创建与使用tree"><a href="#2-创建与使用tree" class="headerlink" title="2-创建与使用tree"></a>2-创建与使用tree</h2><p>我们需要在一棵树上放上许多枝桠，将数据分类存储到枝桠对应的树叶中。正如之前所说，种一棵树的最好时机是在之前(beginjob)。对应的在.h文件中要对tree和branch中的vector进行定义。在进行analyze之后，树上已经枝繁叶茂了，我们就需要在endjobs里面把这颗树给输出出来。至于如何在analyze中在这棵树上塞入树叶，接着往下看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.h</span><br>...<br><span class="hljs-comment">//define token begain</span><br>edm::EDGetTokenT&lt;edm::View&lt;pat::Muon&gt; &gt; gtpatmuonToken_;<br>edm::ESGetToken&lt;MagneticField, IdealMagneticFieldRecord&gt; magneticFieldToken_;<br><span class="hljs-comment">//define token end</span><br><br>TTree* X_One_Tree_;<span class="hljs-comment">//Tree是必须的，便利起见，这里我们只用一个Tree存储所有变量</span><br>vector&lt;<span class="hljs-type">double</span>&gt; *mumuonlyMass, *mumuonlyMassErr;<span class="hljs-comment">//在.h文件中定义你的tree和变量，这里我们用向量数组存储数据</span><br>...<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br>MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>:<span class="hljs-built_in">magneticFieldToken_</span>(<span class="hljs-built_in">esConsumes</span>&lt;MagneticField, IdealMagneticFieldRecord&gt;()),<br>...,<br><span class="hljs-built_in">mumuonlyMass</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">mumuonlyMassErr</span>(<span class="hljs-number">0</span>),<br>...<span class="hljs-comment">//这里是所有你在.h定义的变量初始化参数的地方，初始化时需要与定义的顺序一致，注意最后的变量没有逗号</span><br>&#123;<br><span class="hljs-comment">//extract toke begain</span><br>gtpatmuonToken_ = consumes&lt;edm::View&lt;pat::Muon&gt; &gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;slimmedMuons&quot;</span>));<br><span class="hljs-comment">//extract toke end</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::beginJob</span><span class="hljs-params">()</span> </span>&#123;<br>edm::Service &lt; TFileService &gt; fs;<br>X_One_Tree_ = fs-&gt;make &lt; TTree &gt; (<span class="hljs-string">&quot;X_data&quot;</span>, <span class="hljs-string">&quot;X_Data&quot;</span>);<span class="hljs-comment">//定义tree的名字，相当于你种下一棵树命名为X_Data</span><br>X_One_Tree_-&gt;<span class="hljs-built_in">Branch</span>(<span class="hljs-string">&quot;mumuonlyMass&quot;</span>,&amp;mumuonlyMass);<br>X_One_Tree_-&gt;<span class="hljs-built_in">Branch</span>(<span class="hljs-string">&quot;mumuonlyMassErr&quot;</span>,&amp;mumuonlyMassErr);<span class="hljs-comment">//定义重名的branch，指向对应的vector，这里意味着你之前的种下的树长出了枝桠</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span><span class="hljs-comment">//值得留意的是，这个部分的程序按理来说只会对一个对撞事例运行进行筛选，并没有写对所有事例循环的语句，不用担心，在运行的时候会自动对所有的事例循环的，这也是程序会分不同部分的原因</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-keyword">for</span>(...)&#123;<span class="hljs-comment">//对一个事例中的所有muon进行循环，可以设置条件去筛选你想要的muon并获取这些muon的物理量</span><br>  ...<br>  mumuonlyMass-&gt;<span class="hljs-built_in">push_back</span>(...);<br>  mumuonlyMassErr-&gt;<span class="hljs-built_in">push_back</span>(...);<span class="hljs-comment">//将数据填入数组的主要方式</span><br>  ...<br>&#125;<br>...<br><br><span class="hljs-comment">//clear</span><br>X_One_Tree_-&gt;<span class="hljs-built_in">Fill</span>();<span class="hljs-comment">//树叶在之前的for循环中已经获取了，用这一句话就能让这些数据到对应的枝桠上，去塞满你的树吧</span><br>mumuonlyMass-&gt;<span class="hljs-built_in">clear</span>();mumuonlyMassErr-&gt;<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//因为接下来你需要对下一个事例中的muon再进行analyze部分的程序，因而需要把你的数组进行清空，避免数据重复</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::endJob</span><span class="hljs-params">()</span> </span>&#123;<br>X_One_Tree_-&gt;<span class="hljs-built_in">Write</span>();<span class="hljs-comment">//当运行完analyze部分之后,用这个命令就能将你的Tree保存下来</span><br><span class="hljs-keyword">delete</span> X_One_Tree_;<span class="hljs-comment">//删除清理缓存</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>summary：如果你想新加入一个变量，你需要:</p>
<p>1.在.h文件中定义你的变量名，注意顺序和数据类型<br>2.在.cc文件中的iConfig中初始化你的变量，注意顺序<br>3.在.cc文件中的beginJob中定义你要存储变量在Tree上对应的branch，通常是与变量同名的<br>4.在.cc文件中的analyze中填入你的数据进变量中，并在最后的clear部分进行必要的清除</p>
<p>可以用下面两幅图概括</p>
<p><img src="/postfigure/multilepnote/image-20240809222837449.png" srcset="/img/loading.gif" lazyload><img src="/postfigure/multilepnote/image-20240809222627359.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来两节我们将尝试输出事例中的mumu对的物理信息,第一步搭建for循环，对事例中的muon进行配对，第二步拟合muon的track获取物理信息并输出</p>
<h2 id="3-for循环起始"><a href="#3-for循环起始" class="headerlink" title="3-for循环起始"></a>3-for循环起始</h2><p>note:以下部分省略了一些变量的定义、初始化和清理过程，请参照之前的章节进行对应操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.h </span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//define toke begain</span><br>edm::EDGetTokenT&lt;edm::View&lt;pat::Muon&gt; &gt; gtpatmuonToken_;<span class="hljs-comment">//获取pat::Muon的token</span><br>edm::ESGetToken&lt;MagneticField, IdealMagneticFieldRecord&gt; magneticFieldToken_;<span class="hljs-comment">//获取MagneticField的token</span><br><span class="hljs-comment">//define toke end</span><br></code></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br>MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>:<span class="hljs-built_in">magneticFieldToken_</span>(<span class="hljs-built_in">esConsumes</span>&lt;MagneticField, IdealMagneticFieldRecord&gt;())<br>&#123;<br><span class="hljs-comment">//extract toke</span><br>gtpatmuonToken_ = consumes&lt;edm::View&lt;pat::Muon&gt; &gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;slimmedMuons&quot;</span>));<span class="hljs-comment">//在.h文件中导入了pat::Muon的token在这里就可以提取出来</span><br><span class="hljs-comment">//extract toke</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的gtpatmuonToken_是一个成员变量，它保存了一个Token。这个Token表示模块需要pat::Muon类型的对象，数据来源是一个名为“slimmedMuons”的数据集（由edm::InputTag指定）。这个数据集名称是在数据处理链中定义的，用于标识数据源。<br>可以用下面的方式查看这个tag是什么（通常不用Displaced，至于其他的rootfile的情况不清楚是怎样的）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ edmDumpEventContent f8e93985-e14c-4a8a-b28b-f8cceb3c878e.root<br>...<br>vector&lt;pat::Muon&gt;                     <span class="hljs-string">&quot;slimmedDisplacedMuons&quot;</span>     <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-string">&quot;PAT&quot;</span><br>vector&lt;pat::Muon&gt;                     <span class="hljs-string">&quot;slimmedMuons&quot;</span>              <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-string">&quot;PAT&quot;</span>  <br>...  <br></code></pre></td></tr></table></figure>
<p>pat::Muon是一个代表μ子的对象类型，它是分析中使用的“物理对象”（Physics Object）的一种。PAT（Physics Analysis Toolkit）是CMSSW中的一个包，提供了一组标准的高层次的物理对象类型，如电子、μ子、喷流（jets）等。pat::Muon对象包含了关于μ子的各种信息，例如动量、能量、轨迹等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// analyze</span><br>edm::Handle&lt;edm::View&lt;pat::Muon&gt;&gt; thePATMuonHandle;<span class="hljs-comment">//使用edm::Handle可以确保在访问数据时，这些数据对象是有效的并且已被正确初始化。定义一个智能指针 thePATMuonHandle</span><br>iEvent.<span class="hljs-built_in">getByToken</span>(gtpatmuonToken_, thePATMuonHandle);<span class="hljs-comment">//将之前的token提取出来并存储到 thePATMuonHandle</span><br>edm::View &lt;pat::Muon&gt;::const_iterator iMuon1;<span class="hljs-comment">//定义两个指向 edm::View&lt;pat::Muon&gt; 中 pat::Muon 对象常量迭代器，只读而不能修改</span><br>edm::View &lt;pat::Muon&gt;::const_iterator iMuon2;<br><span class="hljs-keyword">for</span> (iMuon1 = thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>();iMuon1 != thePATMuonHandle-&gt;<span class="hljs-built_in">end</span>(); ++iMuon1) &#123;<br>    TrackRef muTrack1 = iMuon1-&gt;<span class="hljs-built_in">track</span>();<span class="hljs-comment">//与下面的reco::Track区别在于，muTrack1可以用于轻量地操作，比如为了看这个track是否是有效的，下面的那个就直接重建出来值，用于track数据的存储，这样做是为了节省运算量，总之，muTrack1更适合进行一些操作运算</span><br>    <span class="hljs-keyword">if</span> (muTrack<span class="hljs-number">1.</span><span class="hljs-built_in">isNull</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//检测两个muon的track是否有效，如果track是无效的，跳过下面的步骤</span><br>    reco::Track recoMu1 = *iMuon1-&gt;<span class="hljs-built_in">track</span>();<span class="hljs-comment">//有效的muon的track进行重建并存储到recoMu1</span><br>    <span class="hljs-keyword">for</span> (iMuon2 = iMuon1 + <span class="hljs-number">1</span>; iMuon2 != thePATMuonHandle-&gt;<span class="hljs-built_in">end</span>(); ++iMuon2) &#123;<span class="hljs-comment">//为了寻找两个配对在一起的muon，就需要循环n(n-1)/2次</span><br>        TrackRef muTrack2 = iMuon2-&gt;<span class="hljs-built_in">track</span>();<br>        <span class="hljs-keyword">if</span> (muTrack<span class="hljs-number">2.</span><span class="hljs-built_in">isNull</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>        reco::Track recoMu2 = *iMuon2-&gt;<span class="hljs-built_in">track</span>();<br>        <span class="hljs-keyword">if</span> ( (iMuon1-&gt;<span class="hljs-built_in">charge</span>()+iMuon2-&gt;<span class="hljs-built_in">charge</span>() ) == <span class="hljs-number">0</span> ) &#123;<span class="hljs-comment">//需要mu+ mu-电荷相加等于0</span><br>            <span class="hljs-comment">//next part</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>&#125;<span class="hljs-comment">// analyze</span><br></code></pre></td></tr></table></figure>

<h2 id="4-track拟合"><a href="#4-track拟合" class="headerlink" title="4-track拟合"></a>4-track拟合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// analyze</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> myMumass = <span class="hljs-number">0.1056583745</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> myMumasserr = myMumass * <span class="hljs-number">1e-6</span>;<span class="hljs-comment">//后面会用到的妙妙工具</span><br><span class="hljs-comment">//////......//////</span><br><span class="hljs-keyword">if</span> ( (iMuon1-&gt;<span class="hljs-built_in">charge</span>()+iMuon2-&gt;<span class="hljs-built_in">charge</span>() ) == <span class="hljs-number">0</span> ) &#123;<br>  <span class="hljs-function">TransientTrack <span class="hljs-title">muonPTT</span><span class="hljs-params">(muTrack1, &amp;(bFieldHandle))</span></span>;<br>  <span class="hljs-function">TransientTrack <span class="hljs-title">muonMTT</span><span class="hljs-params">(muTrack2, &amp;(bFieldHandle))</span></span>;<span class="hljs-comment">//获取muon的track信息，需要track的数据和磁场信息，命名为minus</span><br>  KinematicParticleFactoryFromTransientTrack pmumuFactory;<br>  ParticleMass muon_mass = myMumass;<br>  <span class="hljs-type">float</span> muon_sigma = myMumasserr;<br>  <span class="hljs-type">float</span> chi = <span class="hljs-number">0.</span>;<br>  <span class="hljs-type">float</span> ndf = <span class="hljs-number">0.</span>;<br>  vector &lt; RefCountedKinematicParticle &gt; muonParticles;<br>  muonParticles.<span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonPTT, muon_mass, chi, ndf, muon_sigma));<br>  muonParticles.<span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonMTT, muon_mass, chi, ndf, muon_sigma));<br>  <span class="hljs-comment">//以上是对track的拟合</span><br>  KinematicParticleVertexFitter fitter;<br>  RefCountedKinematicTree psiVertexFitTree;<br>  psiVertexFitTree = fitter.<span class="hljs-built_in">fit</span>(muonParticles);<br>  <span class="hljs-comment">//以上是对顶点的拟合</span><br>  <span class="hljs-keyword">if</span> (psiVertexFitTree-&gt;<span class="hljs-built_in">isValid</span>()) &#123;<span class="hljs-comment">//顶点拟合有效，则</span><br>    psiVertexFitTree-&gt;<span class="hljs-built_in">movePointerToTheTop</span>();<span class="hljs-comment">//这个tree的结构是psi-&gt;mu mu所以Top就是psi，后面还会用到FirstChild，NextChild指的就是mu mu了，Child排序按照muon的动量大小排序</span><br>    RefCountedKinematicParticle psi_vFit_noMC = psiVertexFitTree-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    RefCountedKinematicVertex psi_vFit_vertex_noMC = psiVertexFitTree-&gt;<span class="hljs-built_in">currentDecayVertex</span>();<br>    KinematicParameters mymumupara=  psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    <span class="hljs-comment">//以上是对这个tree提取数据</span><br>    mumuonlyMass-&gt;<span class="hljs-built_in">push_back</span>(psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">mass</span>());<br> <br>  &#125;<br>&#125;<span class="hljs-comment">// analyze</span><br></code></pre></td></tr></table></figure>
<p>试着将下面的这些变量都在Tree里面存储下来吧！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br><span class="hljs-type">float</span> mymumuonlyctau=<span class="hljs-built_in">GetcTau</span>(psi_vFit_vertex_noMC,psi_vFit_noMC,theBeamSpotV);<br><span class="hljs-type">float</span> mymumuonlyctauerr=<span class="hljs-built_in">GetcTauErr</span>(psi_vFit_vertex_noMC,psi_vFit_noMC,theBeamSpotV);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyChg&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon2-&gt;<span class="hljs-built_in">charge</span>()) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyctau&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumuonlyctau &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyctauerr&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumuonlyctauerr&lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyVtxCL&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">ChiSquaredProbability</span>((<span class="hljs-type">double</span>)(psi_vFit_vertex_noMC-&gt;<span class="hljs-built_in">chiSquared</span>()),(<span class="hljs-type">double</span>)(psi_vFit_vertex_noMC-&gt;<span class="hljs-built_in">degreesOfFreedom</span>())) &lt;&lt; std::endl;<br>mumuonlyMass-&gt;<span class="hljs-built_in">push_back</span>(psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">mass</span>());<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyMass&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">mass</span>() &lt;&lt; std::endl;  <span class="hljs-function">no mass constrain</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">( psi_vFit_noMC-&gt;currentState().kinematicParametersError().matrix()(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)&gt;<span class="hljs-number">0</span>)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyMassErr&quot;</span> &lt;&lt; <span class="hljs-built_in">sqrt</span>(psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParametersError</span>().<span class="hljs-built_in">matrix</span>()(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)) &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  mumuonlyMassErr-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-9</span>);<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyPx&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumupara.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyPy&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumupara.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyPz&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumupara.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlymu1Idx&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), iMuon1)&lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlymu2Idx&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), iMuon2)&lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<p>summary：</p>
<p>以上部分可以理解为，我们对探测器中的$\mu$子进行重建，并尝试将重建的$\mu$子对的顶点进行拟合，选择那些由一个粒子衰变出来两个正负$\mu$子的过程，将这个重建出来的粒子的物理信息输出出来。<br>现在你已经掌握了如何在一个事例中筛选并提取简单的muon对的物理信息了，这代表着你已经掌握了绝大部分代码的逻辑关系！接下来就是要输出更多有用的物理信息，不过在此之前，为什么不看一眼你的 $ J&#x2F; \psi $ 是什么样子的呢？</p>
<h2 id="5-myntuple-分析root文件"><a href="#5-myntuple-分析root文件" class="headerlink" title="5-myntuple 分析root文件"></a>5-myntuple 分析root文件</h2><p>runMuMuEEPAT_data_Run2012CMSSW53XJan.py -&gt; ivars.outputFile&#x3D;’mymultilep.root’ 会根据你之前写的.cc文件进行筛选输出这个root文件，<code>cmsenv</code>配置环境之后，用下面的命令运行这个py文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmsRun runMultiLepPAT_dataRun3_miniAOD.py<br></code></pre></td></tr></table></figure>

<p>一个ntuple的job需要 myntuple.C.rootmap，myntuple.C，myntuple.h和一个运行的Runjobs.py文件</p>
<p>.rootmap是通用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//myntuple.C.rootmap</span><br>&#123; decls &#125;<br>[ myntuple_C.so ]<br>namespace myntuple<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myntuple</span>:</span>:myntuple<br>header myntuple.h<br></code></pre></td></tr></table></figure>

<p>当你没有.C与.h文件时，可以通过mymultilep.root生成，他是根据你之前编辑的MuMuEEPat.h中的变量，去生成一个对应的myntuple.h文件，以及一个空的myntuple.C文件，当然你可以在<code>MakeClass</code>那里取一个自己的名字，但你也需要对应的在rootmap中修改，如果你是新手的话用相同的命名是最好的。注：这一步会覆盖掉之前你生成的myntuple.C等文件，当你没有对MuMuEEPat.h添加额外的变量的时候就不需要重复这一步。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l mymultilep.root<br>.<span class="hljs-built_in">ls</span>   //mkcands<br>mkcands-&gt;<span class="hljs-built_in">cd</span>()<br>.<span class="hljs-built_in">ls</span>   //X_data<br>X_data-&gt;MakeClass(<span class="hljs-string">&quot;myntuple&quot;</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//会生成这样的.C文件和一个包含你在之前.cc里面定义过的所有变量的.h文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myntuple_cxx</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myntuple.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TH2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TStyle.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TCanvas.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myntuple::Loop</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">if</span> (fChain == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>Long64_t nentries = fChain-&gt;GetEntries();<br>Long64_t nbytes = <span class="hljs-number">0</span>, nb = <span class="hljs-number">0</span>;<br><br>TFile* myhbk = new TFile (<span class="hljs-string">&quot;myhbk.root&quot;</span>,<span class="hljs-string">&quot;recreate&quot;</span>);<span class="hljs-comment">//创建一个root，将所有你想画出来的直方图都放进去</span><br>TH1F* mumumass = new TH1F(<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>);<span class="hljs-comment">//创建一个一维直方图</span><br>TH1F* mumumasserr = new TH1F(<span class="hljs-string">&quot;mumumasserr&quot;</span>,<span class="hljs-string">&quot;mumumasserr&quot;</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>);<br><span class="hljs-keyword">for</span> (Long64_t jentry=<span class="hljs-number">0</span>; jentry&lt;nentries;jentry++) &#123;<span class="hljs-comment">//对每个事例进行loop</span><br>  Long64_t ientry = LoadTree(jentry);<br>  <span class="hljs-keyword">if</span> (ientry &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>  nb = fChain-&gt;GetEntry(jentry);   nbytes += nb;<br>  <span class="hljs-comment">// if (Cut(ientry) &lt; 0) continue;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> myi = <span class="hljs-number">0</span>; myi &lt; mumuonlyMass-&gt;size(); myi++) &#123;<span class="hljs-comment">//对一个事例中的mumu进行loop</span><br>     mumumass-&gt;Fill((*mumuonlyMass)[myi]);<span class="hljs-comment">//将你的变量填入到你定义的直方图中</span><br>    mumumasserr-&gt;Fill((*mumuonlyMassErr)[myi]);<br>  &#125;<br><span class="hljs-keyword">if</span> (jentry%<span class="hljs-number">10000</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I am running &quot;</span> &lt;&lt; jentry &lt;&lt; <span class="hljs-string">&quot; th entries out of &quot;</span> &lt;&lt; nentries &lt;&lt; <span class="hljs-string">&quot; total entries&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>myhbk-&gt;Write(); <span class="hljs-comment">//这一句就能将所有你填入的直方图保存下来</span><br>&#125;<span class="hljs-comment">//end</span><br></code></pre></td></tr></table></figure>

<p>Tips:这里需要说明几个概念。nentries可以看作是对撞事例的编号，所以第一个for循环是为了对所用的对撞事例进行循环的，而第二个for循环是对一次事例中的<code>mumuonlyMass-&gt;size()</code>进行循环，这里取的编号是mumu对的编号，也就是对所有的$\mu$子对进行循环。在之后你还会尝试对单个$\mu$子进行操作，逻辑也是如此。<br><img src="/postfigure/multilepnote/IMG_0585.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>写好myntuple.C之后，需要进行编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l <br>.L myntuple.C++<br></code></pre></td></tr></table></figure>

<p>编译完成后就能运行Runjobs.C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Runjobs</span><span class="hljs-params">()</span><br>&#123;<br>gSystem-&gt;Load(<span class="hljs-string">&quot;myntuple_C.so&quot;</span>);<br>TChain * chain = new TChain(<span class="hljs-string">&quot;/mkcands/X_data&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>chain-&gt;Add(<span class="hljs-string">&quot;./mymultilep.root&quot;</span>);<span class="hljs-comment">//这里放入你在cmsRun生成的文件</span><br>myntuple <span class="hljs-title function_">a</span><span class="hljs-params">(chain)</span>;<br>a.Loop();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l -b -q Runjobs.C <span class="hljs-comment">#-l 是不显示root启动界面，-b 以批处理模式运行，不显示图形界面， -q 处理完命令行宏文件后退出。这个命令通常在需要跑很多文件的时候配合脚本使用</span><br></code></pre></td></tr></table></figure>

<p>运行完成后会生成一个root文件，就是你在myntuple.C中命名的那个myhbk.root，你可以用一些命令去看里面的直方图，不过更推荐用vscode和root file viewer这个插件去看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l myhbk.root<br>root [0] <br>Attaching file myhbk.root as _file0...<br>(TFile *) 0x1cc6e10<br>root [1] .<span class="hljs-built_in">ls</span><br>TFile**         myhbk.root<br> TFile*         myhbk.root<br>  KEY: TH1F     mumumass;1      mumumass<br>root [2] mumumass-&gt;GetXaxis()-&gt;SetRangeUser(0.5, 5)<br>root [3] mumumass-&gt;Draw()<br></code></pre></td></tr></table></figure>



<h2 id="6-Muon-ID的输出"><a href="#6-Muon-ID的输出" class="headerlink" title="6-Muon ID的输出"></a>6-Muon ID的输出</h2><p>Muon ID 本质上是对$\mu$子的一些筛选条件的整合，将其打上Loose, soft, medium, tight等标签，以方便我们的分析，如果你完成了这一章，你就能在你的myntuple.C中用MuonID设置你自己的筛选条件了。这一节会介绍以下这几个ID的输出方式以及必要的物理信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">muIsPatLooseMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isLooseMuon</span>());<br>muIsPatTightMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isTightMuon</span>(thePrimaryV));<br>muIsPatSoftMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isSoftMuon</span>(thePrimaryV));<br>muIsPatMediumMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isMediumMuon</span>());<br></code></pre></td></tr></table></figure>

<p>需要注意的有两点：<br>1.与之前输出mu子对不同，这次是输出单个mu子的信息<br>2.有些muon ID需要PrimaryVetex的信息，而PrimaryVetex需要获取beamSpot的信息，</p>
<p>下面是需要用到的妙妙工具，把他们放入到合适的地方吧！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.h</span><br>edm::EDGetTokenT&lt;BeamSpot&gt; gtbeamspotToken_;<br>edm::EDGetTokenT&lt;VertexCollection&gt; gtprimaryVtxToken_;<br><span class="hljs-type">bool</span> addXlessPrimaryVertex_; <span class="hljs-type">bool</span> resolveAmbiguity_;<br><br><span class="hljs-comment">//.cc</span><br>MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>:<span class="hljs-built_in">addXlessPrimaryVertex_</span>(iConfig.getUntrackedParameter &lt; <span class="hljs-type">bool</span> &gt; (<span class="hljs-string">&quot;addXlessPrimaryVertex&quot;</span>, <span class="hljs-literal">true</span>)),<br><span class="hljs-built_in">resolveAmbiguity_</span>(iConfig.getUntrackedParameter &lt; <span class="hljs-type">bool</span> &gt; (<span class="hljs-string">&quot;resolvePileUpAmbiguity&quot;</span>, <span class="hljs-literal">true</span>))<br>&#123;<br>gtbeamspotToken_ = <span class="hljs-built_in">consumes</span>&lt;BeamSpot&gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;offlineBeamSpot&quot;</span>));<br>gtprimaryVtxToken_ = <span class="hljs-built_in">consumes</span>&lt;VertexCollection&gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;offlineSlimmedPrimaryVertices&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Beamspot-and-PrimaryVertex"><a href="#Beamspot-and-PrimaryVertex" class="headerlink" title="Beamspot and PrimaryVertex"></a>Beamspot and PrimaryVertex</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.cc -&gt;analyze</span><br><span class="hljs-comment">//Beamspot</span><br>Vertex theBeamSpotV;<span class="hljs-comment">//声明一个Vertex类型的对象，表示一个顶点</span><br>BeamSpot beamSpot;<span class="hljs-comment">//声明一个BeamSpot类型的对象，表示束流点</span><br><br>edm::Handle &lt; reco::BeamSpot &gt; beamSpotHandle;<span class="hljs-comment">//在之前的代码中也用到，用于存储束流信息</span><br>iEvent.<span class="hljs-built_in">getByToken</span>(gtbeamspotToken_, beamSpotHandle);<span class="hljs-comment">//提取信息存储在beamSpotHandle中</span><br><span class="hljs-keyword">if</span> (beamSpotHandle.<span class="hljs-built_in">isValid</span>()) &#123;<span class="hljs-comment">//如果beamSpotHandle是有效的则把对应的信息存储起来</span><br>  beamSpot = *beamSpotHandle;<br>  theBeamSpotV = <span class="hljs-built_in">Vertex</span>(beamSpot.<span class="hljs-built_in">position</span>(), beamSpot.<span class="hljs-built_in">covariance3D</span>());<span class="hljs-comment">//用beamSpot的位置信息，和协方差矩阵来初始化theBeamSpotV对象</span><br>&#125; <span class="hljs-keyword">else</span> std::cout &lt;&lt; <span class="hljs-string">&quot;No beam spot available from EventSetup&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-comment">//Beamspot end</span><br><br><span class="hljs-comment">//PrimaryVertex</span><br>Vertex thePrimaryV;<br>math::XYZPoint RefVtx;<span class="hljs-comment">//用于表示三维点或向量，存储PrimaryVertex</span><br><br>edm::Handle &lt; VertexCollection &gt; recVtxs;<br>iEvent.<span class="hljs-built_in">getByToken</span>(gtprimaryVtxToken_, recVtxs);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nVtxTrks = <span class="hljs-number">0</span>;<span class="hljs-comment">//无符号整数即正整数避免负值</span><br><span class="hljs-type">int</span> mynGoodPrimVtx=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> myi=<span class="hljs-number">0</span>;myi&lt;recVtxs-&gt;<span class="hljs-built_in">size</span>();myi++) &#123;<span class="hljs-comment">//遍历所有recVtxs取到的顶点</span><br>  <span class="hljs-keyword">if</span>((*recVtxs)[myi].<span class="hljs-built_in">ndof</span>()&gt;=<span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">fabs</span>((*recVtxs)[myi].<span class="hljs-built_in">z</span>())&lt;=<span class="hljs-number">24</span> &amp;&amp; <span class="hljs-built_in">fabs</span>((*recVtxs)[myi].<span class="hljs-built_in">position</span>().<span class="hljs-built_in">rho</span>())&lt;=<span class="hljs-number">2.0</span>) &#123;<span class="hljs-comment">//顶点条件有ndof自由度，z坐标，rho径向距离</span><br>    mynGoodPrimVtx++;<span class="hljs-comment">//符合条件的为goodPrimaryVertex，计数+1</span><br>  &#125;<br>&#125;<br>nGoodPrimVtx = mynGoodPrimVtx;<span class="hljs-comment">//这个变量记得输出出来</span><br><br><span class="hljs-keyword">if</span> (recVtxs-&gt;<span class="hljs-built_in">begin</span>() != recVtxs-&gt;<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-comment">//检查是否为空</span><br>  <span class="hljs-keyword">if</span> (addXlessPrimaryVertex_ || resolveAmbiguity_) &#123;<span class="hljs-comment">//如果为真，选择第一个顶点为thePrimaryV</span><br>    thePrimaryV = <span class="hljs-built_in">Vertex</span>(*(recVtxs-&gt;<span class="hljs-built_in">begin</span>()));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果不为真，选择轨迹数量最多的顶点为thePrimaryV</span><br>    <span class="hljs-keyword">for</span> (reco::VertexCollection::const_iterator vtx = recVtxs-&gt;<span class="hljs-built_in">begin</span>(); vtx != recVtxs-&gt;<span class="hljs-built_in">end</span>(); ++vtx) &#123;<br>      <span class="hljs-keyword">if</span> (nVtxTrks &lt; vtx-&gt;<span class="hljs-built_in">tracksSize</span>()) &#123;<br>        nVtxTrks = vtx-&gt;<span class="hljs-built_in">tracksSize</span>();<br>        thePrimaryV = <span class="hljs-built_in">Vertex</span>(*vtx);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果为空，用之前的beamspot信息进行初始化</span><br>  thePrimaryV = <span class="hljs-built_in">Vertex</span>(beamSpot.<span class="hljs-built_in">position</span>(), beamSpot.<span class="hljs-built_in">covariance3D</span>());<br>&#125;<span class="hljs-comment">//这一部分确保在顶点重建和物理分析中，有一个合理的主顶点可供使用</span><br><br><span class="hljs-comment">//接下来导出初始顶点的位置信息</span><br>RefVtx = thePrimaryV.<span class="hljs-built_in">position</span>();<br>priVtxX = (thePrimaryV.<span class="hljs-built_in">position</span>().<span class="hljs-built_in">x</span>());<br>priVtxY = (thePrimaryV.<span class="hljs-built_in">position</span>().<span class="hljs-built_in">y</span>());<br>priVtxZ = (thePrimaryV.<span class="hljs-built_in">position</span>().<span class="hljs-built_in">z</span>());<br>priVtxXE = (thePrimaryV.<span class="hljs-built_in">xError</span>());<br>priVtxYE = (thePrimaryV.<span class="hljs-built_in">yError</span>());<br>priVtxZE = (thePrimaryV.<span class="hljs-built_in">zError</span>());<br>priVtxChiNorm = (thePrimaryV.<span class="hljs-built_in">normalizedChi2</span>());<br>priVtxChi = thePrimaryV.<span class="hljs-built_in">chi2</span>();<br>priVtxCL = <span class="hljs-built_in">ChiSquaredProbability</span>((<span class="hljs-type">double</span>) (thePrimaryV.<span class="hljs-built_in">chi2</span>()), (<span class="hljs-type">double</span>) (thePrimaryV.<span class="hljs-built_in">ndof</span>()));<br><span class="hljs-comment">//PrimaryVertex end</span><br></code></pre></td></tr></table></figure>

<h3 id="Muon-ID-and-Muon-block"><a href="#Muon-ID-and-Muon-block" class="headerlink" title="Muon ID and Muon block"></a>Muon ID and Muon block</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.cc -&gt;如果之前更复杂的情况你已经完全掌握的话，下面这部分对你来说应该是非常简单的:)</span><br>edm::Handle&lt; edm::View&lt;pat::Muon&gt; &gt; thePATMuonHandle;<span class="hljs-comment">//同样定义handle，然后提取信息</span><br>iEvent.<span class="hljs-built_in">getByToken</span>(gtpatmuonToken_, thePATMuonHandle);<br>edm::View&lt;pat::Muon&gt;::const_iterator iMuonP;<br><span class="hljs-keyword">for</span> (iMuonP = thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(); iMuonP != thePATMuonHandle-&gt;<span class="hljs-built_in">end</span>(); ++iMuonP) &#123;<br>  ++nMu;<span class="hljs-comment">//muon计数器，用于之后的效率计算</span><br>  muIsPatLooseMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isLooseMuon</span>());<br>  muIsPatTightMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isTightMuon</span>(thePrimaryV));<br>  muIsPatSoftMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isSoftMuon</span>(thePrimaryV));<br>  muIsPatMediumMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isMediumMuon</span>());<br>  muPx-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">px</span>());<br>  muPy-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">py</span>());<br>  muPz-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">pz</span>());<br>  muCharge-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">charge</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-处理数据"><a href="#7-处理数据" class="headerlink" title="7-处理数据"></a>7-处理数据</h2><p>如果一切顺利的话，你应该会在mumu的质量谱中3Gev附近看到一个很尖的峰，没错这就是你重建出来的$J&#x2F;\psi$粒子！Congratulations！但像这样粗浅的看一眼就说，我找到的的这个峰就是3.0969Gev的$J&#x2F;\psi$峰，很显然是会被丁肇中先生打死的。我们还需要对这些数据点进行拟合，用数学的方式去确定我们找到的峰是什么粒子的衰变函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">TH1F* mumumass = new TH1F(<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>);<span class="hljs-comment">//5000为bin的数量</span><br></code></pre></td></tr></table></figure>

<p>还记得之前我们在myntuple.C文件中定义的名为mumumass一维直方图吗，里面我们设置了他的范围0-25，以及一个5000的bin。这里的bin可以理解为成条形统计图的柱子，这也就意味着我们会损失掉一些精细的数据，比如我们就无法分辨质量为3.000和3.0002的两个mumu，因为他们都会被丢到3.000～3.005这一个bin中，当然如果你的bin足够多也可以称之为“精细”，这也是微积分的方法了。但为什么不直接获取每一个mumu对的质量数值呢！所以，你这里输出的直方图虽说可以用于拟合，但如果想更加自由一点，你需要输出每一个mumu对的质量，这样你就能在你的拟合程序中随心所欲地改变你的bin了！</p>
<p>输出成txt部分比较简单，直接在myntuple.C中用下面的方式就能输出了，相信你应该能把这两个拼图放在正确的地方了，记得在输出多个变量的时候在两个变量之间加入空格，这样在后续需要输入多个变量的时候可以通过空格分成不同的列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">ofstream <span class="hljs-title function_">myoutfile</span><span class="hljs-params">(<span class="hljs-string">&quot;mydata.txt&quot;</span>)</span>;<span class="hljs-comment">//放在循环外面</span><br>...<br>myoutfile &lt;&lt; <span class="hljs-built_in">std</span>::fixed <br>  &lt;&lt; (*mumuonlyMass)[myi] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*mumuonlyMassErr)[myi] <br>  &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//放在循环里面</span><br></code></pre></td></tr></table></figure>

<p>当你成功输出一个txt文件之后，就可以新做一个拟合程序。</p>
<p>下面正式进行拟合部分，以及如果你对使用的变量有任何疑问我没能包含的，你可以在这个链接中找到解答<a target="_blank" rel="noopener" href="https://root.cern.ch/doc/master/group__Roofitmain.html">ROOT: RooFit (cern.ch)</a>（另外我正在写另外一个关于roofit用法的note，waiting… 13D&#x2F;08M&#x2F;24Y）</p>
<p>比如你可以找到<code>RooRealVar</code>的用法，善用查找功能，你也能成为master! <img src="/postfigure/multilepnote/image-20240813001010193.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TFile.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TH1.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooAbsReal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooRealVar.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooDataHist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooGaussian.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooPlot.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooFitResult.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooChebychev.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooAddPdf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TCanvas.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooCrystalBall.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooFit.h&gt;</span></span><br>using namespace RooFit;<br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fitroot</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//这个需要与你的文件名相同</span><br>    RooRealVar <span class="hljs-title function_">mass</span><span class="hljs-params">(<span class="hljs-string">&quot;mass&quot;</span>, <span class="hljs-string">&quot;Invariant Mass&quot;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">4</span>)</span>;<span class="hljs-comment">//定义变量，是最常用的一个类</span><br>    RooArgSet variables;<br>    variables.add(mass);<span class="hljs-comment">//创建了一个变量集合并在里面添加了mass这个变量</span><br>  <br>    RooDataSet *data = RooDataSet::read(<span class="hljs-string">&quot;./mydata.txt&quot;</span>, variables,<span class="hljs-string">&quot;Q&quot;</span>);<span class="hljs-comment">//读入数据，当你需要多个变量输入的时候，请确保你的变量集的顺序和你在myntuple.C的输出顺序是一致的，也就是说你的变量需要跟你txt文件中每列（以空格分割）相对应</span><br>    mass.setBins(<span class="hljs-number">300</span>);<span class="hljs-comment">//这里并不是对数据分bin，而是对变量分bin，相当于先分好一些空箱子</span><br>    RooDataHist <span class="hljs-title function_">datahist</span> <span class="hljs-params">(<span class="hljs-string">&quot;datahist&quot;</span>, <span class="hljs-string">&quot;binned data&quot;</span>, RooArgSet(mass),*data)</span>;<span class="hljs-comment">//这一步才是把数据分到之前的箱子中</span><br>  	<span class="hljs-comment">//下面这些可以忽略</span><br>    <span class="hljs-comment">//TFile *file = TFile::Open(&quot;myhbk.root&quot;);</span><br>    <span class="hljs-comment">//TH1F *hist = (TH1F*)file-&gt;Get(&quot;mumumassSoft&quot;);//这两步是直接从root提取你的直方图</span><br>    <span class="hljs-comment">//TH1F *rebinHist = (TH1F*)hist-&gt;Rebin(2, &quot;rebinHist&quot;);//这个意味着将直方图的两个bin合并为一个</span><br>    <span class="hljs-comment">//RooDataHist data(&quot;data&quot;, &quot;Dataset with mass&quot;, mass,hist);</span><br>		<span class="hljs-comment">//</span><br>  <br>    RooRealVar <span class="hljs-title function_">c0</span><span class="hljs-params">(<span class="hljs-string">&quot;c0&quot;</span>,<span class="hljs-string">&quot;c0&quot;</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">c1</span><span class="hljs-params">(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">c2</span><span class="hljs-params">(<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">c3</span><span class="hljs-params">(<span class="hljs-string">&quot;c3&quot;</span>,<span class="hljs-string">&quot;c3&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooChebychev <span class="hljs-title function_">chev</span><span class="hljs-params">(<span class="hljs-string">&quot;chev&quot;</span>,<span class="hljs-string">&quot;chev&quot;</span>,mass,RooArgList(c0,c1,c2,c3))</span>;<span class="hljs-comment">//Chebyshev polynomials</span><br><br>   <br>    RooRealVar <span class="hljs-title function_">psimean</span><span class="hljs-params">(<span class="hljs-string">&quot;psimean&quot;</span>, <span class="hljs-string">&quot;Mean&quot;</span>, <span class="hljs-number">3.1</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">3.3</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">psisigma</span><span class="hljs-params">(<span class="hljs-string">&quot;psisigma&quot;</span>, <span class="hljs-string">&quot;Sigma&quot;</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.1</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">psialpha</span><span class="hljs-params">(<span class="hljs-string">&quot;psialpha&quot;</span>,<span class="hljs-string">&quot;psialpha&quot;</span>,<span class="hljs-number">1.</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">2.0</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">psin</span><span class="hljs-params">(<span class="hljs-string">&quot;psin&quot;</span>,<span class="hljs-string">&quot;psin&quot;</span>,<span class="hljs-number">1.</span>,<span class="hljs-number">0</span>,<span class="hljs-number">15</span>)</span>;<br>    RooCrystalBall <span class="hljs-title function_">psicb</span><span class="hljs-params">(<span class="hljs-string">&quot;psicb&quot;</span>,<span class="hljs-string">&quot;psicb&quot;</span>,mass,psimean,psisigma,psialpha,psin,<span class="hljs-literal">false</span>)</span>;<span class="hljs-comment">//Crystal Ball function</span><br>    <span class="hljs-comment">//RooGaussian psigauss(&quot;psigauss&quot;, &quot;Gaussian PDF&quot;, mass, psimean, psisigma);</span><br><br>    RooRealVar <span class="hljs-title function_">njpsi</span><span class="hljs-params">(<span class="hljs-string">&quot;njpsi&quot;</span>, <span class="hljs-string">&quot;signal fraction&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">10000.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">nbkg</span><span class="hljs-params">(<span class="hljs-string">&quot;nbkg&quot;</span>, <span class="hljs-string">&quot;background fraction&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">100000.</span>)</span>;<br><br>    RooExtendPdf <span class="hljs-title function_">epsisig</span><span class="hljs-params">(<span class="hljs-string">&quot;esig&quot;</span>, <span class="hljs-string">&quot;esig&quot;</span>, psicb, njpsi)</span>;<br>    RooExtendPdf <span class="hljs-title function_">epsibkg</span><span class="hljs-params">(<span class="hljs-string">&quot;ebkg&quot;</span>, <span class="hljs-string">&quot;ebkg&quot;</span>, chev, nbkg)</span>;<span class="hljs-comment">//这部分有一些知识前提，总之将pdf extend之后可以直接获得成分的数目</span><br><br>    RooAddPdf <span class="hljs-title function_">model</span><span class="hljs-params">(<span class="hljs-string">&quot;fsig&quot;</span>,<span class="hljs-string">&quot;fsig&quot;</span>,RooArgList(epsisig,epsibkg))</span>;<span class="hljs-comment">//model(x) = (njpsi/(njpsi+nbkg))*psicb(x) + (1-(nbkg/(njpsi+nbkg))*bkg(x)</span><br>    RooFitResult* result = model.fitTo(*data, Save());<br>    <span class="hljs-comment">//RooFitResult* result = model.fitTo(datahist, Save());</span><br><br>   <br>    RooPlot* frame = mass.frame();<span class="hljs-comment">//以mass创建一个坐标轴相当于x轴</span><br>    data-&gt;plotOn(frame,MarkerStyle(<span class="hljs-number">20</span>),MarkerSize(<span class="hljs-number">0.4</span>),Name(<span class="hljs-string">&quot;data&quot;</span>));<br>    <span class="hljs-comment">//datahist.plotOn(frame,MarkerStyle(20),MarkerSize(0.4),Name(&quot;data&quot;));</span><br>    model.plotOn(frame,LineColor(<span class="hljs-number">2</span>),LineWidth(<span class="hljs-number">3</span>),Name(<span class="hljs-string">&quot;model&quot;</span>));<br>    model.plotOn(frame,Components(epsisig),LineColor(<span class="hljs-number">7</span>),LineStyle(<span class="hljs-number">1</span>),LineWidth(<span class="hljs-number">3</span>),Name(<span class="hljs-string">&quot;Jpsi&quot;</span>));<br>    model.plotOn(frame,Components(epsibkg),LineColor(<span class="hljs-number">9</span>),LineStyle(<span class="hljs-number">1</span>),LineWidth(<span class="hljs-number">3</span>),Name(<span class="hljs-string">&quot;BKG&quot;</span>));<br>    <span class="hljs-comment">//将对应部分画到这个坐标轴上</span><br>    <br>    TLegend <span class="hljs-title function_">yleg</span><span class="hljs-params">(<span class="hljs-number">0.7</span>,<span class="hljs-number">0.7</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.9</span>)</span>;<span class="hljs-comment">//在一个画布的相对于左下角的(0.7,0.7)位置开始到(0.9,0.9)画出一个矩形</span><br>    yleg.AddEntry(frame-&gt;findObject(<span class="hljs-string">&quot;model&quot;</span>),<span class="hljs-string">&quot;FullModel&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>);<br>    yleg.AddEntry(frame-&gt;findObject(<span class="hljs-string">&quot;Jpsi&quot;</span>),<span class="hljs-string">&quot;Jpsi&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>);<br>    yleg.AddEntry(frame-&gt;findObject(<span class="hljs-string">&quot;BKG&quot;</span>),<span class="hljs-string">&quot;Background&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>);<br>	  <span class="hljs-comment">//添加图例</span><br>  <br>    RooPlot *xfpull=mass.frame();<span class="hljs-comment">//画pull分布</span><br>    RooHist *pullx=frame-&gt;pullHist(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;model&quot;</span>);<span class="hljs-comment">//数据点在拟合的model图线上的偏离情况</span><br>    xfpull-&gt;addPlotable(pullx,<span class="hljs-string">&quot;p&quot;</span>);<br>    <span class="hljs-comment">//xfpull-&gt;GetXaxis()-&gt;SetTitle(&quot;J/#psiJ/#psi&quot;);</span><br>    xfpull-&gt;GetXaxis()-&gt;SetTitleSize(<span class="hljs-number">0.15</span>);<br>    xfpull-&gt;GetXaxis()-&gt;SetLabelSize(<span class="hljs-number">0.12</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetTitle(<span class="hljs-string">&quot;Pull&quot;</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetTitleSize(<span class="hljs-number">0.15</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetLabelSize(<span class="hljs-number">0.1</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetTitleOffset(<span class="hljs-number">0.2</span>);<br>    <br>    TCanvas <span class="hljs-title function_">c</span> <span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;Fit with RooFit&quot;</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>)</span>;<span class="hljs-comment">//创建一个画布</span><br>    c.cd();<br>    TPad <span class="hljs-title function_">pad11</span><span class="hljs-params">(<span class="hljs-string">&quot;pad11&quot;</span>,<span class="hljs-string">&quot;pad11&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1.0</span>)</span>;<span class="hljs-comment">//创建(0,0.3)到(1,1)的范围</span><br>    pad11.SetTopMargin(<span class="hljs-number">0.08</span>);<br>    pad11.SetBottomMargin(<span class="hljs-number">0.017</span>);<br>    pad11.Draw();<br>    pad11.cd();<span class="hljs-comment">//进入这个区域画你想画上去的plot和legend</span><br>    frame-&gt;Draw();<br>    yleg.Draw();<br>    c.cd();<br>    TPad <span class="hljs-title function_">pad12</span><span class="hljs-params">(<span class="hljs-string">&quot;pad12&quot;</span>,<span class="hljs-string">&quot;pad12&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.3</span>)</span>;<br>    pad12.SetTopMargin(<span class="hljs-number">0.03</span>);<br>    pad12.SetBottomMargin(<span class="hljs-number">0.325</span>);<br>    pad12.SetGridx();<br>    pad12.SetGridy(<span class="hljs-number">2</span>);<br>    pad12.Draw();<br>    pad12.cd();<br>    xfpull-&gt;Draw();<br>    c.Update();<br>    c.cd();<br><br>    c.SaveAs(<span class="hljs-string">&quot;fitResult.pdf&quot;</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>不出意外的话，你最终会得到一个很漂亮的拟合图形。或许你会发现了一些较小的峰，他们分别是$\rho,\phi,\psi(2S)$，那么试着在<a target="_blank" rel="noopener" href="https://pdg.lbl.gov/">PDG</a>上找到这些粒子的质量，用<code>RooBreitWigner</code>或者<code>RooGaussian</code>函数去拟合这些峰吧！相信你会能得到一个看起来非常棒的结果！</p>
<p>现在喝杯可乐休息一下吧！后面的内容会更加复杂！</p>
<h2 id="8-four-muon-拟合"><a href="#8-four-muon-拟合" class="headerlink" title="8-four muon 拟合"></a>8-four muon 拟合</h2><p>p.s. 下面的内容如果直接拷贝可能会出现一些变量没提及或未定义的情况，因为我只会介绍的逻辑，一些细枝末节可能会因为我的粗心未能完全包含，不过，相信你经过之前的练习已经能完全对付这些小问题了！</p>
<p>在之前的分析中，我们成功的对两个muon进行拟合并得到一些令人兴奋的结果。但我们的征途并不会止步于此，在接下来的章节里我们将研究四个muon，多了一倍的数量的muon带来的是更多的变量和更复杂的筛选，以及一些更有趣的结果！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (thePATMuonHandle-&gt;size()&gt;=<span class="hljs-number">4</span> )&#123;<br>    <span class="hljs-keyword">for</span> (iMuon1 = thePATMuonHandle-&gt;begin();iMuon1 != thePATMuonHandle-&gt;end(); ++iMuon1) &#123;<br>        TrackRef muTrack1 = iMuon1-&gt;track();<br>        <span class="hljs-keyword">if</span> (muTrack1.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>        reco::Track recoMu1 = *iMuon1-&gt;track();<br>        <span class="hljs-keyword">for</span> (iMuon2 = iMuon1 + <span class="hljs-number">1</span>; iMuon2 != thePATMuonHandle-&gt;end(); ++iMuon2) &#123;<br>          TrackRef muTrack2 = iMuon2-&gt;track();<br>          <span class="hljs-keyword">if</span> (muTrack2.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>          reco::Track recoMu2 = *iMuon2-&gt;track();<br>          <span class="hljs-keyword">for</span> (iMuon3 = iMuon2 + <span class="hljs-number">1</span>; iMuon3 != thePATMuonHandle-&gt;end(); ++iMuon3) &#123;<br>            TrackRef muTrack3 = iMuon3-&gt;track();<br>            <span class="hljs-keyword">if</span> (muTrack3.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>            reco::Track recoMu3 = *iMuon3-&gt;track();<br>            <span class="hljs-keyword">for</span> (iMuon4 = iMuon3 + <span class="hljs-number">1</span>; iMuon4 != thePATMuonHandle-&gt;end(); ++iMuon4) &#123;<br>              TrackRef muTrack4 = iMuon4-&gt;track();<br>              <span class="hljs-keyword">if</span> (muTrack4.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>              reco::Track recoMu4 = *iMuon4-&gt;track();<br>              <span class="hljs-keyword">if</span> ( (iMuon1-&gt;charge()+iMuon2-&gt;charge()+iMuon3-&gt;charge()+iMuon4-&gt;charge() ) == <span class="hljs-number">0</span> ) &#123;<br></code></pre></td></tr></table></figure>

<p>循环和之前的类似，通过遍历一个事例中的所有$\mu$来进行后续的配对操作。你可以在此之前添加一个条件<code>if (thePATMuonHandle-&gt;size()&gt;=4)</code>以确保你这个事例中确实是有四个或四个以上的$\mu$的，这样你才能进行后面的操作。同样的，如果我们想重建两个中性粒子的话，需要要求四个$\mu$的电荷加和为零，这样能经过这个条件的$\mu$必定是$\mu^+ \mu^- \mu^+ \mu^-$，但是在程序中我们得到的只是$\mu_1 \mu_2 \mu_3 \mu_4$，不同于两个$\mu$，四个$\mu$就代表着如果两两组合的话，我们就会有三种不同的组合</p>
<p>$\mu_1 \mu_2,\mu_3 \mu_4$ | $\mu_1 \mu_3, \mu_2 \mu_4$ | $\mu_1 \mu_4, \mu_2 \mu_3$</p>
<p>而在这三种组合中，再考虑两两组合里的两个$\mu$的电荷之和也应该为0，这样其实最终只有两种组合是正确的，请注意，$\mu_1 \mu_2 \mu_3 \mu_4$的电荷排序并不一定就是$\mu^+ \mu^- \mu^+ \mu^-$，所以不代表 $\mu_1 \mu_3, \mu_2 \mu_4$ 就一定是错误的组合（你需要思考！）那么为了剔除其中错误的组合，你可以选择在myntuple.C进行筛选，也可以在.cc这里就进行筛选。<font color="Red"><strong>前者是我们最后主要的处理方式，这里为了逻辑的连续性我会展示在.cc的处理方式，也为后续更高级的处理方式做一个铺垫。</strong></font></p>
<p>其实很简单，就是把电荷之和为零的填入到一个二维数组里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ( (iMuon1-&gt;<span class="hljs-built_in">charge</span>()+iMuon2-&gt;<span class="hljs-built_in">charge</span>()+iMuon3-&gt;<span class="hljs-built_in">charge</span>()+iMuon4-&gt;<span class="hljs-built_in">charge</span>() ) == <span class="hljs-number">0</span> ) &#123;<br>  std::vector&lt;std::pair&lt;<span class="hljs-type">const</span> edm::View&lt;pat::Muon&gt;::const_iterator, <span class="hljs-type">const</span> edm::View&lt;pat::Muon&gt;::const_iterator&gt;&gt; muonPairs;<br>  <span class="hljs-keyword">if</span> ((iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon2-&gt;<span class="hljs-built_in">charge</span>()) == <span class="hljs-number">0</span>) &#123;<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon1, iMuon2));<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon3, iMuon4));<br>      &#125;<br>  <span class="hljs-keyword">if</span> ((iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon3-&gt;<span class="hljs-built_in">charge</span>()) == <span class="hljs-number">0</span>) &#123;<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon1, iMuon3));<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon2, iMuon4));<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon4-&gt;<span class="hljs-built_in">charge</span>()) == <span class="hljs-number">0</span>) &#123;<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon1, iMuon4));<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon2, iMuon3));<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; muonPairs.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon1 = muonPairs[i].first;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon2 = muonPairs[i].second;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon3 = muonPairs[i<span class="hljs-number">+1</span>].first;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon4 = muonPairs[i<span class="hljs-number">+1</span>].second;<br>    <span class="hljs-comment">//下面的代码和两个muon的部分十分相似，相信你能很容易看懂其中的意义</span><br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonPTT1</span><span class="hljs-params">(muon1-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonMTT2</span><span class="hljs-params">(muon2-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonPTT3</span><span class="hljs-params">(muon3-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonMTT4</span><span class="hljs-params">(muon4-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    KinematicParticleFactoryFromTransientTrack pmumuFactory;<br>    ParticleMass muon_mass = myMumass;<br>    <span class="hljs-type">float</span> muon_sigma = myMumasserr;<br>    <span class="hljs-type">float</span> chi = <span class="hljs-number">0.</span>;<br>    <span class="hljs-type">float</span> ndf = <span class="hljs-number">0.</span>;<br>    vector &lt; RefCountedKinematicParticle &gt; muonParticles1;<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonPTT1, muon_mass, chi, ndf, muon_sigma));<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonMTT2, muon_mass, chi, ndf, muon_sigma));<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonPTT3, muon_mass, chi, ndf, muon_sigma));<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonMTT4, muon_mass, chi, ndf, muon_sigma));<br>    KinematicParticleVertexFitter fitter;<br>    RefCountedKinematicTree psiVertexFitTree1;<br>    psiVertexFitTree1 = fitter.<span class="hljs-built_in">fit</span>(muonParticles1);<br><br>  <span class="hljs-keyword">if</span> (psiVertexFitTree1-&gt;<span class="hljs-built_in">isValid</span>()) &#123;<br>    <span class="hljs-comment">//这里我删去了输出fourmuonmass的部分，直接输出各muon的动量</span><br>    <span class="hljs-comment">//child 的顺序与填入muonParticles1的顺序一致，所以与muon1的排序一致</span><br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheFirstChild</span>();<br>    RefCountedKinematicParticle mu1CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu1KP=  mu1CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheNextChild</span>();<br>    RefCountedKinematicParticle mu2CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu2KP=  mu2CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheNextChild</span>();<br>    RefCountedKinematicParticle mu3CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu3KP=  mu3CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheNextChild</span>();<br>    RefCountedKinematicParticle mu4CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu4KP=  mu4CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br><br>		<span class="hljs-comment">//下面需要输出四个muon的动量，这样我们就能获得这些muon的四动量</span><br>    MyFourMuonMu1Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu1KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu1Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu1KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu1Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu1KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br>    MyFourMuonMu2Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu2KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu2Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu2KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu2Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu2KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br>    MyFourMuonMu3Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu3KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu3Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu3KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu3Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu3KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br>    MyFourMuonMu4Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu4KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu4Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu4KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu4Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu4KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br><br>    mumuonlymu1Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon1));<br>    mumuonlymu2Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon2));<br>    mumuonlymu3Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon3));<br>    mumuonlymu4Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon4));<br></code></pre></td></tr></table></figure>

<p>如果你不想在.cc中进行这一步筛选，直接把对应<code>muon1</code>替换为<code>iMuon1</code>就好了。但你同时还需要输出对应$\mu$的电荷以便于之后在myntuple.C中进行筛选，在(### Muon ID and Muon block)章节中其实已经对所有的$\mu$按照顺序输出了他们的电荷，那么你就可以用<code>(*muCharge)[(*mumuonlymu1Idx)[myi]]</code>的方式在myntuple.C中获取对应$\mu$的电荷了（这里只是作为提示，请思考这里的myi一个是取哪个变量的<code>size()</code>）</p>
<p>如此一来在myntuple.C中的处理变得心应手了，请利用下面的提示去获取你的$\mu \mu$组合的质量，这样就能画出两个不变质量谱，甚至可以画出一个二维分布图！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TLorentzVector.h&quot;</span></span><br>TH2F* mumumassJJ = new TH2F(<span class="hljs-string">&quot;mumumassJJ&quot;</span>,<span class="hljs-string">&quot;mumumassJJ&quot;</span>,<span class="hljs-number">60</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.4</span>,<span class="hljs-number">60</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.4</span>);<br>...<br>TLorentzVector Muon1FourVector;<br>Muon1FourVector.SetXYZM((*muPx)[(*MyFourMuonMu1Idx)[myi]], (*muPy)[(*MyFourMuonMu1Idx)[myi]], (*muPz)[(*MyFourMuonMu1Idx)[myi]], muonMass);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;Muon1FourVector.M() &lt;&lt; Muon1FourVector.Pt() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>...<br>mumumassJJ-&gt;Fill(mumumass1, mumumass2);<br></code></pre></td></tr></table></figure>

<p>但是，however, だがしかし、你或许会发现你的第二对$\mu$的不变质量看起来很奇怪，为什么第一对可以清楚地看到峰，而第二对却不行？下面是我的初步解释，你可以用一些方法验证我说的是否正确</p>
<blockquote>
<p>一个事例中的$\mu$子的动量是按动量从大到小进行排序的，第一对的两个$\mu$子往往会得到更大的横动量pt，从而拥有更低的本底，因此要想在第二对$\mu$中看到峰可以对$\mu$的pt进行限制</p>
</blockquote>
<p><img src="/postfigure/multilepnote/image-20240911223127881.png" srcset="/img/loading.gif" lazyload alt="第一对$\mu$子" style="zoom:40%;" /><img src="/postfigure/multilepnote/image-20240911222912057.png" srcset="/img/loading.gif" lazyload alt="第二对$\mu$子" style="zoom:40%;" /></p>
<p>然而当对本底进行压低的时候也意味着信号会有相应的损失，因此一个root文件的数据已经不太够了，你需要尝试多run几个文件，在<a target="_blank" rel="noopener" href="https://cmsweb.cern.ch/das/request?instance=prod/global&input=file+dataset=/ParkingDoubleMuonLowMass0/Run2023B-22Sep2023-v1/MINIAOD">cms Data Aggregation System </a>中我已经筛选出所需要的root文件，你可以用类似下面的命令下载到你的目录下<br><code>xrdcp -d 1 -f root://xrootd-cms.infn.it//store/data/Run2023B/ParkingDoubleMuonLowMass0/MINIAOD/22Sep2023-v1/2560000/0cb0075f-5308-4849-a0ee-f451012a0c7c.root .</code><br>如果不可以的话请联系我。下载合适数量的文件后（10个左右）在runMultiLepPAT_dataRun3_miniAOD.py中修改inputFiles，拿到数据之后，在myntuple.C中可以设置每个$\mu$子的pt大于1.5或者2应该就能看到峰啦！下图中左边是<code>pt&gt;1.5</code>右边是<code>pt&gt;2</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">ivars.inputFiles=(<br><span class="hljs-string">&#x27;file:f8e93985-e14c-4a8a-b28b-f8cceb3c878e.root&#x27;</span>,//可以通过添加逗号并行多个root文件<br><span class="hljs-string">&#x27;file:847912fd-20d4-4cbe-80bf-3eeade7bcb1f.root&#x27;</span><br>)<br></code></pre></td></tr></table></figure>

<p><img src="/postfigure/multilepnote/24381725427136_.pic.jpg" srcset="/img/loading.gif" lazyload alt="pt>1.5" style="zoom:50%;" /><img src="/postfigure/multilepnote/24401725427247_.pic.jpg" srcset="/img/loading.gif" lazyload alt="pt>2" style="zoom:50%;" /></p>
<h2 id="9-mass-constraint"><a href="#9-mass-constraint" class="headerlink" title="9-mass constraint"></a>9-mass constraint</h2><p>当你去<a target="_blank" rel="noopener" href="https://pdg.lbl.gov/">PDG</a>查询$J&#x2F;\psi$粒子的信息的时候会发现，他的衰变宽度只有0.0000926GeV！而在我们的不变质量谱上，位于3.096GeV的峰的宽度很显然比这个值要大得多，WHY? 事实上这受到探测器的分辨率的影响，按理来说在真实的物理世界中，如果我们能精密测量$\mu$的动量的话，我们重建出来的$J&#x2F;\psi$峰的形状应该像一个$\delta$函数。但我们的探测器做不到这一点，他能测量出来的动量是有误差的，而且因为这个过程是：$\mu$子打在探测器上-&gt;留下电信号的空间位置-&gt;拟合出多个电信号组成轨迹-&gt;根据轨迹半径计算$\mu$的动量。其中的探测器就像是一个一个像素点，如果点亮了就说明$\mu$子来过，这个像素点很显然不能无限精细，这就有了分辨率这一说，就像4K与360P的区别。既然有分辨率导致的不准确，也就会导致$J&#x2F;\psi$质量附近变得“模糊”了（当你摘下眼镜看向月亮，就会看到一坨月亮），那么如何修正这一点呢？我们需要做mass constraint!</p>
<p>正如其名，我们要将$J&#x2F;\psi$附近的模糊的$\mu \mu$动量通过一些拟合修正，把他们的不变质量重新<strong>约束</strong>到3.096GeV！这里要说明一点的是，并不是所有的粒子都适合做mass constraint，像衰变宽度很大的粒子就不适合，这会改变原有的物理性质。了解了这些之后，让我们开始代码的书写吧！</p>
<p><strong>Note:</strong> 在此之前，在下面的文件夹内包含相关的文件，.cc是截止到4muon部分的所有代码，你可以把他覆盖掉你原先自己写的.cc，.h是包含所有所需的变量，这些变量即使没用到也没有关系，另外还有一个作为提示的完整代码。这部分重复的结构很多，在理解其中的逻辑之后请仔细确认变量名，be patient！</p>
<blockquote>
<p>用下面的路径下的文件吧！<br>&#x2F;afs&#x2F;cern.ch&#x2F;user&#x2F;z&#x2F;zhuf&#x2F;public&#x2F;UserCode&#x2F;massconst<br>—&gt;MuMuEEPat.cc<br>—&gt;MuMuEEPat.h<br>—&gt;MultiLepPAT.cc_hint </p>
</blockquote>
<p>新的.cc文件中调整了一些循环结构让整体逻辑更简洁明了</p>
<blockquote>
<p>– for iMuonP 这里对所有的$\mu$遍历，输出所有的信息<br>-&gt; raw_muonPx, muonID, Index…</p>
<p>if Handle-&gt;size()&gt;&#x3D;2: 如果有大于2个的$\mu$的话<br>– for iMuon1 iMuon2<br>-&gt; mumuonly fit_muonPx<br>if Handle-&gt;size()&gt;&#x3D;4: 如果有大于4个的$\mu$的话<br>– for iMuon3 iMuon4<br>    -&gt; fourmuon<br>    -&gt; mass constraint for each pairs <strong>(we are here!)</strong></p>
</blockquote>
<p>在之前(### four muon 拟合)我们提到有三种不同的配对组合：</p>
<p>$\mu_1 \mu_2,\mu_3 \mu_4$ | $\mu_1 \mu_3, \mu_2 \mu_4$ | $\mu_1 \mu_4, \mu_2 \mu_3$</p>
<p>那么如果我们需要对每对$\mu$重建出来的$J&#x2F;\psi$做mass constraint 的话就需要按照不同的电荷条件重复3次，比如我们先做第一组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(muon1TT.charge()+muon2TT.charge()==<span class="hljs-number">0</span>)  &#123;<br>  muonP12.push_back(pFactory.particle(muon1TT, muon_mass, chi, ndf, muon_sigma));<br>  muonP12.push_back(pFactory.particle(muon2TT, muon_mass, chi, ndf, muon_sigma));<br>  muonP34.push_back(pFactory.particle(muon3TT, muon_mass, chi, ndf, muon_sigma));<br>  muonP34.push_back(pFactory.particle(muon4TT, muon_mass, chi, ndf, muon_sigma));<br>  RefCountedKinematicTree Jpsi1 = kpvFitter.fit(muonP12);<br>  RefCountedKinematicTree Jpsi2 = kpvFitter.fit(muonP34);<br><br>  RefCountedKinematicTree Jpsi1noMCJJ = kpvFitter.fit(muonP12);<br>  RefCountedKinematicTree Jpsi2noMCJJ = kpvFitter.fit(muonP34);<br>  <span class="hljs-keyword">if</span> (Jpsi1-&gt;isValid() &amp;&amp; Jpsi2-&gt;isValid())&#123;<br>    ..........<span class="hljs-comment">//这部分是在分别取两个J/\psi的物理信息，和之前的类似，不做过多解释</span><br>		<span class="hljs-keyword">if</span>(doJPsiMassCost) &#123;<span class="hljs-comment">//这部分做mass constraint，你可以把这个if去掉不用判断</span><br>      RefCountedKinematicTree Chi1_bTree;<br>      RefCountedKinematicParticle MyChi1_part;<br><br>      <span class="hljs-comment">//JJ assumption</span><br>      jp1 = myJmass;  jp_m_sigma1 = myJmasserr;<br>      jp2 = myJmass;  jp_m_sigma2 = myJmasserr;<br>      jpsi_c1 = new MassKinematicConstraint(jp1,jp_m_sigma1);<br>      jpsi_c2 = new MassKinematicConstraint(jp2,jp_m_sigma2);<span class="hljs-comment">//设置你想constraint的粒子参数</span><br>      try&#123; Jpsi1 = csFitter.fit(jpsi_c1,Jpsi1noMCJJ);&#125; catch (VertexException <span class="hljs-type">const</span>&amp; x) &#123;  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;mu12 vertex exception with mass constrainted to J!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>; &#125;<br>      try&#123; Jpsi2 = csFitter.fit(jpsi_c2,Jpsi2noMCJJ);&#125; catch (VertexException <span class="hljs-type">const</span>&amp; x) &#123;  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;mu34 vertex exception with mass constrainted to J!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>; &#125;<span class="hljs-comment">//尝试将之前的mumu组合constraint到你设置的参数上，并将结果覆盖进Jpsi1中</span><br>      <span class="hljs-keyword">if</span>(Jpsi1-&gt;isEmpty()!=<span class="hljs-literal">true</span> &amp;&amp; Jpsi2-&gt;isEmpty()!=<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//如果JPsi1和JPsi2拟合成功且非空，提取当前粒子并将其添加到Chi_1列表中</span><br>        Jpsi1-&gt;movePointerToTheTop();<br>        Jpsi2-&gt;movePointerToTheTop();		<br>        Jpsi1_part = Jpsi1-&gt;currentParticle();<br>        Jpsi2_part = Jpsi2-&gt;currentParticle();<br>        Chi_1.push_back(Jpsi1_part);<br>        Chi_1.push_back(Jpsi2_part);				 <br>        <span class="hljs-type">bool</span> isagoodfit=<span class="hljs-literal">true</span>;<br>        try&#123;  Chi1_bTree = kpvFitter.fit(Chi_1); &#125; catch (VertexException <span class="hljs-type">const</span>&amp; x) &#123;isagoodfit=<span class="hljs-literal">false</span>;   <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;mu12 and mu34 vertex exception with mu12 and mu34 constrained to JJ&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//相当于先分别对两个muon拟合顶点到J/\psi，再对两个经过mass constraint后的两个J/\psi再进行顶点拟合</span><br>        <span class="hljs-keyword">if</span>(Chi1_bTree-&gt;isValid() &amp;&amp; isagoodfit) &#123;<span class="hljs-comment">//如果拟合成功就提取J/\psi物理信息</span><br>        ...........<span class="hljs-comment">//省略</span><br>        &#125;<br>      &#125;<br>      delete jpsi_c1; delete jpsi_c2;<br>      <span class="hljs-comment">//end JJ assuption</span><br></code></pre></td></tr></table></figure>

<p>Note: 关于Ctau的定义<br>需要一个洛伦兹不变量表示粒子的寿命。<br>实验室系下：$\tau &#x3D; \gamma \tau_0$；$\tau_0$为粒子的静止寿命 $\gamma&#x3D;\frac{1}{\sqrt{1-\beta^2}},\beta&#x3D;\frac{v}{c}$<br>衰变长度：$L&#x3D;v\tau&#x3D;\gamma \beta c \tau_0$；其中$c\tau_0$就可认为是洛伦兹不变的<br>其中$p&#x3D;\gamma m_0 \beta$，带入可得$c\tau_0 &#x3D;\frac{L}{\gamma\beta}&#x3D; \frac{Lm_0}{p}$<br>指得注意的是，这里的$c\tau_0$是在动量方向和位移方向平行的情况下的，当有呈现一定角度的时候也只有在平行于位移方向上才会有洛伦兹收缩的现象，因此在实际的计算中还需要有一个夹角$cos\alpha$，下面是可以在.h中找到的函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C">virtual <span class="hljs-type">double</span> <span class="hljs-title function_">GetcTau</span><span class="hljs-params">(RefCountedKinematicVertex&amp; decayVrtx, RefCountedKinematicParticle&amp; kinePart, Vertex&amp; bs)</span><br>  &#123;	TVector3 vtx;<br>    TVector3 pvtx;<br>    vtx.SetXYZ((*decayVrtx).position().x(), (*decayVrtx).position().y(), <span class="hljs-number">0</span>);<br>    pvtx.SetXYZ(bs.position().x(), bs.position().y(), <span class="hljs-number">0</span>);<br>    VertexDistanceXY vdistXY;<br>    TVector3 <span class="hljs-title function_">pperp</span><span class="hljs-params">(kinePart-&gt;currentState().globalMomentum().x(),</span><br><span class="hljs-params">		   kinePart-&gt;currentState().globalMomentum().y(), <span class="hljs-number">0</span>)</span>;<br>    <br>    TVector3 vdiff = vtx - pvtx;<br>    <span class="hljs-type">double</span> cosAlpha = vdiff.Dot(pperp) / (vdiff.Perp() * pperp.Perp());<br>    Measurement1D distXY = vdistXY.distance(Vertex(*decayVrtx), Vertex(bs));<br>    <span class="hljs-type">double</span> ctauPV = distXY.value() * cosAlpha * kinePart-&gt;currentState().mass() / pperp.Perp();<br>    <span class="hljs-keyword">return</span> ctauPV;    <br>  &#125;<br></code></pre></td></tr></table></figure>

<p><del>Note: 拟合顶点的步骤<br>顶点拟合的过程也会对$\mu$子原始的Px,Py,Pz进行修正，因此在变量的使用上有raw_Px和fit_Px的区别。<br><code>KinematicParticleVertexFitter</code>创建一个工具<br><code>TransientTrack</code>–.particle-&gt;<code>KinematicParticleFactoryFromTransientTrack</code>–push_back-&gt;<code>vector &lt; RefCountedKinematicParticle &gt;</code>–fitter-&gt;<code>RefCountedKinematicTree</code><br><code>RefCountedKinematicTree-&gt;movePointerToTheFirstChild()</code>–currentParticle()-&gt;<code>RefCountedKinematicParticle</code>–currentState().kinematicParameters()-&gt;<code>KinematicParameters</code></del></p>
<p>以上对于.cc的内容基本上就结束了。我们查看完整版的代码会发现，里面除了JJ的mass constraint 还有很多其他衰变道的代码，而那些代码之间并无太多区别，在这里就不再重复。然而学习并不会就此终止，.cc中的筛选条件只是一些最最基础的，他最主要的作用还是做一些拟合，和输出对应的物理量，而更细致的筛选则是在myntuple.C中完成的。那么在接下来的章节中我会继续介绍myntuple.C的内容。</p>
<p>（以上内容完成于13&#x2F;09&#x2F;2024）</p>
<hr>
<h2 id="10-myntuple-进阶"><a href="#10-myntuple-进阶" class="headerlink" title="10-myntuple 进阶"></a>10-myntuple 进阶</h2><p><strong>Note:</strong> 以下的任务推荐在清华集群中完成，你可以使用下面路径中的mymultilep.root文件进行<code>MakeClass</code>的操作，生成和编写你的myntuple.C文件</p>
<blockquote>
<p>Data path:这里是你可以用的数据文件，你需要在之前完整版的cc找到你需要的变量名<br>&#x2F;home&#x2F;storage0&#x2F;users&#x2F;llchen&#x2F;dataMINI&#x2F;Run3&#x2F;ReReco2023&#x2F;2023B&#x2F;ParkingDoubleMuonLowMass0<br>myntuple_hint:这是所有衰变道的整合文件，里面很乱，选取你需要的部分<br>&#x2F;home&#x2F;storage0&#x2F;users&#x2F;zhufeng&#x2F;formymultilep_learning&#x2F;myntuple.C_hint</p>
</blockquote>
<h3 id="数据输入的管理和排序"><a href="#数据输入的管理和排序" class="headerlink" title="数据输入的管理和排序"></a>数据输入的管理和排序</h3><p>在之前的myntuple.C中我们学会了一些简单的画图操作，这很显然不能满足我们日渐增长的筛选需求，并且随着four muon和mass constraint的加入，带来了更多的变量，我们也需要对这些变量进行管理，下面是一个思路：</p>
<p>在.cc中$\mu$的变量是以四个为一组进行输出的，同样的在.C中我们也会以同样的思路获取，比如一个$\mu$子的charge和fourLorentzVector，就可以把他们四个为一组输入到一个数组里：（下面不是代码，只是作为逻辑展示）</p>
<blockquote>
<p>我们可以把$\mu$物理量按照顺序填入到数组里：<br>MuCharge: {charge_mu1,charge_mu2,charge_mu3,charge_mu4}<br>Mu4vect:   {4vect_mu1,  4vect_mu2,  4vect_mu3,  4vect_mu4}</p>
</blockquote>
<p>如果所有的变量都按照这个顺序填入到一个对应的数组里的话，那么我们只需要 <strong>变量名+序号</strong> 就能获取对应$\mu$子的物理量了，比如我们想知道第3个$\mu$的Px，那只需要用<code>(MuPx)[2]</code>就能得到了，前提是你创建了<code>MuPx</code>这个数组并按照正确的顺序填入了这个变量。</p>
<p>既然我们用合适的方式管理了4个$\mu$子的物理量，接下来就是对这4个$\mu$子进行配对了。之前我介绍了用<code>if</code>条件判断电荷相加是否为零的方式来配对他们，如果为零则输出配对之后的两个$\mu$的不变质量，而且也已经知道三种配对方式中只有两对是合适的。在条件很少的情况下这种方式确实能很方便的得到我们想要的东西，但我们需要找到一个公用的标签去筛选和组合这些物理量，上面的管理就是为了这一步做准备的。</p>
<p>还记得刚刚提到的序号吗，事实上我们如果对序号进行组合和排序的话，这样我们在完成操作之后只需要找需要对应的物理量输出出来就好了！比如：</p>
<blockquote>
<p>对序号进行组合：myCombIdx[3] &#x3D; {0,1,2,3}, {0,2,1,3}, {0,3,1,2}，<br>分别对应 $\mu_1 \mu_2,\mu_3 \mu_4$ | $\mu_1 \mu_3, \mu_2 \mu_4$ | $\mu_1 \mu_4, \mu_2 \mu_3$的组合方式</p>
<p>比如我们想看$\mu_1 \mu_3$ 这个组合是否满足电荷相加为零的条件，如果满足则输出$\mu_1\mu_3$的不变质量：</p>
</blockquote>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( (MuCharge)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]] + (MuCharge)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>)<br>&#123;( (Mu4vect)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]] + (Mu4vect)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] ).M()&#125;<br></code></pre></td></tr></table></figure>

<p>接下来是排序，排序除了想解决规范问题之外，还会有比如在$\Upsilon J&#x2F;\psi$这样的衰变道中，我们需要让第一对的两个$\mu$子的不变质量大于第二对的，这样才比较合理。下面我会介绍对于电荷和质量大小的排序：</p>
<blockquote>
<p>首先找出错误的电荷组合，将其放入到myCombIdx[0]序号为零的里面，这样如果我们不想研究带电的态的话就可以只对[1] [2]进行循环了，然后比较两对的不变质量，把较大的放在前面即<code>([0]+[1]).M() &gt; ([2]+[3]).M()</code>,之后将$\mu$子的电荷按照<code>+-+-</code>的顺序排列。实现以上的需求，你需要下面几个交换函数。<img src="/postfigure/multilepnote/image-20240914210956761.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>除了这些基础的排序，我们还可以根据他们的质量和你想找的粒子的质量的相近程度来排序，这里就会用到$\chi^2$检验。</p>
<blockquote>
<p>卡方值$\chi^2$（Chi-Square）<br>卡方值是一种统计量，用于衡量观测值与期望值之间的偏差程度。卡方值越大，观测值与期望值之间的偏差越大。</p>
</blockquote>
<p>比如我想研究 $\psi(2S) J&#x2F;\psi$ 这个衰变道可以用$\chi^2$的公式是：</p>
<blockquote>
<p>  <font size=5.8> $\chi^2$ &#x3D; $(\frac{M_{1_obs}-M_{\psi(2S)}}{\sigma_{M_1}})^2+(\frac{M_{2_obs}-M_{J&#x2F;\psi}}{\sigma_{M_2}})^2$ </font></p>
<p>具体的代码中还会为了调整质量误差的影响而在质量误差后乘上一个缩放因子</p>
</blockquote>
<p>除了用于排序的函数之外还有一个用于对应$\mu\mu$对的不变质量的函数<code>setFourMuPairsVars</code>，这个函数的作用是，将已经排序的<code>myCombIdx</code>与在cc中进行过拟合的$\mu\mu$对的不变质量对应上。比如排序完成后的<code>myCombIdx[1]</code>为{3,1,4,2}，那么我输出的<code>myFourMuVars[3][2]</code>的数组中<code>myFourMuVars[1][0]=(*MyJpsi3Var_Mu13)[fourMuIdx] myFourMuVars[1][1] = (*MyJpsi4Var_Mu24)[fourMuIdx]</code></p>
<h3 id="结果输出的命名与自动化"><a href="#结果输出的命名与自动化" class="headerlink" title="结果输出的命名与自动化"></a>结果输出的命名与自动化</h3><blockquote>
<p>你可以修改下面三个地方自定义输出的root文件名，这样你就可以通过脚本程序生成多个Runjobs.C同时运行，并且会输出为不同文件，最后再用<code>hadd</code>将这些文件合成为一份就可以了</p>
<p>脚本可以参考&#x2F;home&#x2F;storage0&#x2F;users&#x2F;zhufeng&#x2F;formymultilep_learning&#x2F;shell&#x2F;</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//.C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myntuple::Loop</span><span class="hljs-params">(TString outputname)</span>&#123;<br>.....<br>TString myroot = outputname + <span class="hljs-string">&quot;_zhuf.root&quot;</span>;<br>TFile* myhbk = new TFile (myroot,<span class="hljs-string">&quot;recreate&quot;</span>);<br><br><span class="hljs-comment">//.h</span><br>virtual <span class="hljs-type">void</span>     <span class="hljs-title function_">Loop</span><span class="hljs-params">(TString outputname)</span>;<br><br><span class="hljs-comment">//Runjobs</span><br>a.Loop(<span class="hljs-string">&quot;youroutputdir/youroutputname&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>了解这一步之前，我们首先要了解myntuple.C myntuple.h 和 Runjobs.C之间的关系。当你用<code>MakeClass</code>去创建一个新的myntuple.C的时候，大部分的成员函数已经创建完成了，像<code>GetEntry</code>这样的，这些函数的功能比较单一，所以都会放在.h文件中，而其中有一个<code> virtual void     Loop();</code>这一<code>Loop</code>成员函数是我们主要需要编写的函数。如果我们编译之后得到的myntuple_C.so文件就能在 Runjobs.C 中加载使用了（下面代码中路径有点长省略了一部分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Runjobs</span><span class="hljs-params">()</span><br>&#123;<br>  gSystem-&gt;Load(<span class="hljs-string">&quot;myntuple_C.so&quot;</span>);<span class="hljs-comment">//加载库</span><br>  TChain * chain = new TChain(<span class="hljs-string">&quot;/mkcands/X_data&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//创建TChain，用于处理多个TTree对象</span><br>  chain-&gt;Add(<span class="hljs-string">&quot;..MuOnia/ReReco2016/FILE/mymultilep_*Number.root&quot;</span>);<span class="hljs-comment">//将路径中的root文件加载进TChain中，TChain就包含了所有的TTree的信息</span><br>  myntuple <span class="hljs-title function_">a</span><span class="hljs-params">(chain)</span>;<span class="hljs-comment">//使用chain 创建一个 myntuple 类的实例 a</span><br>  a.Loop();<span class="hljs-comment">//调用 myntuple 类的 Loop 方法，处理 TChain 中的数据</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以发现我们在Runjobs中只会调用<code>Loop</code>函数所以我们在这个函数里面增加一个<code>string</code>变量就能在函数里面使用了，并将这个<code>string</code>运用在输出文件的命名中就大功告成了！</p>
<h2 id="end-some-tricks-need-to-test"><a href="#end-some-tricks-need-to-test" class="headerlink" title="end-some tricks need to test"></a>end-some tricks need to test</h2><p>由于在添加一个新的branch的时候，总是有一些重复的工作，而且对于大量的变量的加入也会导致工作量的增加以及代码的简洁性，下面的一些工具能让你的添加branch部分变得十分简洁易读。你只需要把他们放在对应的地方就能在主函数中使用<code>CREATE_BRANCHES(nGoodPrimVtx,muPx,muPy,muPz);</code>和<code>CLEAR_VARIABLES(nGoodPrimVtx,muPx,muPy,muPz);</code>这样的命令进行批量地创建和清理了。不过这个功能还在测试中，可能会出现意想不到的错误，如果你发现了错误，还请<a href="mailto:feng.zhu@cern.ch">联系我</a>进行修改!（update:08m&#x2F;12d 下面的这些大概率不能work，如果你有类似的可行方法也请联系我）</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/multilep/" class="print-no-link">#multilep</a>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/12/ebookdownload/" title="ebook">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ebook</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/11/linux/" title="Linux learning note">
                        <span class="hidden-mobile">Linux learning note</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      
<i class="iconfont icon-love"></i> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
