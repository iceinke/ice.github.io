<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>First Step of Linux and Root</title>
    <link href="/2024/10/12/rootfirststep/"/>
    <url>/2024/10/12/rootfirststep/</url>
    
    <content type="html"><![CDATA[<h2 id="Lesson-0-install-root-and-software-on-your-computer"><a href="#Lesson-0-install-root-and-software-on-your-computer" class="headerlink" title="Lesson 0 install root and software on your computer"></a>Lesson 0 install root and software on your computer</h2><p><a href="https://brew.sh/">homebrew</a> Click this link to go to the Homebrew page, follow the instructions to install Homebrew on your Mac. Homebrew is a software package manager that allows you to download many applications on your Mac!<br>After finishing the installation, paste the following command in a macOS terminal to install CERN ROOT software: <code>$ brew install root</code>. This way, you can also install applications like <code>firefox</code> which you can’t find in the App Store.<br>Additionally, <code>$</code> indicates a shell command, so drop the <code>$</code> sign when you copy the command.</p><h2 id="Lesson-1-base-commands"><a href="#Lesson-1-base-commands" class="headerlink" title="Lesson 1 base commands"></a>Lesson 1 base commands</h2><p>If you get the THU’s computer cluster account, use following commands to get into.</p><p><code>$ ssh -XY -p 48571 -o ServerAliveInterval=5  yourname@hepthu.com</code></p><p>You can also run code on your pc if you have installed root, it’s up to you. </p><hr><p>Some simple commands you can have a try!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span>  <span class="hljs-comment">#print work directory</span><br><span class="hljs-built_in">cd</span> /path/to/directory <span class="hljs-comment">#change directory</span><br><span class="hljs-built_in">cd</span> ..  <span class="hljs-comment">#back to parent directory</span><br><span class="hljs-built_in">ls</span>    <span class="hljs-comment">#list directory contents</span><br><span class="hljs-built_in">mkdir</span>  <span class="hljs-comment">#make a directory</span><br><span class="hljs-built_in">rm</span> file <span class="hljs-comment">#remove</span><br><span class="hljs-built_in">rm</span> -r directory  <span class="hljs-comment">#delete a directory</span><br>vi filename    <span class="hljs-comment">#open or make a file with vim editor</span><br></code></pre></td></tr></table></figure><p>Vim editor</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">i     <span class="hljs-comment">#insert, edit mode</span><br>Esc    <span class="hljs-comment">#exit edit mode</span><br>:wq    <span class="hljs-comment">#save and exit</span><br>:q    <span class="hljs-comment">#exit, will mention you if you have modified the file </span><br>:q!    <span class="hljs-comment">#exit !without! save</span><br></code></pre></td></tr></table></figure><p>you will use the next commands from time to time<br>vi somefile -&gt; press i into edit mode -&gt; do something -&gt;esc exit edit mode -&gt; :wq</p><hr><p>Get start!</p><p><code>$ vi test.C  </code></p><p>&#x2F;&#x2F;push <code> i</code> to enter the insert mode&#x2F;&#x2F;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-comment">//be sure it is similar with your file name</span><br><br> &#123;<br><br>TH1F* graph=new TH1F(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-number">200</span>,<span class="hljs-number">2.97</span>,<span class="hljs-number">3.03</span>); <br>  <span class="hljs-comment">//TH1F* graph name=new TH1F(&quot;name&quot;,&quot;title”,bins, low, high)</span><br><br>graph-&gt;Draw();  <span class="hljs-comment">//draw your graph </span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;push <code>ESC</code> to end the insert mode&#x2F;&#x2F;</p><p><code>:wq</code>  &#x2F;&#x2F;save and exit </p><p><code>$ root test.C</code>  &#x2F;&#x2F;run your code</p><p><img src="/postfigure/rootfirststepfigure/PastedGraphic1.png"></p><p>&#x2F;&#x2F;&#x2F;successful!&#x2F;&#x2F;&#x2F;</p><p><code>.q  </code>&#x2F;&#x2F;exit the program </p><hr><p>Let’s add something into your graph!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br><br> <span class="hljs-comment">//TCanvas* c1=new TCanvas(&quot;c1&quot;,&quot;fitting with Gaussian function&quot;);  //if you don’t set the canvas’s name, it will created default canvas with name c1</span><br><br> <span class="hljs-comment">//c1-&gt;SetGrid();  // set grid </span><br><br> TH1F* graph=new TH1F(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-number">200</span>,<span class="hljs-number">2.97</span>,<span class="hljs-number">3.03</span>);<br><br> graph-&gt;Fill(<span class="hljs-number">2.99</span>); <span class="hljs-comment">// you can add just one data in your graph using “Fill” command and try to draw your graph.It’s boring, right? We need more!</span><br><br> TRandom n; <span class="hljs-comment">// define a random variable n</span><br><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;++i)&#123;<br><br> graph-&gt;Fill(n.Gaus(<span class="hljs-number">3</span>,<span class="hljs-number">0.005</span>));  <span class="hljs-comment">//Determine variable n using Gaussian distribution and fill to graph</span><br><br> &#125;<br><br> graph-&gt;Draw();<br><br> graph-&gt;Fit(<span class="hljs-string">&quot;gaus&quot;</span>);<span class="hljs-comment">//fit your graph with Gaussian function</span><br><br> &#125;<br></code></pre></td></tr></table></figure><p><img src="/postfigure/rootfirststepfigure/PastedGraphic2.png"></p><p>Wow! now you can use root to do some simple fit works. but we usually use RooFit to do more complex job! So, ready for more programs!</p><h2 id="Lesson-2-Gaussian-fitting-using-RooFit"><a href="#Lesson-2-Gaussian-fitting-using-RooFit" class="headerlink" title="Lesson 2 Gaussian fitting using RooFit"></a>Lesson 2 Gaussian fitting using RooFit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"> <span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br> TCanvas* c1=new TCanvas(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;fitting with Gaussian function&quot;</span>);<br> c1-&gt;SetGrid();<br> <span class="hljs-comment">//build a gaussian pdf (probability density function)</span><br> <span class="hljs-comment">/*RooRealVar: define a variable</span><br><span class="hljs-comment"> RooRealVar::RooRealVar(const char* name, const char* title,Double_t minValue,Double_t maxValue, const char* unit = &quot;&quot; )    */</span><br> RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-number">2.97</span>,<span class="hljs-number">3.03</span>)</span>;<span class="hljs-comment">//observable</span><br> RooRealVar <span class="hljs-title function_">mean</span><span class="hljs-params">(<span class="hljs-string">&quot;mean&quot;</span>,<span class="hljs-string">&quot;mean&quot;</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.2</span>)</span>;<span class="hljs-comment">//mean</span><br> RooRealVar <span class="hljs-title function_">sigma</span><span class="hljs-params">(<span class="hljs-string">&quot;sigma&quot;</span>,<span class="hljs-string">&quot;sigma&quot;</span>,<span class="hljs-number">0.003</span>,<span class="hljs-number">0.002</span>,<span class="hljs-number">0.003</span>)</span>;<span class="hljs-comment">//sigma</span><br> RooAbsPdf* gaus=new RooGaussian(<span class="hljs-string">&quot;gaus&quot;</span>,<span class="hljs-string">&quot;gaus&quot;</span>,x,mean,sigma);<span class="hljs-comment">//representing pdf</span><br> <span class="hljs-comment">//or: RooGaussian gaus(&quot;gaus&quot;,&quot;gaus&quot;,x,mean,sigma) &lt;- this code used more commonly</span><br> RooRealVar <span class="hljs-title function_">n</span><span class="hljs-params">(<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">50000</span>)</span>;<br> RooExtendPdf*<span class="hljs-built_in">exp</span>=new RooExtendPdf(<span class="hljs-string">&quot;exp&quot;</span>,<span class="hljs-string">&quot;exp&quot;</span>,*gaus,n); <br>RooAddPdf <span class="hljs-title function_">total</span><span class="hljs-params">(“total”,”total”,RooArgList(*<span class="hljs-built_in">exp</span>),RooArgList(n))</span>;  <br><br><span class="hljs-comment">//RooAddPdf: define your total PDF</span><br><br>RooAddPd::RooAddPdf(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title, <span class="hljs-type">const</span> RooArgList&amp; pdfList, <span class="hljs-type">const</span> RooArgList&amp; coefList, <span class="hljs-type">bool</span> recursiveFraction = <span class="hljs-literal">false</span>)<br><br><span class="hljs-comment">//coefList-&gt;coefficient List</span><br><br><span class="hljs-comment">//so if you have many pdfs or coefficients, you can use following code </span><br><br><span class="hljs-comment">/* RooArgList pdfList;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     pdfList.add(pdf1);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     pdfList.add(pdf2);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     ……</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   RooArgList numList;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     numList.add(num1);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    numList.add(num2);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">……</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   RooAddPdf mytotpdf(&quot;mytotpdf&quot;, &quot;mytotpdf&quot;,pdfList,numList);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//generate a toy data</span><br>RooDataSet*data;<br>data=gaus-&gt;generate(RooArgSet(x),<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//fit</span><br>RooFitResult*result=total.fitTo(*data,Save(),<span class="hljs-string">&quot;mer&quot;</span>); <br>RooPlot* xframe=x.frame(RooFit::Title(<span class="hljs-string">&quot;Fit GausX&quot;</span>));<br>data-&gt;plotOn(xframe);  <span class="hljs-comment">//data point</span><br>global.plotOn(xframe);<span class="hljs-comment">//fit curve</span><br>xframe-&gt;Draw();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/postfigure/rootfirststepfigure/PastedGraphic3.png"></p><blockquote><p>Homework: fitting with two PDFs(Gaussian and Chebyshev polynomials) </p></blockquote><blockquote><p>Hint: Chebyshev polynomials need one variable</p></blockquote><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">back</span><span class="hljs-params">()</span>&#123;<br>using namespace RooFit;<br><span class="hljs-comment">//build gaussian and shev pdf</span><br>RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-number">2.97</span>,<span class="hljs-number">3.03</span>)</span>;<br>RooRealVar <span class="hljs-title function_">mean</span><span class="hljs-params">(<span class="hljs-string">&quot;mean&quot;</span>,<span class="hljs-string">&quot;mean&quot;</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.2</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigma</span><span class="hljs-params">(<span class="hljs-string">&quot;sigma&quot;</span>,<span class="hljs-string">&quot;sigma&quot;</span>,<span class="hljs-number">0.005</span>,<span class="hljs-number">0.003</span>,<span class="hljs-number">0.007</span>)</span>;<br>RooRealVar <span class="hljs-title function_">a0</span><span class="hljs-params">(<span class="hljs-string">&quot;a0&quot;</span>,<span class="hljs-string">&quot;a0&quot;</span>,<span class="hljs-number">0.005</span>,<span class="hljs-number">0.004</span>,<span class="hljs-number">0.006</span>)</span>;<br>RooAbsPdf* gaus=new RooGaussian(<span class="hljs-string">&quot;gaus&quot;</span>,<span class="hljs-string">&quot;gaus&quot;</span>,x,mean,sigma);<br>RooAbsPdf* shev=new RooChebychev(<span class="hljs-string">&quot;shev&quot;</span>,<span class="hljs-string">&quot;shev&quot;</span>,x,a0);<br>RooRealVar <span class="hljs-title function_">n1</span><span class="hljs-params">(<span class="hljs-string">&quot;n1&quot;</span>,<span class="hljs-string">&quot;n1&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">50000</span>)</span>;<br>RooRealVar <span class="hljs-title function_">n2</span><span class="hljs-params">(<span class="hljs-string">&quot;n2&quot;</span>,<span class="hljs-string">&quot;n2&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">50000</span>)</span>;<br>RooExtendPdf*signal1=new RooExtendPdf(<span class="hljs-string">&quot;sig1&quot;</span>,<span class="hljs-string">&quot;sig1&quot;</span>,*gaus,n1);<br>RooExtendPdf*signal2=new RooExtendPdf(<span class="hljs-string">&quot;sig2&quot;</span>,<span class="hljs-string">&quot;sig2&quot;</span>,*shev,n2);<br>RooAddPdf <span class="hljs-title function_">totalPdf</span><span class="hljs-params">(<span class="hljs-string">&quot;total&quot;</span>,<span class="hljs-string">&quot;total&quot;</span>,RooArgList(*gaus,*shev),RooArgList(n1,n2))</span>;<br><br><span class="hljs-comment">//generate data point</span><br>RooDataSet*data1;<br>RooDataSet*data2;<br>data1=gaus-&gt;generate(RooArgSet(x),<span class="hljs-number">1000</span>);<br>data2=shev-&gt;generate(RooArgSet(x),<span class="hljs-number">1000</span>);<br>data1-&gt;append(*data2);<br><br><span class="hljs-comment">//fit</span><br>RooFitResult*result= totalPdf.fitTo(*data1,Save(),<span class="hljs-string">&quot;mer&quot;</span>);<br>RooPlot*xframe=x.frame();<br>data1-&gt;plotOn(xframe);<br>totalPdf.plotOn(xframe);<br>xframe-&gt;Draw();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/postfigure/rootfirststepfigure/PastedGraphic4.png"></p><hr><h2 id="Lesson-3-2D-fitting"><a href="#Lesson-3-2D-fitting" class="headerlink" title="Lesson 3 2D fitting"></a>Lesson 3 2D fitting</h2><p>Just as the title says, this time we will try 2 dimensions fitting. Relax, it will be very easy if you master what you have learnt before. Additionally, let’s make your graph more “beautiful”!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TH2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TStyle.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TCanvas.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TF1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TText.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TLorentzVector.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TVector3.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TLorentzRotation.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooNumIntConfig.h&quot;</span> <span class="hljs-comment">//no matter what, copy directly!</span></span><br><br>using namespace RooFit;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fit</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//create two canvases, because you have to know two dimensions fitting.</span><br>TCanvas*c1 =new TCanvas(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;Fitting X&quot;</span>);<br>TCanvas*c2 =new TCanvas(<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-string">&quot;Fitting Y&quot;</span>);<br>c1-&gt;SetGrid();<br>c2-&gt;SetGrid();<br><span class="hljs-comment">//build gaussian pdf in two dimension</span><br>RooRealVar <span class="hljs-title function_">x</span><span class="hljs-params">(<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-number">2.7</span>,<span class="hljs-number">11</span>)</span>;<br>  <br>RooRealVar <span class="hljs-title function_">meanx1</span><span class="hljs-params">(<span class="hljs-string">&quot;meanx1&quot;</span>,<span class="hljs-string">&quot;meanx1&quot;</span>,<span class="hljs-number">3.0967</span>,<span class="hljs-number">2.9</span>,<span class="hljs-number">3.2</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigmax1</span><span class="hljs-params">(<span class="hljs-string">&quot;sigmax1&quot;</span>,<span class="hljs-string">&quot;sigmax1&quot;</span>,<span class="hljs-number">0.03</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.06</span>)</span>;<br>RooAbsPdf* gausx1=new RooGaussian(<span class="hljs-string">&quot;gausx1&quot;</span>,<span class="hljs-string">&quot;gausx1&quot;</span>,x,meanx1,sigmax1);<br><br>RooRealVar <span class="hljs-title function_">meanx2</span><span class="hljs-params">(<span class="hljs-string">&quot;meanx2&quot;</span>,<span class="hljs-string">&quot;meanx2&quot;</span>,<span class="hljs-number">3.686</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">3.8</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigmax2</span><span class="hljs-params">(<span class="hljs-string">&quot;sigmax2&quot;</span>,<span class="hljs-string">&quot;sigmax2&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.2</span>)</span>;<br>RooAbsPdf* gausx2=new RooGaussian(<span class="hljs-string">&quot;gausx2&quot;</span>,<span class="hljs-string">&quot;gausx2&quot;</span>,x,meanx2,sigmax2);<br><br>RooRealVar <span class="hljs-title function_">y</span><span class="hljs-params">(<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-number">2.7</span>,<span class="hljs-number">11</span>)</span>;<br>  <br>RooRealVar <span class="hljs-title function_">meany1</span><span class="hljs-params">(<span class="hljs-string">&quot;meany1&quot;</span>,<span class="hljs-string">&quot;meany1&quot;</span>,<span class="hljs-number">3.0967</span>,<span class="hljs-number">2.9</span>,<span class="hljs-number">3.2</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigmay1</span><span class="hljs-params">(<span class="hljs-string">&quot;sigmay1&quot;</span>,<span class="hljs-string">&quot;sigmay1&quot;</span>,<span class="hljs-number">0.03</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.06</span>)</span>;<br>RooAbsPdf* gausy1=new RooGaussian(<span class="hljs-string">&quot;gausy1&quot;</span>,<span class="hljs-string">&quot;gausy1&quot;</span>,y,meany1,sigmay1);<br>  <br>RooRealVar <span class="hljs-title function_">meany2</span><span class="hljs-params">(<span class="hljs-string">&quot;meany2&quot;</span>,<span class="hljs-string">&quot;meany2&quot;</span>,<span class="hljs-number">3.686</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">3.8</span>)</span>;<br>RooRealVar <span class="hljs-title function_">sigmay2</span><span class="hljs-params">(<span class="hljs-string">&quot;sigmay2&quot;</span>,<span class="hljs-string">&quot;sigmay2&quot;</span>,<span class="hljs-number">0.002</span>,<span class="hljs-number">0.001</span>,<span class="hljs-number">0.003</span>)</span>;<br>RooAbsPdf* gausy2=new RooGaussian(<span class="hljs-string">&quot;gausy2&quot;</span>,<span class="hljs-string">&quot;gausy2&quot;</span>,y,meany2,sigmay2);<br><br><br><br><span class="hljs-comment">//constructor with 2 pdf</span><br>RooProdPdf* gausx1y1=new RooProdPdf(<span class="hljs-string">&quot;gausx1y1&quot;</span>,<span class="hljs-string">&quot;gausx1y1&quot;</span>,*gausx1,*gausy1);<br>RooProdPdf* gausx1y2=new RooProdPdf(<span class="hljs-string">&quot;gausx1y2&quot;</span>,<span class="hljs-string">&quot;gausx1y2&quot;</span>,*gausx1,*gausy2);<br>RooProdPdf* gausx2y1=new RooProdPdf(<span class="hljs-string">&quot;gausx2y1&quot;</span>,<span class="hljs-string">&quot;gausx2y1&quot;</span>,*gausx2,*gausy1);<br><br>RooRealVar <span class="hljs-title function_">n_x1y1</span><span class="hljs-params">(<span class="hljs-string">&quot;n1&quot;</span>,<span class="hljs-string">&quot;n1&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">50000</span>)</span>;<br>RooRealVar <span class="hljs-title function_">n_x1y2</span><span class="hljs-params">(<span class="hljs-string">&quot;n2&quot;</span>,<span class="hljs-string">&quot;n2&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">50000</span>)</span>;<br>RooRealVar <span class="hljs-title function_">n_x2y1</span><span class="hljs-params">(<span class="hljs-string">&quot;n3&quot;</span>,<span class="hljs-string">&quot;n3&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">50000</span>)</span>;<br><br>RooExtendPdf*signal1=new RooExtendPdf(<span class="hljs-string">&quot;sig1&quot;</span>,<span class="hljs-string">&quot;sig1&quot;</span>,*gausx1y1,n_x1y1);<br>RooExtendPdf*signal2=new RooExtendPdf(<span class="hljs-string">&quot;sig2&quot;</span>,<span class="hljs-string">&quot;sig2&quot;</span>,*gausx1y2,n_x1y2);<br>RooExtendPdf*signal3=new RooExtendPdf(<span class="hljs-string">&quot;sig3&quot;</span>,<span class="hljs-string">&quot;sig3&quot;</span>,*gausx2y1,n_x2y1);<br><br>RooAddPdf <span class="hljs-title function_">totalPdf</span><span class="hljs-params">(<span class="hljs-string">&quot;total&quot;</span>,<span class="hljs-string">&quot;total&quot;</span>,RooArgList(*gausx1y1,*gausx1y2,*gausx2y1),RooArgList(n_x1y1,n_x1y2,n_x2y1))</span>;<br><br><span class="hljs-comment">//generate data point</span><br><br>RooDataSet*data1;<br>RooDataSet*data2;<br>RooDataSet*data3;<br>data1=gausx1y1-&gt;generate(RooArgSet(x,y),<span class="hljs-number">1000</span>);<br>data2=gausx1y2-&gt;generate(RooArgSet(x,y),<span class="hljs-number">1000</span>);<br>data3=gausx2y1-&gt;generate(RooArgSet(x,y),<span class="hljs-number">1000</span>);<br><br>data1-&gt;append(*data2);<br>data1-&gt;append(*data3);<br><br><span class="hljs-comment">//fit</span><br>RooFitResult*result= totalPdf.fitTo(*data1,Save(),<span class="hljs-string">&quot;mer&quot;</span>);<br><span class="hljs-comment">//x dimension</span><br><br>c1-&gt;cd();<br>RooPlot*xframe=x.frame(RooFit::Title(<span class="hljs-string">&quot;Fit GausX&quot;</span>));<br>data1-&gt;plotOn(xframe);<br>totalPdf.plotOn(xframe,Name(<span class="hljs-string">&quot;fullModel&quot;</span>));<br>totalPdf.plotOn(xframe,Components(*gausx1y1),LineColor(<span class="hljs-number">2</span>),LineStyle(<span class="hljs-number">1</span>),Name(<span class="hljs-string">&quot;JpsiJpsi&quot;</span>));<br>totalPdf.plotOn(xframe,Components(*signal2),LineColor(<span class="hljs-number">6</span>),LineStyle(<span class="hljs-number">1</span>),Name(<span class="hljs-string">&quot;JpsiPsi2S&quot;</span>));<br>totalPdf.plotOn(xframe,Components(*gausx2y1),LineColor(<span class="hljs-number">7</span>),LineStyle(<span class="hljs-number">1</span>),Name(<span class="hljs-string">&quot;Psi2SJpsi&quot;</span>));<br><br>TLegend <span class="hljs-title function_">leg</span><span class="hljs-params">(<span class="hljs-number">0.7</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.9</span>)</span>;<br>leg.AddEntry(xframe-&gt;findObject(<span class="hljs-string">&quot;fullModel&quot;</span>), <span class="hljs-string">&quot;Full Model&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br>leg.AddEntry(xframe-&gt;findObject(<span class="hljs-string">&quot;JpsiJpsi&quot;</span>), <span class="hljs-string">&quot;J/#psi_&#123;#mu1#mu2&#125;J/#psi_&#123;#mu3#mu4&#125;&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br>leg.AddEntry(xframe-&gt;findObject(<span class="hljs-string">&quot;JpsiPsi2S&quot;</span>), <span class="hljs-string">&quot;J/#psi_&#123;#mu1#mu2&#125;#psi(2S)_&#123;#mu3#mu4&#125;&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br>leg.AddEntry(xframe-&gt;findObject(<span class="hljs-string">&quot;Psi2SJpsi&quot;</span>), <span class="hljs-string">&quot;#psi(2S)_&#123;#mu1#mu2&#125;J/#psi_&#123;#mu3#mu4&#125;&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br><br>xframe-&gt;Draw();<br>leg.DrawClone();<br><br><br><br><span class="hljs-comment">//y dimension</span><br><br>c2-&gt;cd();<br>RooPlot*yframe=y.frame(RooFit::Title(<span class="hljs-string">&quot;Fit GausY&quot;</span>));<br>data1-&gt;plotOn(yframe);<br>totalPdf.plotOn(yframe);<br>totalPdf.plotOn(yframe,Name(<span class="hljs-string">&quot;fullModel&quot;</span>));<br>totalPdf.plotOn(yframe,Components(*gausx1y1),LineColor(<span class="hljs-number">2</span>),LineStyle(<span class="hljs-number">1</span>),Name(<span class="hljs-string">&quot;JpsiJpsi&quot;</span>));<br>totalPdf.plotOn(yframe,Components(*signal2),LineColor(<span class="hljs-number">6</span>),LineStyle(<span class="hljs-number">1</span>),Name(<span class="hljs-string">&quot;JpsiPsi2S&quot;</span>));<br>totalPdf.plotOn(yframe,Components(*gausx2y1),LineColor(<span class="hljs-number">7</span>),LineStyle(<span class="hljs-number">1</span>),Name(<span class="hljs-string">&quot;Psi2SJpsi&quot;</span>));<br><br><br>TLegend <span class="hljs-title function_">leg2</span><span class="hljs-params">(<span class="hljs-number">0.7</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.9</span>)</span>;<br>leg2.AddEntry(yframe-&gt;findObject(<span class="hljs-string">&quot;data1&quot;</span>), <span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;pe&quot;</span>);<br>leg2.AddEntry(yframe-&gt;findObject(<span class="hljs-string">&quot;fullModel&quot;</span>), <span class="hljs-string">&quot;Total Fit&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br>leg2.AddEntry(yframe-&gt;findObject(<span class="hljs-string">&quot;JpsiJpsi&quot;</span>), <span class="hljs-string">&quot;J/#psi_&#123;#mu1#mu2&#125;J/#psi_&#123;#mu3#mu4&#125;&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br>leg2.AddEntry(yframe-&gt;findObject(<span class="hljs-string">&quot;JpsiPsi2S&quot;</span>), <span class="hljs-string">&quot;J/#psi_&#123;#mu1#mu2&#125;#psi(2S)_&#123;#mu3#mu4&#125;&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br>leg2.AddEntry(yframe-&gt;findObject(<span class="hljs-string">&quot;Psi2SJpsi&quot;</span>), <span class="hljs-string">&quot;#psi(2S)_&#123;#mu1#mu2&#125;J/#psi_&#123;#mu3#mu4&#125;&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>);<br><br>yframe-&gt;Draw();<br>leg2.DrawClone();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ebook</title>
    <link href="/2024/10/12/ebookdownload/"/>
    <url>/2024/10/12/ebookdownload/</url>
    
    <content type="html"><![CDATA[<style>  .ebook-cover {    margin-right: 10px;    margin-left: 10px;    position: relative;  }  .ebook-container {  display: inline-block;  text-align: center;  margin-bottom: 20px;  }  .ebook-title {    display: block;    margin-top: 10px;    font-size: 14px;    color: #333;  }</style><div class="ebook-container">  <a href="/download/new_Instruction_for_CERN_account.pdf">    <img class="ebook-cover" src="/postfigure/ebook/CERN70.jpg" alt="new_Instruction_for_CERN_account" width="200" height="300">  </a>  <span class="ebook-title">New Instruction for CERN account</span></div><div class="ebook-container">  <a href="/download/鸟哥的Linux私房菜基础学习篇第四版.pdf">    <img class="ebook-cover" src="/postfigure/ebook/鸟哥的Linux私房菜基础学习篇第四版.jpg" alt="鸟哥的Linux私房菜基础学习篇第四版" width="200" height="300">  </a>  <span class="ebook-title">鸟哥的Linux私房菜基础学习篇第四版</span></div><div class="ebook-container">  <a href="/download/Introductiontoelementaryparticles.pdf">    <img class="ebook-cover" src="/postfigure/ebook/Introductiontoelementaryparticles.jpg" alt="Introductiontoelementaryparticles" width="200" height="300">  </a>  <span class="ebook-title">Introduction to Elementary Particles</span></div>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learning note</title>
    <link href="/2024/10/11/multilepnote/"/>
    <url>/2024/10/11/multilepnote/</url>
    
    <content type="html"><![CDATA[<h2 id="0-序"><a href="#0-序" class="headerlink" title="0-序"></a>0-序</h2><p>终端中的vim编辑器面对这样的大型代码会异常难用，特别是像lpc这种延迟很高的服务器，强烈建议使用vscode和各种插件方便你的工作！<a href="https://code.visualstudio.com/">下载vscode</a> </p><p><img src="/postfigure/multilepnote/image-18.png"> </p><p>这三个插件可以ssh登录到集群，推荐登录hepthu集群体验会很好，下面的插件可以选择安装</p><p><img src="/postfigure/multilepnote/image.png" alt="" style="zoom:150%;" /><img src="/postfigure/multilepnote/image-1.png"></p><p>本篇note只会介绍程序的逻辑关系以及需要用到的变量设置，会有很多未涉及的细节部分，比如这个变量为什么要这样用，为什么这个函数要加这个变量等。对于这些问题一部分是我并不清楚该如何解释，还有大部分是底层代码的关系，你可以在<a href="https://cmsdoxygen.web.cern.ch/cmsdoxygen/">CMSSW Reference Manual (cern.ch)</a>中查到对应的变量的用法。比如你可以在pat::Muon里面找到MuonID的函数，会发现<code>isSoftMuon</code>里面需要一个<code>reco::Vertex</code>的变量，而<code>isLooseMuon</code>则不需要，你还能在里面找到更详细的关于MuonID的介绍。你还可以在<a href="https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookCMSSWFramework">WorkBookCMSSWFramework &lt; CMSPublic &lt; TWiki (cern.ch)</a>中找到更详细的关于CMSSW work。</p><p><img src="/postfigure/multilepnote/image-20240809212857446.png" alt="" style="zoom:50%;" /><img src="/postfigure/multilepnote/image-20240809213052779.png"><img src="/postfigure/multilepnote/image-20240809213635011.png" alt="" style="zoom:50%;" /></p><p>Tip: Here are the empty files in following path, you can copy it to your work directory using <strong><code>cmsrel CMSSW_13_0_13</code></strong> cms-software version because of the root file we will use. I also dropped some hints in the corresponding folder named as ‘_hint’. So, if and only if you are stuck, you can get some helps with it.<br>ps: hepthu集群在cmsRun时会出现问题，推荐在lxplus集群上进行下面的工作</p><blockquote><p>&#x2F;home&#x2F;storage0&#x2F;users&#x2F;zhufeng&#x2F;formymultilep_learning&#x2F;UserCode<br>&#x2F;afs&#x2F;cern.ch&#x2F;user&#x2F;z&#x2F;zhuf&#x2F;public&#x2F;UserCode&#x2F;MuMuEEPat&#x2F;</p></blockquote><h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1-文件结构"></a>1-文件结构</h2><p>MuMuEEPat.h 头文件用于声明函数变量等，不包含具体实现的细节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MuMuEEPat</span> : <span class="hljs-keyword">public</span> edm::one::EDAnalyzer&lt;edm::one::SharedResources&gt;&#123;<br><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//public成员可以从类的外部访问,任何对象或者函数都可以访问类的public成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MuMuEEPat</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::ParameterSet&amp;)</span></span>; <span class="hljs-comment">//初始化</span><br>  ~<span class="hljs-built_in">MuMuEEPat</span>();<br>  <br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//private成员只能从类的内部访问。只有类的成员函数可以访问类的private成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">beginJob</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">beginRun</span><span class="hljs-params">(edm::Run <span class="hljs-type">const</span> &amp; iRun, edm::EventSetup <span class="hljs-type">const</span>&amp; iSetup)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp;, <span class="hljs-type">const</span> edm::EventSetup&amp;)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endJob</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//你可以不用理解上面在干什么，copy it directly!</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>MuMuEEPat.cc 源文件中就是具体分析过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++">MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>&#123;<br><span class="hljs-comment">//进行变量的初始化</span><br>&#125;<br><br>MuMuEEPat::~<span class="hljs-built_in">MuMuEEPat</span>()<br>&#123;<br><span class="hljs-comment">//未知（清除缓存？</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::beginJob</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//在进行analyze的循环之前运行的部分，这里就需要定义你需要的变量了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::beginRun</span><span class="hljs-params">(edm::Run <span class="hljs-type">const</span> &amp; iRun, edm::EventSetup <span class="hljs-type">const</span>&amp; iSetup)</span> </span>&#123;<br><span class="hljs-comment">//未知</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span> </span>&#123;<br><span class="hljs-comment">//主要的分析程序，会自动循环  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> </span><br><span class="hljs-function"><span class="hljs-title">MuMuEEPat::endJob</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//analyze的循环过程中会不断在你定义的tree中填入数据，循环结束后你就需要把这个tree给写入到一个文件中，并进行必要的缓存清理</span><br>&#125;<br><br><span class="hljs-built_in">DEFINE_FWK_MODULE</span>(MuMuEEPat);<br></code></pre></td></tr></table></figure><p>Tips: 你需要在UserCode的上一级目录下用下面的命令编译你的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">scramv1 b ProjectRename <br>scramv1 b clean <span class="hljs-comment">#当你进入到一个新的工作目录的时候你需要上面两行</span><br>scramv1 b <span class="hljs-comment">#当你修改了你的代码的时候用这一句就可以编译了</span><br></code></pre></td></tr></table></figure><h2 id="2-创建与使用tree"><a href="#2-创建与使用tree" class="headerlink" title="2-创建与使用tree"></a>2-创建与使用tree</h2><p>我们需要在一棵树上放上许多枝桠，将数据分类存储到枝桠对应的树叶中。正如之前所说，种一棵树的最好时机是在之前(beginjob)。对应的在.h文件中要对tree和branch中的vector进行定义。在进行analyze之后，树上已经枝繁叶茂了，我们就需要在endjobs里面把这颗树给输出出来。至于如何在analyze中在这棵树上塞入树叶，接着往下看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.h</span><br>...<br><span class="hljs-comment">//define token begain</span><br>edm::EDGetTokenT&lt;edm::View&lt;pat::Muon&gt; &gt; gtpatmuonToken_;<br>edm::ESGetToken&lt;MagneticField, IdealMagneticFieldRecord&gt; magneticFieldToken_;<br><span class="hljs-comment">//define token end</span><br><br>TTree* X_One_Tree_;<span class="hljs-comment">//Tree是必须的，便利起见，这里我们只用一个Tree存储所有变量</span><br>vector&lt;<span class="hljs-type">double</span>&gt; *mumuonlyMass, *mumuonlyMassErr;<span class="hljs-comment">//在.h文件中定义你的tree和变量，这里我们用向量数组存储数据</span><br>...<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br>MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>:<span class="hljs-built_in">magneticFieldToken_</span>(<span class="hljs-built_in">esConsumes</span>&lt;MagneticField, IdealMagneticFieldRecord&gt;()),<br>...,<br><span class="hljs-built_in">mumuonlyMass</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">mumuonlyMassErr</span>(<span class="hljs-number">0</span>),<br>...<span class="hljs-comment">//这里是所有你在.h定义的变量初始化参数的地方，初始化时需要与定义的顺序一致，注意最后的变量没有逗号</span><br>&#123;<br><span class="hljs-comment">//extract toke begain</span><br>gtpatmuonToken_ = consumes&lt;edm::View&lt;pat::Muon&gt; &gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;slimmedMuons&quot;</span>));<br><span class="hljs-comment">//extract toke end</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::beginJob</span><span class="hljs-params">()</span> </span>&#123;<br>edm::Service &lt; TFileService &gt; fs;<br>X_One_Tree_ = fs-&gt;make &lt; TTree &gt; (<span class="hljs-string">&quot;X_data&quot;</span>, <span class="hljs-string">&quot;X_Data&quot;</span>);<span class="hljs-comment">//定义tree的名字，相当于你种下一棵树命名为X_Data</span><br>X_One_Tree_-&gt;<span class="hljs-built_in">Branch</span>(<span class="hljs-string">&quot;mumuonlyMass&quot;</span>,&amp;mumuonlyMass);<br>X_One_Tree_-&gt;<span class="hljs-built_in">Branch</span>(<span class="hljs-string">&quot;mumuonlyMassErr&quot;</span>,&amp;mumuonlyMassErr);<span class="hljs-comment">//定义重名的branch，指向对应的vector，这里意味着你之前的种下的树长出了枝桠</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span><span class="hljs-comment">//值得留意的是，这个部分的程序按理来说只会对一个对撞事例运行进行筛选，并没有写对所有事例循环的语句，不用担心，在运行的时候会自动对所有的事例循环的，这也是程序会分不同部分的原因</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-keyword">for</span>(...)&#123;<span class="hljs-comment">//对一个事例中的所有muon进行循环，可以设置条件去筛选你想要的muon并获取这些muon的物理量</span><br>  ...<br>  mumuonlyMass-&gt;<span class="hljs-built_in">push_back</span>(...);<br>  mumuonlyMassErr-&gt;<span class="hljs-built_in">push_back</span>(...);<span class="hljs-comment">//将数据填入数组的主要方式</span><br>  ...<br>&#125;<br>...<br><br><span class="hljs-comment">//clear</span><br>X_One_Tree_-&gt;<span class="hljs-built_in">Fill</span>();<span class="hljs-comment">//树叶在之前的for循环中已经获取了，用这一句话就能让这些数据到对应的枝桠上，去塞满你的树吧</span><br>mumuonlyMass-&gt;<span class="hljs-built_in">clear</span>();mumuonlyMassErr-&gt;<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//因为接下来你需要对下一个事例中的muon再进行analyze部分的程序，因而需要把你的数组进行清空，避免数据重复</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::endJob</span><span class="hljs-params">()</span> </span>&#123;<br>X_One_Tree_-&gt;<span class="hljs-built_in">Write</span>();<span class="hljs-comment">//当运行完analyze部分之后,用这个命令就能将你的Tree保存下来</span><br><span class="hljs-keyword">delete</span> X_One_Tree_;<span class="hljs-comment">//删除清理缓存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>summary：如果你想新加入一个变量，你需要:</p><p>1.在.h文件中定义你的变量名，注意顺序和数据类型<br>2.在.cc文件中的iConfig中初始化你的变量，注意顺序<br>3.在.cc文件中的beginJob中定义你要存储变量在Tree上对应的branch，通常是与变量同名的<br>4.在.cc文件中的analyze中填入你的数据进变量中，并在最后的clear部分进行必要的清除</p><p>可以用下面两幅图概括</p><p><img src="/postfigure/multilepnote/image-20240809222837449.png"><img src="/postfigure/multilepnote/image-20240809222627359.png"></p><p>接下来两节我们将尝试输出事例中的mumu对的物理信息,第一步搭建for循环，对事例中的muon进行配对，第二步拟合muon的track获取物理信息并输出</p><h2 id="3-for循环起始"><a href="#3-for循环起始" class="headerlink" title="3-for循环起始"></a>3-for循环起始</h2><p>note:以下部分省略了一些变量的定义、初始化和清理过程，请参照之前的章节进行对应操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.h </span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//define toke begain</span><br>edm::EDGetTokenT&lt;edm::View&lt;pat::Muon&gt; &gt; gtpatmuonToken_;<span class="hljs-comment">//获取pat::Muon的token</span><br>edm::ESGetToken&lt;MagneticField, IdealMagneticFieldRecord&gt; magneticFieldToken_;<span class="hljs-comment">//获取MagneticField的token</span><br><span class="hljs-comment">//define toke end</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br>MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>:<span class="hljs-built_in">magneticFieldToken_</span>(<span class="hljs-built_in">esConsumes</span>&lt;MagneticField, IdealMagneticFieldRecord&gt;())<br>&#123;<br><span class="hljs-comment">//extract toke</span><br>gtpatmuonToken_ = consumes&lt;edm::View&lt;pat::Muon&gt; &gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;slimmedMuons&quot;</span>));<span class="hljs-comment">//在.h文件中导入了pat::Muon的token在这里就可以提取出来</span><br><span class="hljs-comment">//extract toke</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的gtpatmuonToken_是一个成员变量，它保存了一个Token。这个Token表示模块需要pat::Muon类型的对象，数据来源是一个名为“slimmedMuons”的数据集（由edm::InputTag指定）。这个数据集名称是在数据处理链中定义的，用于标识数据源。<br>可以用下面的方式查看这个tag是什么（通常不用Displaced，至于其他的rootfile的情况不清楚是怎样的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ edmDumpEventContent f8e93985-e14c-4a8a-b28b-f8cceb3c878e.root<br>...<br>vector&lt;pat::Muon&gt;                     <span class="hljs-string">&quot;slimmedDisplacedMuons&quot;</span>     <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-string">&quot;PAT&quot;</span><br>vector&lt;pat::Muon&gt;                     <span class="hljs-string">&quot;slimmedMuons&quot;</span>              <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-string">&quot;PAT&quot;</span>  <br>...  <br></code></pre></td></tr></table></figure><p>pat::Muon是一个代表μ子的对象类型，它是分析中使用的“物理对象”（Physics Object）的一种。PAT（Physics Analysis Toolkit）是CMSSW中的一个包，提供了一组标准的高层次的物理对象类型，如电子、μ子、喷流（jets）等。pat::Muon对象包含了关于μ子的各种信息，例如动量、能量、轨迹等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// analyze</span><br>edm::Handle&lt;edm::View&lt;pat::Muon&gt;&gt; thePATMuonHandle;<span class="hljs-comment">//使用edm::Handle可以确保在访问数据时，这些数据对象是有效的并且已被正确初始化。定义一个智能指针 thePATMuonHandle</span><br>iEvent.<span class="hljs-built_in">getByToken</span>(gtpatmuonToken_, thePATMuonHandle);<span class="hljs-comment">//将之前的token提取出来并存储到 thePATMuonHandle</span><br>edm::View &lt;pat::Muon&gt;::const_iterator iMuon1;<span class="hljs-comment">//定义两个指向 edm::View&lt;pat::Muon&gt; 中 pat::Muon 对象常量迭代器，只读而不能修改</span><br>edm::View &lt;pat::Muon&gt;::const_iterator iMuon2;<br><span class="hljs-keyword">for</span> (iMuon1 = thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>();iMuon1 != thePATMuonHandle-&gt;<span class="hljs-built_in">end</span>(); ++iMuon1) &#123;<br>    TrackRef muTrack1 = iMuon1-&gt;<span class="hljs-built_in">track</span>();<span class="hljs-comment">//与下面的reco::Track区别在于，muTrack1可以用于轻量地操作，比如为了看这个track是否是有效的，下面的那个就直接重建出来值，用于track数据的存储，这样做是为了节省运算量，总之，muTrack1更适合进行一些操作运算</span><br>    <span class="hljs-keyword">if</span> (muTrack<span class="hljs-number">1.</span><span class="hljs-built_in">isNull</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//检测两个muon的track是否有效，如果track是无效的，跳过下面的步骤</span><br>    reco::Track recoMu1 = *iMuon1-&gt;<span class="hljs-built_in">track</span>();<span class="hljs-comment">//有效的muon的track进行重建并存储到recoMu1</span><br>    <span class="hljs-keyword">for</span> (iMuon2 = iMuon1 + <span class="hljs-number">1</span>; iMuon2 != thePATMuonHandle-&gt;<span class="hljs-built_in">end</span>(); ++iMuon2) &#123;<span class="hljs-comment">//为了寻找两个配对在一起的muon，就需要循环n(n-1)/2次</span><br>        TrackRef muTrack2 = iMuon2-&gt;<span class="hljs-built_in">track</span>();<br>        <span class="hljs-keyword">if</span> (muTrack<span class="hljs-number">2.</span><span class="hljs-built_in">isNull</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>        reco::Track recoMu2 = *iMuon2-&gt;<span class="hljs-built_in">track</span>();<br>        <span class="hljs-keyword">if</span> ( (iMuon1-&gt;<span class="hljs-built_in">charge</span>()+iMuon2-&gt;<span class="hljs-built_in">charge</span>() ) == <span class="hljs-number">0</span> ) &#123;<span class="hljs-comment">//需要mu+ mu-电荷相加等于0</span><br>            <span class="hljs-comment">//next part</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>&#125;<span class="hljs-comment">// analyze</span><br></code></pre></td></tr></table></figure><h2 id="4-track拟合"><a href="#4-track拟合" class="headerlink" title="4-track拟合"></a>4-track拟合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MuMuEEPat::analyze</span><span class="hljs-params">(<span class="hljs-type">const</span> edm::Event&amp; iEvent, <span class="hljs-type">const</span> edm::EventSetup&amp; iSetup)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// analyze</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> myMumass = <span class="hljs-number">0.1056583745</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> myMumasserr = myMumass * <span class="hljs-number">1e-6</span>;<span class="hljs-comment">//后面会用到的妙妙工具</span><br><span class="hljs-comment">//////......//////</span><br><span class="hljs-keyword">if</span> ( (iMuon1-&gt;<span class="hljs-built_in">charge</span>()+iMuon2-&gt;<span class="hljs-built_in">charge</span>() ) == <span class="hljs-number">0</span> ) &#123;<br>  <span class="hljs-function">TransientTrack <span class="hljs-title">muonPTT</span><span class="hljs-params">(muTrack1, &amp;(bFieldHandle))</span></span>;<br>  <span class="hljs-function">TransientTrack <span class="hljs-title">muonMTT</span><span class="hljs-params">(muTrack2, &amp;(bFieldHandle))</span></span>;<span class="hljs-comment">//获取muon的track信息，需要track的数据和磁场信息，命名为minus</span><br>  KinematicParticleFactoryFromTransientTrack pmumuFactory;<br>  ParticleMass muon_mass = myMumass;<br>  <span class="hljs-type">float</span> muon_sigma = myMumasserr;<br>  <span class="hljs-type">float</span> chi = <span class="hljs-number">0.</span>;<br>  <span class="hljs-type">float</span> ndf = <span class="hljs-number">0.</span>;<br>  vector &lt; RefCountedKinematicParticle &gt; muonParticles;<br>  muonParticles.<span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonPTT, muon_mass, chi, ndf, muon_sigma));<br>  muonParticles.<span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonMTT, muon_mass, chi, ndf, muon_sigma));<br>  <span class="hljs-comment">//以上是对track的拟合</span><br>  KinematicParticleVertexFitter fitter;<br>  RefCountedKinematicTree psiVertexFitTree;<br>  psiVertexFitTree = fitter.<span class="hljs-built_in">fit</span>(muonParticles);<br>  <span class="hljs-comment">//以上是对顶点的拟合</span><br>  <span class="hljs-keyword">if</span> (psiVertexFitTree-&gt;<span class="hljs-built_in">isValid</span>()) &#123;<span class="hljs-comment">//顶点拟合有效，则</span><br>    psiVertexFitTree-&gt;<span class="hljs-built_in">movePointerToTheTop</span>();<span class="hljs-comment">//这个tree的结构是psi-&gt;mu mu所以Top就是psi，后面还会用到FirstChild，NextChild指的就是mu mu了，Child排序按照muon的动量大小排序</span><br>    RefCountedKinematicParticle psi_vFit_noMC = psiVertexFitTree-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    RefCountedKinematicVertex psi_vFit_vertex_noMC = psiVertexFitTree-&gt;<span class="hljs-built_in">currentDecayVertex</span>();<br>    KinematicParameters mymumupara=  psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    <span class="hljs-comment">//以上是对这个tree提取数据</span><br>    mumuonlyMass-&gt;<span class="hljs-built_in">push_back</span>(psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">mass</span>());<br> <br>  &#125;<br>&#125;<span class="hljs-comment">// analyze</span><br></code></pre></td></tr></table></figure><p>试着将下面的这些变量都在Tree里面存储下来吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//MuMuEEPat.cc</span><br><span class="hljs-type">float</span> mymumuonlyctau=<span class="hljs-built_in">GetcTau</span>(psi_vFit_vertex_noMC,psi_vFit_noMC,theBeamSpotV);<br><span class="hljs-type">float</span> mymumuonlyctauerr=<span class="hljs-built_in">GetcTauErr</span>(psi_vFit_vertex_noMC,psi_vFit_noMC,theBeamSpotV);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyChg&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon2-&gt;<span class="hljs-built_in">charge</span>()) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyctau&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumuonlyctau &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyctauerr&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumuonlyctauerr&lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyVtxCL&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">ChiSquaredProbability</span>((<span class="hljs-type">double</span>)(psi_vFit_vertex_noMC-&gt;<span class="hljs-built_in">chiSquared</span>()),(<span class="hljs-type">double</span>)(psi_vFit_vertex_noMC-&gt;<span class="hljs-built_in">degreesOfFreedom</span>())) &lt;&lt; std::endl;<br>mumuonlyMass-&gt;<span class="hljs-built_in">push_back</span>(psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">mass</span>());<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyMass&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">mass</span>() &lt;&lt; std::endl;  <span class="hljs-function">no mass constrain</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">( psi_vFit_noMC-&gt;currentState().kinematicParametersError().matrix()(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)&gt;<span class="hljs-number">0</span>)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyMassErr&quot;</span> &lt;&lt; <span class="hljs-built_in">sqrt</span>(psi_vFit_noMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParametersError</span>().<span class="hljs-built_in">matrix</span>()(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)) &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  mumuonlyMassErr-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-9</span>);<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyPx&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumupara.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyPy&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumupara.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlyPz&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mymumupara.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlymu1Idx&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), iMuon1)&lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mumuonlymu2Idx&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), iMuon2)&lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>summary：</p><p>以上部分可以理解为，我们对探测器中的$\mu$子进行重建，并尝试将重建的$\mu$子对的顶点进行拟合，选择那些由一个粒子衰变出来两个正负$\mu$子的过程，将这个重建出来的粒子的物理信息输出出来。<br>现在你已经掌握了如何在一个事例中筛选并提取简单的muon对的物理信息了，这代表着你已经掌握了绝大部分代码的逻辑关系！接下来就是要输出更多有用的物理信息，不过在此之前，为什么不看一眼你的 $ J&#x2F; \psi $ 是什么样子的呢？</p><h2 id="5-myntuple-分析root文件"><a href="#5-myntuple-分析root文件" class="headerlink" title="5-myntuple 分析root文件"></a>5-myntuple 分析root文件</h2><p>runMuMuEEPAT_data_Run2012CMSSW53XJan.py -&gt; ivars.outputFile&#x3D;’mymultilep.root’ 会根据你之前写的.cc文件进行筛选输出这个root文件，<code>cmsenv</code>配置环境之后，用下面的命令运行这个py文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmsRun runMultiLepPAT_dataRun3_miniAOD.py<br></code></pre></td></tr></table></figure><p>一个ntuple的job需要 myntuple.C.rootmap，myntuple.C，myntuple.h和一个运行的Runjobs.py文件</p><p>.rootmap是通用的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//myntuple.C.rootmap</span><br>&#123; decls &#125;<br>[ myntuple_C.so ]<br>namespace myntuple<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myntuple</span>:</span>:myntuple<br>header myntuple.h<br></code></pre></td></tr></table></figure><p>.C与.h文件可以通过mymultilep.root生成一个空文件，在里面填入你想要输出的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l mymultilep.root<br>.<span class="hljs-built_in">ls</span>   //mkcands<br>mkcands-&gt;<span class="hljs-built_in">cd</span>()<br>.<span class="hljs-built_in">ls</span>   //X_data<br>X_data-&gt;MakeClass(<span class="hljs-string">&quot;myntuple&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//会生成这样的.C文件和一个包含你在之前.cc里面定义过的所有变量的.h文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myntuple_cxx</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myntuple.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TH2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TStyle.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TCanvas.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myntuple::Loop</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">if</span> (fChain == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>Long64_t nentries = fChain-&gt;GetEntriesFast();<br>Long64_t nbytes = <span class="hljs-number">0</span>, nb = <span class="hljs-number">0</span>;<br><br>TFile* myhbk = new TFile (<span class="hljs-string">&quot;myhbk.root&quot;</span>,<span class="hljs-string">&quot;recreate&quot;</span>);<span class="hljs-comment">//创建一个root，将所有你想画出来的直方图都放进去</span><br>TH1F* mumumass = new TH1F(<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>);<span class="hljs-comment">//创建一个一维直方图</span><br>TH1F* mumumasserr = new TH1F(<span class="hljs-string">&quot;mumumasserr&quot;</span>,<span class="hljs-string">&quot;mumumasserr&quot;</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>);<br><span class="hljs-keyword">for</span> (Long64_t jentry=<span class="hljs-number">0</span>; jentry&lt;nentries;jentry++) &#123;<span class="hljs-comment">//对每个事例进行loop</span><br>  Long64_t ientry = LoadTree(jentry);<br>  <span class="hljs-keyword">if</span> (ientry &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>  nb = fChain-&gt;GetEntry(jentry);   nbytes += nb;<br>  <span class="hljs-comment">// if (Cut(ientry) &lt; 0) continue;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> myi = <span class="hljs-number">0</span>; myi &lt; mumuonlyMass-&gt;size(); myi++) &#123;<span class="hljs-comment">//对一个事例中的mumu进行loop</span><br>     mumumass-&gt;Fill((*mumuonlyMass)[myi]);<span class="hljs-comment">//将你的变量填入到你定义的直方图中</span><br>    mumumasserr-&gt;Fill((*mumuonlyMassErr)[myi]);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (jentry%<span class="hljs-number">10000</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I am running &quot;</span> &lt;&lt; jentry &lt;&lt; <span class="hljs-string">&quot; th entries out of &quot;</span> &lt;&lt; nentries &lt;&lt; <span class="hljs-string">&quot; total entries&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>myhbk-&gt;Write(); <span class="hljs-comment">//这一句就能将所有你填入的直方图保存下来</span><br>&#125;<span class="hljs-comment">//end</span><br></code></pre></td></tr></table></figure><p>Tips:这里需要说明几个概念。nentries可以看作是对撞事例的编号，所以第一个for循环是为了对所用的对撞事例进行循环的，而第二个for循环是对一次事例中的<code>mumuonlyMass-&gt;size()</code>进行循环，这里取的编号是mumu对的编号，也就是对所有的$\mu$子对进行循环。在之后你还会尝试对单个$\mu$子进行操作，逻辑也是如此。<br><img src="/postfigure/multilepnote/IMG_0585.jpeg"></p><p>写好myntuple.C之后，需要进行编译（这里有一个trick但我忘记了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l <br>.L myntuple.C++<br></code></pre></td></tr></table></figure><p>编译完成后就能运行Runjobs.C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Runjobs</span><span class="hljs-params">()</span><br>&#123;<br>gSystem-&gt;Load(<span class="hljs-string">&quot;myntuple_C.so&quot;</span>);<br>TChain * chain = new TChain(<span class="hljs-string">&quot;/mkcands/X_data&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>chain-&gt;Add(<span class="hljs-string">&quot;./mymultilep.root&quot;</span>);<span class="hljs-comment">//这里放入你在cmsRun生成的文件</span><br>myntuple <span class="hljs-title function_">a</span><span class="hljs-params">(chain)</span>;<br>a.Loop();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l -b -q Runjobs.C <span class="hljs-comment">#-l 是不显示root启动界面，-b 以批处理模式运行，不显示图形界面， -q 处理完命令行宏文件后退出。这个命令通常在需要跑很多文件的时候配合脚本使用</span><br></code></pre></td></tr></table></figure><p>运行完成后会生成一个root文件，就是你在myntuple.C中命名的那个myhbk.root，你可以用一些命令去看里面的直方图，不过更推荐用vscode和root file viewer这个插件去看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root -l myhbk.root<br>root [0] <br>Attaching file myhbk.root as _file0...<br>(TFile *) 0x1cc6e10<br>root [1] .<span class="hljs-built_in">ls</span><br>TFile**         myhbk.root<br> TFile*         myhbk.root<br>  KEY: TH1F     mumumass;1      mumumass<br>root [2] mumumass-&gt;GetXaxis()-&gt;SetRangeUser(0.5, 5)<br>root [3] mumumass-&gt;Draw()<br></code></pre></td></tr></table></figure><h2 id="6-Muon-ID的输出"><a href="#6-Muon-ID的输出" class="headerlink" title="6-Muon ID的输出"></a>6-Muon ID的输出</h2><p>Muon ID 本质上是对$\mu$子的一些筛选条件的整合，将其打上Loose, soft, medium, tight等标签，以方便我们的分析，如果你完成了这一章，你就能在你的myntuple.C中用MuonID设置你自己的筛选条件了。这一节会介绍以下这几个ID的输出方式以及必要的物理信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">muIsPatLooseMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isLooseMuon</span>());<br>muIsPatTightMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isTightMuon</span>(thePrimaryV));<br>muIsPatSoftMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isSoftMuon</span>(thePrimaryV));<br>muIsPatMediumMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isMediumMuon</span>());<br></code></pre></td></tr></table></figure><p>需要注意的有两点：<br>1.与之前输出mu子对不同，这次是输出单个mu子的信息<br>2.有些muon ID需要PrimaryVetex的信息，而PrimaryVetex需要获取beamSpot的信息，</p><p>下面是需要用到的妙妙工具，把他们放入到合适的地方吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.h</span><br>edm::EDGetTokenT&lt;BeamSpot&gt; gtbeamspotToken_;<br>edm::EDGetTokenT&lt;VertexCollection&gt; gtprimaryVtxToken_;<br><span class="hljs-type">bool</span> addXlessPrimaryVertex_; <span class="hljs-type">bool</span> resolveAmbiguity_;<br><br><span class="hljs-comment">//.cc</span><br>MuMuEEPat::<span class="hljs-built_in">MuMuEEPat</span>(<span class="hljs-type">const</span> edm::ParameterSet&amp; iConfig)<br>:<span class="hljs-built_in">addXlessPrimaryVertex_</span>(iConfig.getUntrackedParameter &lt; <span class="hljs-type">bool</span> &gt; (<span class="hljs-string">&quot;addXlessPrimaryVertex&quot;</span>, <span class="hljs-literal">true</span>)),<br><span class="hljs-built_in">resolveAmbiguity_</span>(iConfig.getUntrackedParameter &lt; <span class="hljs-type">bool</span> &gt; (<span class="hljs-string">&quot;resolvePileUpAmbiguity&quot;</span>, <span class="hljs-literal">true</span>))<br>&#123;<br>gtbeamspotToken_ = <span class="hljs-built_in">consumes</span>&lt;BeamSpot&gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;offlineBeamSpot&quot;</span>));<br>gtprimaryVtxToken_ = <span class="hljs-built_in">consumes</span>&lt;VertexCollection&gt;(edm::<span class="hljs-built_in">InputTag</span>(<span class="hljs-string">&quot;offlineSlimmedPrimaryVertices&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Beamspot-and-PrimaryVertex"><a href="#Beamspot-and-PrimaryVertex" class="headerlink" title="Beamspot and PrimaryVertex"></a>Beamspot and PrimaryVertex</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.cc -&gt;analyze</span><br><span class="hljs-comment">//Beamspot</span><br>Vertex theBeamSpotV;<span class="hljs-comment">//声明一个Vertex类型的对象，表示一个顶点</span><br>BeamSpot beamSpot;<span class="hljs-comment">//声明一个BeamSpot类型的对象，表示束流点</span><br><br>edm::Handle &lt; reco::BeamSpot &gt; beamSpotHandle;<span class="hljs-comment">//在之前的代码中也用到，用于存储束流信息</span><br>iEvent.<span class="hljs-built_in">getByToken</span>(gtbeamspotToken_, beamSpotHandle);<span class="hljs-comment">//提取信息存储在beamSpotHandle中</span><br><span class="hljs-keyword">if</span> (beamSpotHandle.<span class="hljs-built_in">isValid</span>()) &#123;<span class="hljs-comment">//如果beamSpotHandle是有效的则把对应的信息存储起来</span><br>  beamSpot = *beamSpotHandle;<br>  theBeamSpotV = <span class="hljs-built_in">Vertex</span>(beamSpot.<span class="hljs-built_in">position</span>(), beamSpot.<span class="hljs-built_in">covariance3D</span>());<span class="hljs-comment">//用beamSpot的位置信息，和协方差矩阵来初始化theBeamSpotV对象</span><br>&#125; <span class="hljs-keyword">else</span> std::cout &lt;&lt; <span class="hljs-string">&quot;No beam spot available from EventSetup&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-comment">//Beamspot end</span><br><br><span class="hljs-comment">//PrimaryVertex</span><br>Vertex thePrimaryV;<br>math::XYZPoint RefVtx;<span class="hljs-comment">//用于表示三维点或向量，存储PrimaryVertex</span><br><br>edm::Handle &lt; VertexCollection &gt; recVtxs;<br>iEvent.<span class="hljs-built_in">getByToken</span>(gtprimaryVtxToken_, recVtxs);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nVtxTrks = <span class="hljs-number">0</span>;<span class="hljs-comment">//无符号整数即正整数避免负值</span><br><span class="hljs-type">int</span> mynGoodPrimVtx=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> myi=<span class="hljs-number">0</span>;myi&lt;recVtxs-&gt;<span class="hljs-built_in">size</span>();myi++) &#123;<span class="hljs-comment">//遍历所有recVtxs取到的顶点</span><br>  <span class="hljs-keyword">if</span>((*recVtxs)[myi].<span class="hljs-built_in">ndof</span>()&gt;=<span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">fabs</span>((*recVtxs)[myi].<span class="hljs-built_in">z</span>())&lt;=<span class="hljs-number">24</span> &amp;&amp; <span class="hljs-built_in">fabs</span>((*recVtxs)[myi].<span class="hljs-built_in">position</span>().<span class="hljs-built_in">rho</span>())&lt;=<span class="hljs-number">2.0</span>) &#123;<span class="hljs-comment">//顶点条件有ndof自由度，z坐标，rho径向距离</span><br>    mynGoodPrimVtx++;<span class="hljs-comment">//符合条件的为goodPrimaryVertex，计数+1</span><br>  &#125;<br>&#125;<br>nGoodPrimVtx = mynGoodPrimVtx;<span class="hljs-comment">//这个变量记得输出出来</span><br><br><span class="hljs-keyword">if</span> (recVtxs-&gt;<span class="hljs-built_in">begin</span>() != recVtxs-&gt;<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-comment">//检查是否为空</span><br>  <span class="hljs-keyword">if</span> (addXlessPrimaryVertex_ || resolveAmbiguity_) &#123;<span class="hljs-comment">//如果为真，选择第一个顶点为thePrimaryV</span><br>    thePrimaryV = <span class="hljs-built_in">Vertex</span>(*(recVtxs-&gt;<span class="hljs-built_in">begin</span>()));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果不为真，选择轨迹数量最多的顶点为thePrimaryV</span><br>    <span class="hljs-keyword">for</span> (reco::VertexCollection::const_iterator vtx = recVtxs-&gt;<span class="hljs-built_in">begin</span>(); vtx != recVtxs-&gt;<span class="hljs-built_in">end</span>(); ++vtx) &#123;<br>      <span class="hljs-keyword">if</span> (nVtxTrks &lt; vtx-&gt;<span class="hljs-built_in">tracksSize</span>()) &#123;<br>        nVtxTrks = vtx-&gt;<span class="hljs-built_in">tracksSize</span>();<br>        thePrimaryV = <span class="hljs-built_in">Vertex</span>(*vtx);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果为空，用之前的beamspot信息进行初始化</span><br>  thePrimaryV = <span class="hljs-built_in">Vertex</span>(beamSpot.<span class="hljs-built_in">position</span>(), beamSpot.<span class="hljs-built_in">covariance3D</span>());<br>&#125;<span class="hljs-comment">//这一部分确保在顶点重建和物理分析中，有一个合理的主顶点可供使用</span><br><br><span class="hljs-comment">//接下来导出初始顶点的位置信息</span><br>RefVtx = thePrimaryV.<span class="hljs-built_in">position</span>();<br>priVtxX = (thePrimaryV.<span class="hljs-built_in">position</span>().<span class="hljs-built_in">x</span>());<br>priVtxY = (thePrimaryV.<span class="hljs-built_in">position</span>().<span class="hljs-built_in">y</span>());<br>priVtxZ = (thePrimaryV.<span class="hljs-built_in">position</span>().<span class="hljs-built_in">z</span>());<br>priVtxXE = (thePrimaryV.<span class="hljs-built_in">xError</span>());<br>priVtxYE = (thePrimaryV.<span class="hljs-built_in">yError</span>());<br>priVtxZE = (thePrimaryV.<span class="hljs-built_in">zError</span>());<br>priVtxChiNorm = (thePrimaryV.<span class="hljs-built_in">normalizedChi2</span>());<br>priVtxChi = thePrimaryV.<span class="hljs-built_in">chi2</span>();<br>priVtxCL = <span class="hljs-built_in">ChiSquaredProbability</span>((<span class="hljs-type">double</span>) (thePrimaryV.<span class="hljs-built_in">chi2</span>()), (<span class="hljs-type">double</span>) (thePrimaryV.<span class="hljs-built_in">ndof</span>()));<br><span class="hljs-comment">//PrimaryVertex end</span><br></code></pre></td></tr></table></figure><h3 id="Muon-ID-and-Muon-block"><a href="#Muon-ID-and-Muon-block" class="headerlink" title="Muon ID and Muon block"></a>Muon ID and Muon block</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//.cc -&gt;如果之前更复杂的情况你已经完全掌握的话，下面这部分对你来说应该是非常简单的:)</span><br>edm::Handle&lt; edm::View&lt;pat::Muon&gt; &gt; thePATMuonHandle;<span class="hljs-comment">//同样定义handle，然后提取信息</span><br>iEvent.<span class="hljs-built_in">getByToken</span>(gtpatmuonToken_, thePATMuonHandle);<br>edm::View&lt;pat::Muon&gt;::const_iterator iMuonP;<br><span class="hljs-keyword">for</span> (iMuonP = thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(); iMuonP != thePATMuonHandle-&gt;<span class="hljs-built_in">end</span>(); ++iMuonP) &#123;<br>  ++nMu;<span class="hljs-comment">//muon计数器，用于之后的效率计算</span><br>  muIsPatLooseMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isLooseMuon</span>());<br>  muIsPatTightMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isTightMuon</span>(thePrimaryV));<br>  muIsPatSoftMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isSoftMuon</span>(thePrimaryV));<br>  muIsPatMediumMuon-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">isMediumMuon</span>());<br>  muPx-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">px</span>());<br>  muPy-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">py</span>());<br>  muPz-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">pz</span>());<br>  muCharge-&gt;<span class="hljs-built_in">push_back</span>(iMuonP-&gt;<span class="hljs-built_in">charge</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-处理数据"><a href="#7-处理数据" class="headerlink" title="7-处理数据"></a>7-处理数据</h2><p>如果一切顺利的话，你应该会在mumu的质量谱中3Gev附近看到一个很尖的峰，没错这就是你重建出来的$J&#x2F;\psi$粒子！Congratulations！但像这样粗浅的看一眼就说，我找到的的这个峰就是3.0969Gev的$J&#x2F;\psi$峰，很显然是会被丁肇中先生打死的。我们还需要对这些数据点进行拟合，用数学的方式去确定我们找到的峰是什么粒子的衰变函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">TH1F* mumumass = new TH1F(<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-string">&quot;mumumass&quot;</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>);<span class="hljs-comment">//5000为bin的数量</span><br></code></pre></td></tr></table></figure><p>还记得之前我们在myntuple.C文件中定义的名为mumumass一维直方图吗，里面我们设置了他的范围0-25，以及一个5000的bin。这里的bin可以理解为成条形统计图的柱子，这也就意味着我们会损失掉一些精细的数据，比如我们就无法分辨质量为3.000和3.0002的两个mumu，因为他们都会被丢到3.000～3.005这一个bin中，当然如果你的bin足够多也可以称之为“精细”，这也是微积分的方法了。但为什么不直接获取每一个mumu对的质量数值呢！所以，你这里输出的直方图虽说可以用于拟合，但如果想更加自由一点，你需要输出每一个mumu对的质量，这样你就能在你的拟合程序中随心所欲地改变你的bin了！</p><p>输出成txt部分比较简单，直接在myntuple.C中用下面的方式就能输出了，相信你应该能把这两个拼图放在正确的地方了，记得在输出多个变量的时候在两个变量之间加入空格。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">ofstream <span class="hljs-title function_">myoutfile</span><span class="hljs-params">(<span class="hljs-string">&quot;mydata.txt&quot;</span>)</span>;<br>...<br>myoutfile &lt;&lt; <span class="hljs-built_in">std</span>::fixed &lt;&lt; (*mumuonlyMass)[myi] &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>下面正式进行拟合部分，以及如果你对使用的变量有任何疑问我没能包含的，你可以在这个链接中找到解答<a href="https://root.cern.ch/doc/master/group__Roofitmain.html">ROOT: RooFit (cern.ch)</a>（另外我正在写另外一个关于roofit用法的note，waiting… 13D&#x2F;08M&#x2F;24Y）</p><p>比如你可以找到<code>RooRealVar</code>的用法，善用查找功能，你也能成为master! <img src="/postfigure/multilepnote/image-20240813001010193.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TFile.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TH1.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooAbsReal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooRealVar.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooDataHist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooGaussian.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooPlot.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooFitResult.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooChebychev.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooAddPdf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TCanvas.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RooCrystalBall.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;RooFit.h&gt;</span></span><br>using namespace RooFit;<br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fitroot</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//这个需要与你的文件名相同</span><br>    RooRealVar <span class="hljs-title function_">mass</span><span class="hljs-params">(<span class="hljs-string">&quot;mass&quot;</span>, <span class="hljs-string">&quot;Invariant Mass&quot;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">4</span>)</span>;<span class="hljs-comment">//定义变量，是最常用的一个类</span><br>    RooArgSet variables;<br>    variables.add(mass);<span class="hljs-comment">//创建了一个变量集合并在里面添加了mass这个变量</span><br>  <br>    RooDataSet *data = RooDataSet::read(<span class="hljs-string">&quot;./mydata.txt&quot;</span>, variables,<span class="hljs-string">&quot;Q&quot;</span>);<span class="hljs-comment">//读入数据，当你需要多个变量输入的时候，请确保你的变量集的顺序和你在myntuple.C的输出顺序是一致的，也就是说你的变量需要跟你txt文件中每列（以空格分割）相对应</span><br>    mass.setBins(<span class="hljs-number">300</span>);<span class="hljs-comment">//这里并不是对数据分bin，而是对变量分bin，相当于先分好一些空箱子</span><br>    RooDataHist <span class="hljs-title function_">datahist</span> <span class="hljs-params">(<span class="hljs-string">&quot;datahist&quot;</span>, <span class="hljs-string">&quot;binned data&quot;</span>, RooArgSet(mass),*data)</span>;<span class="hljs-comment">//这一步才是把数据分到之前的箱子中</span><br>  <span class="hljs-comment">//下面这些可以忽略</span><br>    <span class="hljs-comment">//TFile *file = TFile::Open(&quot;myhbk.root&quot;);</span><br>    <span class="hljs-comment">//TH1F *hist = (TH1F*)file-&gt;Get(&quot;mumumassSoft&quot;);//这两步是直接从root提取你的直方图</span><br>    <span class="hljs-comment">//TH1F *rebinHist = (TH1F*)hist-&gt;Rebin(2, &quot;rebinHist&quot;);//这个意味着将直方图的两个bin合并为一个</span><br>    <span class="hljs-comment">//RooDataHist data(&quot;data&quot;, &quot;Dataset with mass&quot;, mass,hist);</span><br><span class="hljs-comment">//</span><br>  <br>    RooRealVar <span class="hljs-title function_">c0</span><span class="hljs-params">(<span class="hljs-string">&quot;c0&quot;</span>,<span class="hljs-string">&quot;c0&quot;</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">c1</span><span class="hljs-params">(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">c2</span><span class="hljs-params">(<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">c3</span><span class="hljs-params">(<span class="hljs-string">&quot;c3&quot;</span>,<span class="hljs-string">&quot;c3&quot;</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">-1.</span>,<span class="hljs-number">1.</span>)</span>;<br>    RooChebychev <span class="hljs-title function_">chev</span><span class="hljs-params">(<span class="hljs-string">&quot;chev&quot;</span>,<span class="hljs-string">&quot;chev&quot;</span>,mass,RooArgList(c0,c1,c2,c3))</span>;<span class="hljs-comment">//Chebyshev polynomials</span><br><br>   <br>    RooRealVar <span class="hljs-title function_">psimean</span><span class="hljs-params">(<span class="hljs-string">&quot;psimean&quot;</span>, <span class="hljs-string">&quot;Mean&quot;</span>, <span class="hljs-number">3.1</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">3.3</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">psisigma</span><span class="hljs-params">(<span class="hljs-string">&quot;psisigma&quot;</span>, <span class="hljs-string">&quot;Sigma&quot;</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.1</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">psialpha</span><span class="hljs-params">(<span class="hljs-string">&quot;psialpha&quot;</span>,<span class="hljs-string">&quot;psialpha&quot;</span>,<span class="hljs-number">1.</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">2.0</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">psin</span><span class="hljs-params">(<span class="hljs-string">&quot;psin&quot;</span>,<span class="hljs-string">&quot;psin&quot;</span>,<span class="hljs-number">1.</span>,<span class="hljs-number">0</span>,<span class="hljs-number">15</span>)</span>;<br>    RooCrystalBall <span class="hljs-title function_">psicb</span><span class="hljs-params">(<span class="hljs-string">&quot;psicb&quot;</span>,<span class="hljs-string">&quot;psicb&quot;</span>,mass,psimean,psisigma,psialpha,psin,<span class="hljs-literal">false</span>)</span>;<span class="hljs-comment">//Crystal Ball function</span><br>    <span class="hljs-comment">//RooGaussian psigauss(&quot;psigauss&quot;, &quot;Gaussian PDF&quot;, mass, psimean, psisigma);</span><br><br>    RooRealVar <span class="hljs-title function_">njpsi</span><span class="hljs-params">(<span class="hljs-string">&quot;njpsi&quot;</span>, <span class="hljs-string">&quot;signal fraction&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">10000.</span>)</span>;<br>    RooRealVar <span class="hljs-title function_">nbkg</span><span class="hljs-params">(<span class="hljs-string">&quot;nbkg&quot;</span>, <span class="hljs-string">&quot;background fraction&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">100000.</span>)</span>;<br><br>    RooExtendPdf <span class="hljs-title function_">epsisig</span><span class="hljs-params">(<span class="hljs-string">&quot;esig&quot;</span>, <span class="hljs-string">&quot;esig&quot;</span>, psicb, njpsi)</span>;<br>    RooExtendPdf <span class="hljs-title function_">epsibkg</span><span class="hljs-params">(<span class="hljs-string">&quot;ebkg&quot;</span>, <span class="hljs-string">&quot;ebkg&quot;</span>, chev, nbkg)</span>;<span class="hljs-comment">//这部分有一些知识前提，总之将pdf extend之后可以直接获得成分的数目</span><br><br>    RooAddPdf <span class="hljs-title function_">model</span><span class="hljs-params">(<span class="hljs-string">&quot;fsig&quot;</span>,<span class="hljs-string">&quot;fsig&quot;</span>,RooArgList(epsisig,epsibkg))</span>;<span class="hljs-comment">//model(x) = (njpsi/(njpsi+nbkg))*psicb(x) + (1-(nbkg/(njpsi+nbkg))*bkg(x)</span><br>    RooFitResult* result = model.fitTo(*data, Save());<br>    <span class="hljs-comment">//RooFitResult* result = model.fitTo(datahist, Save());</span><br><br>   <br>    RooPlot* frame = mass.frame();<span class="hljs-comment">//以mass创建一个坐标轴相当于x轴</span><br>    data-&gt;plotOn(frame,MarkerStyle(<span class="hljs-number">20</span>),MarkerSize(<span class="hljs-number">0.4</span>),Name(<span class="hljs-string">&quot;data&quot;</span>));<br>    <span class="hljs-comment">//datahist.plotOn(frame,MarkerStyle(20),MarkerSize(0.4),Name(&quot;data&quot;));</span><br>    model.plotOn(frame,LineColor(<span class="hljs-number">2</span>),LineWidth(<span class="hljs-number">3</span>),Name(<span class="hljs-string">&quot;model&quot;</span>));<br>    model.plotOn(frame,Components(epsisig),LineColor(<span class="hljs-number">7</span>),LineStyle(<span class="hljs-number">1</span>),LineWidth(<span class="hljs-number">3</span>),Name(<span class="hljs-string">&quot;Jpsi&quot;</span>));<br>    model.plotOn(frame,Components(epsibkg),LineColor(<span class="hljs-number">9</span>),LineStyle(<span class="hljs-number">1</span>),LineWidth(<span class="hljs-number">3</span>),Name(<span class="hljs-string">&quot;BKG&quot;</span>));<br>    <span class="hljs-comment">//将对应部分画到这个坐标轴上</span><br>    <br>    TLegend <span class="hljs-title function_">yleg</span><span class="hljs-params">(<span class="hljs-number">0.7</span>,<span class="hljs-number">0.7</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.9</span>)</span>;<span class="hljs-comment">//在一个画布的相对于左下角的(0.7,0.7)位置开始到(0.9,0.9)画出一个矩形</span><br>    yleg.AddEntry(frame-&gt;findObject(<span class="hljs-string">&quot;model&quot;</span>),<span class="hljs-string">&quot;FullModel&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>);<br>    yleg.AddEntry(frame-&gt;findObject(<span class="hljs-string">&quot;Jpsi&quot;</span>),<span class="hljs-string">&quot;Jpsi&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>);<br>    yleg.AddEntry(frame-&gt;findObject(<span class="hljs-string">&quot;BKG&quot;</span>),<span class="hljs-string">&quot;Background&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>);<br>  <span class="hljs-comment">//添加图例</span><br>  <br>    RooPlot *xfpull=mass.frame();<span class="hljs-comment">//画pull分布</span><br>    RooHist *pullx=frame-&gt;pullHist(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;model&quot;</span>);<span class="hljs-comment">//数据点在拟合的model图线上的偏离情况</span><br>    xfpull-&gt;addPlotable(pullx,<span class="hljs-string">&quot;p&quot;</span>);<br>    <span class="hljs-comment">//xfpull-&gt;GetXaxis()-&gt;SetTitle(&quot;J/#psiJ/#psi&quot;);</span><br>    xfpull-&gt;GetXaxis()-&gt;SetTitleSize(<span class="hljs-number">0.15</span>);<br>    xfpull-&gt;GetXaxis()-&gt;SetLabelSize(<span class="hljs-number">0.12</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetTitle(<span class="hljs-string">&quot;Pull&quot;</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetTitleSize(<span class="hljs-number">0.15</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetLabelSize(<span class="hljs-number">0.1</span>);<br>    xfpull-&gt;GetYaxis()-&gt;SetTitleOffset(<span class="hljs-number">0.2</span>);<br>    <br>    TCanvas <span class="hljs-title function_">c</span> <span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;Fit with RooFit&quot;</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>)</span>;<span class="hljs-comment">//创建一个画布</span><br>    c.cd();<br>    TPad <span class="hljs-title function_">pad11</span><span class="hljs-params">(<span class="hljs-string">&quot;pad11&quot;</span>,<span class="hljs-string">&quot;pad11&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1.0</span>)</span>;<span class="hljs-comment">//创建(0,0.3)到(1,1)的范围</span><br>    pad11.SetTopMargin(<span class="hljs-number">0.08</span>);<br>    pad11.SetBottomMargin(<span class="hljs-number">0.017</span>);<br>    pad11.Draw();<br>    pad11.cd();<span class="hljs-comment">//进入这个区域画你想画上去的plot和legend</span><br>    frame-&gt;Draw();<br>    yleg.Draw();<br>    c.cd();<br>    TPad <span class="hljs-title function_">pad12</span><span class="hljs-params">(<span class="hljs-string">&quot;pad12&quot;</span>,<span class="hljs-string">&quot;pad12&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.3</span>)</span>;<br>    pad12.SetTopMargin(<span class="hljs-number">0.03</span>);<br>    pad12.SetBottomMargin(<span class="hljs-number">0.325</span>);<br>    pad12.SetGridx();<br>    pad12.SetGridy(<span class="hljs-number">2</span>);<br>    pad12.Draw();<br>    pad12.cd();<br>    xfpull-&gt;Draw();<br>    c.Update();<br>    c.cd();<br><br>    c.SaveAs(<span class="hljs-string">&quot;fitResult.pdf&quot;</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>不出意外的话，你最终会得到一个很漂亮的拟合图形。或许你会发现了一些较小的峰，他们分别是$\rho,\phi,\psi(2S)$，那么试着在<a href="https://pdg.lbl.gov/">PDG</a>上找到这些粒子的质量，用<code>RooBreitWigner</code>或者<code>RooGaussian</code>函数去拟合这些峰吧！相信你会能得到一个看起来非常棒的结果！</p><p>现在喝杯可乐休息一下吧！后面的内容会更加复杂！</p><h2 id="8-four-muon-拟合"><a href="#8-four-muon-拟合" class="headerlink" title="8-four muon 拟合"></a>8-four muon 拟合</h2><p>p.s. 下面的内容如果直接拷贝可能会出现一些变量没提及或未定义的情况，因为我只会介绍的逻辑，一些细枝末节可能会因为我的粗心未能完全包含，不过，相信你经过之前的练习已经能完全对付这些小问题了！</p><p>在之前的分析中，我们成功的对两个muon进行拟合并得到一些令人兴奋的结果。但我们的征途并不会止步于此，在接下来的章节里我们将研究四个muon，多了一倍的数量的muon带来的是更多的变量和更复杂的筛选，以及一些更有趣的结果！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (thePATMuonHandle-&gt;size()&gt;=<span class="hljs-number">4</span> )&#123;<br>    <span class="hljs-keyword">for</span> (iMuon1 = thePATMuonHandle-&gt;begin();iMuon1 != thePATMuonHandle-&gt;end(); ++iMuon1) &#123;<br>        TrackRef muTrack1 = iMuon1-&gt;track();<br>        <span class="hljs-keyword">if</span> (muTrack1.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>        reco::Track recoMu1 = *iMuon1-&gt;track();<br>        <span class="hljs-keyword">for</span> (iMuon2 = iMuon1 + <span class="hljs-number">1</span>; iMuon2 != thePATMuonHandle-&gt;end(); ++iMuon2) &#123;<br>          TrackRef muTrack2 = iMuon2-&gt;track();<br>          <span class="hljs-keyword">if</span> (muTrack2.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>          reco::Track recoMu2 = *iMuon2-&gt;track();<br>          <span class="hljs-keyword">for</span> (iMuon3 = iMuon2 + <span class="hljs-number">1</span>; iMuon3 != thePATMuonHandle-&gt;end(); ++iMuon3) &#123;<br>            TrackRef muTrack3 = iMuon3-&gt;track();<br>            <span class="hljs-keyword">if</span> (muTrack3.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>            reco::Track recoMu3 = *iMuon3-&gt;track();<br>            <span class="hljs-keyword">for</span> (iMuon4 = iMuon3 + <span class="hljs-number">1</span>; iMuon4 != thePATMuonHandle-&gt;end(); ++iMuon4) &#123;<br>              TrackRef muTrack4 = iMuon4-&gt;track();<br>              <span class="hljs-keyword">if</span> (muTrack4.isNull()) &#123;<span class="hljs-keyword">continue</span>;&#125;<br>              reco::Track recoMu4 = *iMuon4-&gt;track();<br>              <span class="hljs-keyword">if</span> ( (iMuon1-&gt;charge()+iMuon2-&gt;charge()+iMuon3-&gt;charge()+iMuon4-&gt;charge() ) == <span class="hljs-number">0</span> ) &#123;<br></code></pre></td></tr></table></figure><p>循环和之前的类似，通过遍历一个事例中的所有$\mu$来进行后续的配对操作。你可以在此之前添加一个条件<code>if (thePATMuonHandle-&gt;size()&gt;=4)</code>以确保你这个事例中确实是有四个或四个以上的$\mu$的，这样你才能进行后面的操作。同样的，如果我们想重建两个中性粒子的话，需要要求四个$\mu$的电荷加和为零，这样能经过这个条件的$\mu$必定是$\mu^+ \mu^- \mu^+ \mu^-$，但是在程序中我们得到的只是$\mu_1 \mu_2 \mu_3 \mu_4$，不同于两个$\mu$，四个$\mu$就代表着如果两两组合的话，我们就会有三种不同的组合</p><p>$\mu_1 \mu_2,\mu_3 \mu_4$ | $\mu_1 \mu_3, \mu_2 \mu_4$ | $\mu_1 \mu_4, \mu_2 \mu_3$</p><p>而在这三种组合中，再考虑两两组合里的两个$\mu$的电荷之和也应该为0，这样其实最终只有两种组合是正确的，请注意，$\mu_1 \mu_2 \mu_3 \mu_4$的电荷排序并不一定就是$\mu^+ \mu^- \mu^+ \mu^-$，所以不代表 $\mu_1 \mu_3, \mu_2 \mu_4$ 就一定是错误的组合（你需要思考！）那么为了剔除其中错误的组合，你可以选择在myntuple.C进行筛选，也可以在.cc这里就进行筛选。<font color="Red"><strong>前者是我们最后主要的处理方式，这里为了逻辑的连续性我会展示在.cc的处理方式，也为后续更高级的处理方式做一个铺垫。</strong></font></p><p>其实很简单，就是把电荷之和为零的填入到一个二维数组里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ( (iMuon1-&gt;<span class="hljs-built_in">charge</span>()+iMuon2-&gt;<span class="hljs-built_in">charge</span>()+iMuon3-&gt;<span class="hljs-built_in">charge</span>()+iMuon4-&gt;<span class="hljs-built_in">charge</span>() ) == <span class="hljs-number">0</span> ) &#123;<br>  std::vector&lt;std::pair&lt;<span class="hljs-type">const</span> edm::View&lt;pat::Muon&gt;::const_iterator, <span class="hljs-type">const</span> edm::View&lt;pat::Muon&gt;::const_iterator&gt;&gt; muonPairs;<br>  <span class="hljs-keyword">if</span> ((iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon2-&gt;<span class="hljs-built_in">charge</span>()) == <span class="hljs-number">0</span>) &#123;<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon1, iMuon2));<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon3, iMuon4));<br>      &#125;<br>  <span class="hljs-keyword">if</span> ((iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon3-&gt;<span class="hljs-built_in">charge</span>()) == <span class="hljs-number">0</span>) &#123;<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon1, iMuon3));<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon2, iMuon4));<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((iMuon1-&gt;<span class="hljs-built_in">charge</span>() + iMuon4-&gt;<span class="hljs-built_in">charge</span>()) == <span class="hljs-number">0</span>) &#123;<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon1, iMuon4));<br>      muonPairs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(iMuon2, iMuon3));<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; muonPairs.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon1 = muonPairs[i].first;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon2 = muonPairs[i].second;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon3 = muonPairs[i<span class="hljs-number">+1</span>].first;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; muon4 = muonPairs[i<span class="hljs-number">+1</span>].second;<br>    <span class="hljs-comment">//下面的代码和两个muon的部分十分相似，相信你能很容易看懂其中的意义</span><br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonPTT1</span><span class="hljs-params">(muon1-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonMTT2</span><span class="hljs-params">(muon2-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonPTT3</span><span class="hljs-params">(muon3-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    <span class="hljs-function">TransientTrack <span class="hljs-title">muonMTT4</span><span class="hljs-params">(muon4-&gt;track(), &amp;(bFieldHandle))</span></span>;<br>    KinematicParticleFactoryFromTransientTrack pmumuFactory;<br>    ParticleMass muon_mass = myMumass;<br>    <span class="hljs-type">float</span> muon_sigma = myMumasserr;<br>    <span class="hljs-type">float</span> chi = <span class="hljs-number">0.</span>;<br>    <span class="hljs-type">float</span> ndf = <span class="hljs-number">0.</span>;<br>    vector &lt; RefCountedKinematicParticle &gt; muonParticles1;<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonPTT1, muon_mass, chi, ndf, muon_sigma));<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonMTT2, muon_mass, chi, ndf, muon_sigma));<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonPTT3, muon_mass, chi, ndf, muon_sigma));<br>    muonParticles<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(pmumuFactory.<span class="hljs-built_in">particle</span>(muonMTT4, muon_mass, chi, ndf, muon_sigma));<br>    KinematicParticleVertexFitter fitter;<br>    RefCountedKinematicTree psiVertexFitTree1;<br>    psiVertexFitTree1 = fitter.<span class="hljs-built_in">fit</span>(muonParticles1);<br><br>  <span class="hljs-keyword">if</span> (psiVertexFitTree1-&gt;<span class="hljs-built_in">isValid</span>()) &#123;<br>    <span class="hljs-comment">//这里我删去了输出fourmuonmass的部分，直接输出各muon的动量</span><br>    <span class="hljs-comment">//child 的顺序与填入muonParticles1的顺序一致，所以与muon1的排序一致</span><br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheFirstChild</span>();<br>    RefCountedKinematicParticle mu1CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu1KP=  mu1CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheNextChild</span>();<br>    RefCountedKinematicParticle mu2CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu2KP=  mu2CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheNextChild</span>();<br>    RefCountedKinematicParticle mu3CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu3KP=  mu3CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br>    psiVertexFitTree1-&gt;<span class="hljs-built_in">movePointerToTheNextChild</span>();<br>    RefCountedKinematicParticle mu4CandMC = psiVertexFitTree1-&gt;<span class="hljs-built_in">currentParticle</span>();<br>    KinematicParameters myFourMuonMu4KP=  mu4CandMC-&gt;<span class="hljs-built_in">currentState</span>().<span class="hljs-built_in">kinematicParameters</span>();<br><br><span class="hljs-comment">//下面需要输出四个muon的动量，这样我们就能获得这些muon的四动量</span><br>    MyFourMuonMu1Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu1KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu1Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu1KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu1Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu1KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br>    MyFourMuonMu2Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu2KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu2Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu2KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu2Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu2KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br>    MyFourMuonMu3Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu3KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu3Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu3KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu3Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu3KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br>    MyFourMuonMu4Px-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu4KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">x</span>());<br>    MyFourMuonMu4Py-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu4KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">y</span>());<br>    MyFourMuonMu4Pz-&gt;<span class="hljs-built_in">push_back</span>(myFourMuonMu4KP.<span class="hljs-built_in">momentum</span>().<span class="hljs-built_in">z</span>());<br><br>    mumuonlymu1Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon1));<br>    mumuonlymu2Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon2));<br>    mumuonlymu3Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon3));<br>    mumuonlymu4Idx-&gt;<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">distance</span>(thePATMuonHandle-&gt;<span class="hljs-built_in">begin</span>(), muon4));<br></code></pre></td></tr></table></figure><p>如果你不想在.cc中进行这一步筛选，直接把对应<code>muon1</code>替换为<code>iMuon1</code>就好了。但你同时还需要输出对应$\mu$的电荷以便于之后在myntuple.C中进行筛选，在(### Muon ID and Muon block)章节中其实已经对所有的$\mu$按照顺序输出了他们的电荷，那么你就可以用<code>(*muCharge)[(*mumuonlymu1Idx)[myi]]</code>的方式在myntuple.C中获取对应$\mu$的电荷了（这里只是作为提示，请思考这里的myi一个是取哪个变量的<code>size()</code>）</p><p>如此一来在myntuple.C中的处理变得心应手了，请利用下面的提示去获取你的$\mu \mu$组合的质量，这样就能画出两个不变质量谱，甚至可以画出一个二维分布图！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TLorentzVector.h&quot;</span></span><br>TH2F* mumumassJJ = new TH2F(<span class="hljs-string">&quot;mumumassJJ&quot;</span>,<span class="hljs-string">&quot;mumumassJJ&quot;</span>,<span class="hljs-number">60</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.4</span>,<span class="hljs-number">60</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.4</span>);<br>...<br>TLorentzVector Muon1FourVector;<br>Muon1FourVector.SetXYZM((*muPx)[(*MyFourMuonMu1Idx)[myi]], (*muPy)[(*MyFourMuonMu1Idx)[myi]], (*muPz)[(*MyFourMuonMu1Idx)[myi]], muonMass);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;Muon1FourVector.M() &lt;&lt; Muon1FourVector.Pt() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>...<br>mumumassJJ-&gt;Fill(mumumass1, mumumass2);<br></code></pre></td></tr></table></figure><p>但是，however, だがしかし、你或许会发现你的第二对$\mu$的不变质量看起来很奇怪，为什么第一对可以清楚地看到峰，而第二对却不行？下面是我的初步解释，你可以用一些方法验证我说的是否正确</p><blockquote><p>一个事例中的$\mu$子的动量是按动量从大到小进行排序的，第一对的两个$\mu$子往往会得到更大的横动量pt，从而拥有更低的本底，因此要想在第二对$\mu$中看到峰可以对$\mu$的pt进行限制</p></blockquote><p><img src="/postfigure/multilepnote/image-20240911223127881.png" alt="第一对$\mu$子" style="zoom:40%;" /><img src="/postfigure/multilepnote/image-20240911222912057.png" alt="第二对$\mu$子" style="zoom:40%;" /></p><p>然而当对本底进行压低的时候也意味着信号会有相应的损失，因此一个root文件的数据已经不太够了，你需要尝试多run几个文件，在<a href="https://cmsweb.cern.ch/das/request?instance=prod/global&input=file+dataset=/ParkingDoubleMuonLowMass0/Run2023B-22Sep2023-v1/MINIAOD">cms Data Aggregation System </a>中我已经筛选出所需要的root文件，你可以用类似下面的命令下载到你的目录下<br><code>xrdcp -d 1 -f root://xrootd-cms.infn.it//store/data/Run2023B/ParkingDoubleMuonLowMass0/MINIAOD/22Sep2023-v1/2560000/0cb0075f-5308-4849-a0ee-f451012a0c7c.root .</code><br>如果不可以的话请联系我。下载合适数量的文件后（10个左右）在runMultiLepPAT_dataRun3_miniAOD.py中修改inputFiles，拿到数据之后，在myntuple.C中可以设置每个$\mu$子的pt大于1.5或者2应该就能看到峰啦！下图中左边是<code>pt&gt;1.5</code>右边是<code>pt&gt;2</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">ivars.inputFiles=(<br><span class="hljs-string">&#x27;file:f8e93985-e14c-4a8a-b28b-f8cceb3c878e.root&#x27;</span>,//可以通过添加逗号并行多个root文件<br><span class="hljs-string">&#x27;file:847912fd-20d4-4cbe-80bf-3eeade7bcb1f.root&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p><img src="/postfigure/multilepnote/24381725427136_.pic.jpg" alt="pt>1.5" style="zoom:50%;" /><img src="/postfigure/multilepnote/24401725427247_.pic.jpg" alt="pt>2" style="zoom:50%;" /></p><h2 id="9-mass-constraint"><a href="#9-mass-constraint" class="headerlink" title="9-mass constraint"></a>9-mass constraint</h2><p>当你去<a href="https://pdg.lbl.gov/">PDG</a>查询$J&#x2F;\psi$粒子的信息的时候会发现，他的衰变宽度只有0.0000926GeV！而在我们的不变质量谱上，位于3.096GeV的峰的宽度很显然比这个值要大得多，WHY? 事实上这受到探测器的分辨率的影响，按理来说在真实的物理世界中，如果我们能精密测量$\mu$的动量的话，我们重建出来的$J&#x2F;\psi$峰的形状应该像一个$\delta$函数。但我们的探测器做不到这一点，他能测量出来的动量是有误差的，而且因为这个过程是：$\mu$子打在探测器上-&gt;留下电信号的空间位置-&gt;拟合出多个电信号组成轨迹-&gt;根据轨迹半径计算$\mu$的动量。其中的探测器就像是一个一个像素点，如果点亮了就说明$\mu$子来过，这个像素点很显然不能无限精细，这就有了分辨率这一说，就像4K与360P的区别。既然有分辨率导致的不准确，也就会导致$J&#x2F;\psi$质量附近变得“模糊”了（当你摘下眼镜看向月亮，就会看到一坨月亮），那么如何修正这一点呢？我们需要做mass constraint!</p><p>正如其名，我们要将$J&#x2F;\psi$附近的模糊的$\mu \mu$动量通过一些拟合修正，把他们的不变质量重新<strong>约束</strong>到3.096GeV！这里要说明一点的是，并不是所有的粒子都适合做mass constraint，像衰变宽度很大的粒子就不适合，这会改变原有的物理性质。了解了这些之后，让我们开始代码的书写吧！</p><p><strong>Note:</strong> 在此之前，在下面的文件夹内包含相关的文件，.cc是截止到4muon部分的所有代码，你可以把他覆盖掉你原先自己写的.cc，.h是包含所有所需的变量，这些变量即使没用到也没有关系，另外还有一个作为提示的完整代码。这部分重复的结构很多，在理解其中的逻辑之后请仔细确认变量名，be patient！</p><blockquote><p>用下面的路径下的文件吧！<br>&#x2F;afs&#x2F;cern.ch&#x2F;user&#x2F;z&#x2F;zhuf&#x2F;public&#x2F;UserCode&#x2F;massconst<br>—&gt;MuMuEEPat.cc<br>—&gt;MuMuEEPat.h<br>—&gt;MultiLepPAT.cc_hint </p></blockquote><p>新的.cc文件中调整了一些循环结构让整体逻辑更简洁明了</p><blockquote><p>– for iMuonP 这里对所有的$\mu$遍历，输出所有的信息<br>-&gt; raw_muonPx, muonID, Index…</p><p>if Handle-&gt;size()&gt;&#x3D;2: 如果有大于2个的$\mu$的话<br>– for iMuon1 iMuon2<br>-&gt; mumuonly fit_muonPx<br>if Handle-&gt;size()&gt;&#x3D;4: 如果有大于4个的$\mu$的话<br>– for iMuon3 iMuon4<br>    -&gt; fourmuon<br>    -&gt; mass constraint for each pairs <strong>(we are here!)</strong></p></blockquote><p>在之前(### four muon 拟合)我们提到有三种不同的配对组合：</p><p>$\mu_1 \mu_2,\mu_3 \mu_4$ | $\mu_1 \mu_3, \mu_2 \mu_4$ | $\mu_1 \mu_4, \mu_2 \mu_3$</p><p>那么如果我们需要对每对$\mu$重建出来的$J&#x2F;\psi$做mass constraint 的话就需要按照不同的电荷条件重复3次，比如我们先做第一组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(muon1TT.charge()+muon2TT.charge()==<span class="hljs-number">0</span>)  &#123;<br>  muonP12.push_back(pFactory.particle(muon1TT, muon_mass, chi, ndf, muon_sigma));<br>  muonP12.push_back(pFactory.particle(muon2TT, muon_mass, chi, ndf, muon_sigma));<br>  muonP34.push_back(pFactory.particle(muon3TT, muon_mass, chi, ndf, muon_sigma));<br>  muonP34.push_back(pFactory.particle(muon4TT, muon_mass, chi, ndf, muon_sigma));<br>  RefCountedKinematicTree Jpsi1 = kpvFitter.fit(muonP12);<br>  RefCountedKinematicTree Jpsi2 = kpvFitter.fit(muonP34);<br><br>  RefCountedKinematicTree Jpsi1noMCJJ = kpvFitter.fit(muonP12);<br>  RefCountedKinematicTree Jpsi2noMCJJ = kpvFitter.fit(muonP34);<br>  <span class="hljs-keyword">if</span> (Jpsi1-&gt;isValid() &amp;&amp; Jpsi2-&gt;isValid())&#123;<br>    ..........<span class="hljs-comment">//这部分是在分别取两个J/\psi的物理信息，和之前的类似，不做过多解释</span><br><span class="hljs-keyword">if</span>(doJPsiMassCost) &#123;<span class="hljs-comment">//这部分做mass constraint，你可以把这个if去掉不用判断</span><br>      RefCountedKinematicTree Chi1_bTree;<br>      RefCountedKinematicParticle MyChi1_part;<br><br>      <span class="hljs-comment">//JJ assumption</span><br>      jp1 = myJmass;  jp_m_sigma1 = myJmasserr;<br>      jp2 = myJmass;  jp_m_sigma2 = myJmasserr;<br>      jpsi_c1 = new MassKinematicConstraint(jp1,jp_m_sigma1);<br>      jpsi_c2 = new MassKinematicConstraint(jp2,jp_m_sigma2);<span class="hljs-comment">//设置你想constraint的粒子参数</span><br>      try&#123; Jpsi1 = csFitter.fit(jpsi_c1,Jpsi1noMCJJ);&#125; catch (VertexException <span class="hljs-type">const</span>&amp; x) &#123;  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;mu12 vertex exception with mass constrainted to J!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>; &#125;<br>      try&#123; Jpsi2 = csFitter.fit(jpsi_c2,Jpsi2noMCJJ);&#125; catch (VertexException <span class="hljs-type">const</span>&amp; x) &#123;  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;mu34 vertex exception with mass constrainted to J!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>; &#125;<span class="hljs-comment">//尝试将之前的mumu组合constraint到你设置的参数上，并将结果覆盖进Jpsi1中</span><br>      <span class="hljs-keyword">if</span>(Jpsi1-&gt;isEmpty()!=<span class="hljs-literal">true</span> &amp;&amp; Jpsi2-&gt;isEmpty()!=<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//如果JPsi1和JPsi2拟合成功且非空，提取当前粒子并将其添加到Chi_1列表中</span><br>        Jpsi1-&gt;movePointerToTheTop();<br>        Jpsi2-&gt;movePointerToTheTop();<br>        Jpsi1_part = Jpsi1-&gt;currentParticle();<br>        Jpsi2_part = Jpsi2-&gt;currentParticle();<br>        Chi_1.push_back(Jpsi1_part);<br>        Chi_1.push_back(Jpsi2_part); <br>        <span class="hljs-type">bool</span> isagoodfit=<span class="hljs-literal">true</span>;<br>        try&#123;  Chi1_bTree = kpvFitter.fit(Chi_1); &#125; catch (VertexException <span class="hljs-type">const</span>&amp; x) &#123;isagoodfit=<span class="hljs-literal">false</span>;   <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;mu12 and mu34 vertex exception with mu12 and mu34 constrained to JJ&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//相当于先分别对两个muon拟合顶点到J/\psi，再对两个经过mass constraint后的两个J/\psi再进行顶点拟合</span><br>        <span class="hljs-keyword">if</span>(Chi1_bTree-&gt;isValid() &amp;&amp; isagoodfit) &#123;<span class="hljs-comment">//如果拟合成功就提取J/\psi物理信息</span><br>        ...........<span class="hljs-comment">//省略</span><br>        &#125;<br>      &#125;<br>      delete jpsi_c1; delete jpsi_c2;<br>      <span class="hljs-comment">//end JJ assuption</span><br></code></pre></td></tr></table></figure><p>Note: 关于Ctau的定义<br>需要一个洛伦兹不变量表示粒子的寿命。<br>实验室系下：$\tau &#x3D; \gamma \tau_0$；$\tau_0$为粒子的静止寿命 $\gamma&#x3D;\frac{1}{\sqrt{1-\beta^2}},\beta&#x3D;\frac{v}{c}$<br>衰变长度：$L&#x3D;v\tau&#x3D;\gamma \beta c \tau_0$；其中$c\tau_0$就可认为是洛伦兹不变的<br>其中$p&#x3D;\gamma m_0 \beta$，带入可得$c\tau_0 &#x3D;\frac{L}{\gamma\beta}&#x3D; \frac{Lm_0}{p}$<br>指得注意的是，这里的$c\tau_0$是在动量方向和位移方向平行的情况下的，当有呈现一定角度的时候也只有在平行于位移方向上才会有洛伦兹收缩的现象，因此在实际的计算中还需要有一个夹角$cos\alpha$，下面是可以在.h中找到的函数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C">virtual <span class="hljs-type">double</span> <span class="hljs-title function_">GetcTau</span><span class="hljs-params">(RefCountedKinematicVertex&amp; decayVrtx, RefCountedKinematicParticle&amp; kinePart, Vertex&amp; bs)</span><br>  &#123;TVector3 vtx;<br>    TVector3 pvtx;<br>    vtx.SetXYZ((*decayVrtx).position().x(), (*decayVrtx).position().y(), <span class="hljs-number">0</span>);<br>    pvtx.SetXYZ(bs.position().x(), bs.position().y(), <span class="hljs-number">0</span>);<br>    VertexDistanceXY vdistXY;<br>    TVector3 <span class="hljs-title function_">pperp</span><span class="hljs-params">(kinePart-&gt;currentState().globalMomentum().x(),</span><br><span class="hljs-params">   kinePart-&gt;currentState().globalMomentum().y(), <span class="hljs-number">0</span>)</span>;<br>    <br>    TVector3 vdiff = vtx - pvtx;<br>    <span class="hljs-type">double</span> cosAlpha = vdiff.Dot(pperp) / (vdiff.Perp() * pperp.Perp());<br>    Measurement1D distXY = vdistXY.distance(Vertex(*decayVrtx), Vertex(bs));<br>    <span class="hljs-type">double</span> ctauPV = distXY.value() * cosAlpha * kinePart-&gt;currentState().mass() / pperp.Perp();<br>    <span class="hljs-keyword">return</span> ctauPV;    <br>  &#125;<br></code></pre></td></tr></table></figure><p><del>Note: 拟合顶点的步骤<br>顶点拟合的过程也会对$\mu$子原始的Px,Py,Pz进行修正，因此在变量的使用上有raw_Px和fit_Px的区别。<br><code>KinematicParticleVertexFitter</code>创建一个工具<br><code>TransientTrack</code>–.particle-&gt;<code>KinematicParticleFactoryFromTransientTrack</code>–push_back-&gt;<code>vector &lt; RefCountedKinematicParticle &gt;</code>–fitter-&gt;<code>RefCountedKinematicTree</code><br><code>RefCountedKinematicTree-&gt;movePointerToTheFirstChild()</code>–currentParticle()-&gt;<code>RefCountedKinematicParticle</code>–currentState().kinematicParameters()-&gt;<code>KinematicParameters</code></del></p><p>以上对于.cc的内容基本上就结束了。我们查看完整版的代码会发现，里面除了JJ的mass constraint 还有很多其他衰变道的代码，而那些代码之间并无太多区别，在这里就不再重复。然而学习并不会就此终止，.cc中的筛选条件只是一些最最基础的，他最主要的作用还是做一些拟合，和输出对应的物理量，而更细致的筛选则是在myntuple.C中完成的。那么在接下来的章节中我会继续介绍myntuple.C的内容。</p><p>（以上内容完成于13&#x2F;09&#x2F;2024）</p><hr><h2 id="10-myntuple-进阶"><a href="#10-myntuple-进阶" class="headerlink" title="10-myntuple 进阶"></a>10-myntuple 进阶</h2><p><strong>Note:</strong> 以下的任务推荐在清华集群中完成，你可以使用下面路径中的mymultilep.root文件进行<code>MakeClass</code>的操作，生成和编写你的myntuple.C文件</p><blockquote><p>Data path:这里是你可以用的数据文件，你需要在之前完整版的cc找到你需要的变量名<br>&#x2F;home&#x2F;storage0&#x2F;users&#x2F;llchen&#x2F;dataMINI&#x2F;Run3&#x2F;ReReco2023&#x2F;2023B&#x2F;ParkingDoubleMuonLowMass0<br>myntuple_hint:这是所有衰变道的整合文件，里面很乱，选取你需要的部分<br>&#x2F;home&#x2F;storage0&#x2F;users&#x2F;zhufeng&#x2F;formymultilep_learning&#x2F;myntuple.C_hint</p></blockquote><h3 id="数据输入的管理和排序"><a href="#数据输入的管理和排序" class="headerlink" title="数据输入的管理和排序"></a>数据输入的管理和排序</h3><p>在之前的myntuple.C中我们学会了一些简单的画图操作，这很显然不能满足我们日渐增长的筛选需求，并且随着four muon和mass constraint的加入，带来了更多的变量，我们也需要对这些变量进行管理，下面是一个思路：</p><p>在.cc中$\mu$的变量是以四个为一组进行输出的，同样的在.C中我们也会以同样的思路获取，比如一个$\mu$子的charge和fourLorentzVector，就可以把他们四个为一组输入到一个数组里：（下面不是代码，只是作为逻辑展示）</p><blockquote><p>我们可以把$\mu$物理量按照顺序填入到数组里：<br>MuCharge: {charge_mu1,charge_mu2,charge_mu3,charge_mu4}<br>Mu4vect:   {4vect_mu1,  4vect_mu2,  4vect_mu3,  4vect_mu4}</p></blockquote><p>如果所有的变量都按照这个顺序填入到一个对应的数组里的话，那么我们只需要 <strong>变量名+序号</strong> 就能获取对应$\mu$子的物理量了，比如我们想知道第3个$\mu$的Px，那只需要用<code>(MuPx)[2]</code>就能得到了，前提是你创建了<code>MuPx</code>这个数组并按照正确的顺序填入了这个变量。</p><p>既然我们用合适的方式管理了4个$\mu$子的物理量，接下来就是对这4个$\mu$子进行配对了。之前我介绍了用<code>if</code>条件判断电荷相加是否为零的方式来配对他们，如果为零则输出配对之后的两个$\mu$的不变质量，而且也已经知道三种配对方式中只有两对是合适的。在条件很少的情况下这种方式确实能很方便的得到我们想要的东西，但我们需要找到一个公用的标签去筛选和组合这些物理量，上面的管理就是为了这一步做准备的。</p><p>还记得刚刚提到的序号吗，事实上我们如果对序号进行组合和排序的话，这样我们在完成操作之后只需要找需要对应的物理量输出出来就好了！比如：</p><blockquote><p>对序号进行组合：myCombIdx[3] &#x3D; {0,1,2,3}, {0,2,1,3}, {0,3,1,2}，<br>分别对应 $\mu_1 \mu_2,\mu_3 \mu_4$ | $\mu_1 \mu_3, \mu_2 \mu_4$ | $\mu_1 \mu_4, \mu_2 \mu_3$的组合方式</p><p>比如我们想看$\mu_1 \mu_3$ 这个组合是否满足电荷相加为零的条件，如果满足则输出$\mu_1\mu_3$的不变质量：</p></blockquote> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( (MuCharge)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]] + (MuCharge)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>)<br>&#123;( (Mu4vect)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]] + (Mu4vect)[(myCombIdx)[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] ).M()&#125;<br></code></pre></td></tr></table></figure><p>接下来是排序，排序除了想解决规范问题之外，还会有比如在$\Upsilon J&#x2F;\psi$这样的衰变道中，我们需要让第一对的两个$\mu$子的不变质量大于第二对的，这样才比较合理。下面我会介绍对于电荷和质量大小的排序：</p><blockquote><p>首先找出错误的电荷组合，将其放入到myCombIdx[0]序号为零的里面，这样如果我们不想研究带电的态的话就可以只对[1] [2]进行循环了，然后比较两对的不变质量，把较大的放在前面即<code>([0]+[1]).M() &gt; ([2]+[3]).M()</code>,之后将$\mu$子的电荷按照<code>+-+-</code>的顺序排列。实现以上的需求，你需要下面几个交换函数。<img src="/postfigure/multilepnote/image-20240914210956761.png"></p></blockquote><p>除了这些基础的排序，我们还可以根据他们的质量和你想找的粒子的质量的相近程度来排序，这里就会用到$\chi^2$检验。</p><blockquote><p>卡方值$\chi^2$（Chi-Square）<br>卡方值是一种统计量，用于衡量观测值与期望值之间的偏差程度。卡方值越大，观测值与期望值之间的偏差越大。</p></blockquote><p>比如我想研究 $\psi(2S) J&#x2F;\psi$ 这个衰变道可以用$\chi^2$的公式是：</p><blockquote><p>  <font size=5.8> $\chi^2$ &#x3D; $(\frac{M_{1_obs}-M_{\psi(2S)}}{\sigma_{M_1}})^2+(\frac{M_{2_obs}-M_{J&#x2F;\psi}}{\sigma_{M_2}})^2$ </font></p><p>具体的代码中还会为了调整质量误差的影响而在质量误差后乘上一个缩放因子</p></blockquote><p>除了用于排序的函数之外还有一个用于对应$\mu\mu$对的不变质量的函数<code>setFourMuPairsVars</code>，这个函数的作用是，将已经排序的<code>myCombIdx</code>与在cc中进行过拟合的$\mu\mu$对的不变质量对应上。比如排序完成后的<code>myCombIdx[1]</code>为{3,1,4,2}，那么我输出的<code>myFourMuVars[3][2]</code>的数组中<code>myFourMuVars[1][0]=(*MyJpsi3Var_Mu13)[fourMuIdx] myFourMuVars[1][1] = (*MyJpsi4Var_Mu24)[fourMuIdx]</code></p><h3 id="结果输出的命名与自动化"><a href="#结果输出的命名与自动化" class="headerlink" title="结果输出的命名与自动化"></a>结果输出的命名与自动化</h3><blockquote><p>你可以修改下面三个地方自定义输出的root文件名，这样你就可以通过脚本程序生成多个Runjobs.C同时运行，并且会输出为不同文件，最后再用<code>hadd</code>将这些文件合成为一份就可以了</p><p>脚本可以参考&#x2F;home&#x2F;storage0&#x2F;users&#x2F;zhufeng&#x2F;formymultilep_learning&#x2F;shell&#x2F;</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//.C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myntuple::Loop</span><span class="hljs-params">(TString outputname)</span>&#123;<br>.....<br>TString myroot = outputname + <span class="hljs-string">&quot;_zhuf.root&quot;</span>;<br>TFile* myhbk = new TFile (myroot,<span class="hljs-string">&quot;recreate&quot;</span>);<br><br><span class="hljs-comment">//.h</span><br>virtual <span class="hljs-type">void</span>     <span class="hljs-title function_">Loop</span><span class="hljs-params">(TString outputname)</span>;<br><br><span class="hljs-comment">//Runjobs</span><br>a.Loop(<span class="hljs-string">&quot;youroutputdir/youroutputname&quot;</span>);<br></code></pre></td></tr></table></figure><p>了解这一步之前，我们首先要了解myntuple.C myntuple.h 和 Runjobs.C之间的关系。当你用<code>MakeClass</code>去创建一个新的myntuple.C的时候，大部分的成员函数已经创建完成了，像<code>GetEntry</code>这样的，这些函数的功能比较单一，所以都会放在.h文件中，而其中有一个<code> virtual void     Loop();</code>这一<code>Loop</code>成员函数是我们主要需要编写的函数。如果我们编译之后得到的myntuple_C.so文件就能在 Runjobs.C 中加载使用了（下面代码中路径有点长省略了一部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Runjobs</span><span class="hljs-params">()</span><br>&#123;<br>  gSystem-&gt;Load(<span class="hljs-string">&quot;myntuple_C.so&quot;</span>);<span class="hljs-comment">//加载库</span><br>  TChain * chain = new TChain(<span class="hljs-string">&quot;/mkcands/X_data&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//创建TChain，用于处理多个TTree对象</span><br>  chain-&gt;Add(<span class="hljs-string">&quot;..MuOnia/ReReco2016/FILE/mymultilep_*Number.root&quot;</span>);<span class="hljs-comment">//将路径中的root文件加载进TChain中，TChain就包含了所有的TTree的信息</span><br>  myntuple <span class="hljs-title function_">a</span><span class="hljs-params">(chain)</span>;<span class="hljs-comment">//使用chain 创建一个 myntuple 类的实例 a</span><br>  a.Loop();<span class="hljs-comment">//调用 myntuple 类的 Loop 方法，处理 TChain 中的数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现我们在Runjobs中只会调用<code>Loop</code>函数所以我们在这个函数里面增加一个<code>string</code>变量就能在函数里面使用了，并将这个<code>string</code>运用在输出文件的命名中就大功告成了！</p><h2 id="end-some-tricks-need-to-test"><a href="#end-some-tricks-need-to-test" class="headerlink" title="end-some tricks need to test"></a>end-some tricks need to test</h2><p>由于在添加一个新的branch的时候，总是有一些重复的工作，而且对于大量的变量的加入也会导致工作量的增加以及代码的简洁性，下面的一些工具能让你的添加branch部分变得十分简洁易读。你只需要把他们放在对应的地方就能在主函数中使用<code>CREATE_BRANCHES(nGoodPrimVtx,muPx,muPy,muPz);</code>和<code>CLEAR_VARIABLES(nGoodPrimVtx,muPx,muPy,muPz);</code>这样的命令进行批量地创建和清理了。不过这个功能还在测试中，可能会出现意想不到的错误，如果你发现了错误，还请<a href="mailto:feng.zhu@cern.ch">联系我</a>进行修改!（update:08m&#x2F;12d 下面的这些大概率不能work，如果你有类似的可行方法也请联系我）</p>]]></content>
    
    
    
    <tags>
      
      <tag>multilep</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux learning note</title>
    <link href="/2024/10/11/linux/"/>
    <url>/2024/10/11/linux/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.runoob.com/linux/linux-file-content-manage.html">Linux | 菜鸟教程 (runoob.com)</a> 推荐这个作为入门</p><p>linux命令行与shell脚本编程大全</p></blockquote><h1 id="linux-基础"><a href="#linux-基础" class="headerlink" title="linux 基础"></a>linux 基础</h1><h2 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h2><h3 id="1-ls-list"><a href="#1-ls-list" class="headerlink" title="1 ls list"></a>1 <strong>ls</strong> list</h3><p><code>command [-options] parameter ...</code><br>对于选项通常会带‘-’号，-h，有时也会用‘–’使用完整全名，–help</p><p><code>ls -l</code> 显示详情信息<br><code>ls -a</code> 显示隐藏文件<br><code>ls -R</code> 显示子目录文件<br><code>ls -F</code> 显示文件类型<br>-F选项会在目录名之后添加正斜线（&#x2F;），以方便用户在输出中分辨。类似地，它还会在可执行文件（比如上面的my_script文件）之后添加星号（*），以帮助用户找出可在系统中运行的文件<br><code>ls -i</code> 显示文件inode编码</p><p><strong>通配符</strong></p><p><code>ls -l t?st</code> 替代一个字符<br><code>ls -l t*st</code> 替代多个字符<br><code>ls -l t[abc]st</code> 用abc替代<br><code>ls -l t[a-c]st</code> 用a到c替代<br><code>ls -l t[!d]st</code> 用除了d替代<br>pwd print working directory<br><code>pwd -P</code> 如果你在一个链接文件夹内，单纯的pwd会出现错误的位置，加个-P选项就会获得正确的路径了</p><h3 id="2-处理文件"><a href="#2-处理文件" class="headerlink" title="2 处理文件"></a>2 处理文件</h3><p><code>touch test</code> 创建一个空文件<br><code>rm -f</code>强制删除<br><code>cp -R Document/ NewDocument/</code> 在执行cp –R命令之前，目录NewDocuments并不存在。它是随着cp –R命令被创建的，整个Documents目录中的内容都被复制到其中。<br><font color="Chocolate"><strong><code>ln -s file slink_file</code> 创建软链接，相当于快捷方式</strong></font><br><code>cp -i file1 file2</code> <strong>-i</strong>的选项是在执行操作时问询<br>例如：<code>rm -i</code><br><code>mv -i</code></p><p><code>mkdir -p /path/to/new/dir</code> 根据需要创建缺失的父目录 即如果你只有&#x2F;path，这个命令会自动创建&#x2F;path&#x2F;to，&#x2F;path&#x2F;to&#x2F;new，path&#x2F;to&#x2F;new&#x2F;dir文件夹</p><h3 id="3-查看文件内容"><a href="#3-查看文件内容" class="headerlink" title="3 查看文件内容"></a>3 查看文件内容</h3><p><code>file .bashrc</code>查看文件类型甚至是软链接的位置<br><code>cat -n file </code>查看文本并加上行数<br><code>less file</code> 查看大段文本<br><code>tail -n 5 file </code>or<code>tail -5 file </code>查看最后5行<br><code>head -n 5 file </code>or<code>head -5 file </code>查看开始5行<br><code>tail -f file</code> 该选项允许你在其他进程使用此文件时查看文件的内容。tail命令会保持活动状态并持续地显示添加到文件中的内容。这是实时监测系统日志的绝佳方式。</p><hr><h2 id="二、数据管理"><a href="#二、数据管理" class="headerlink" title="二、数据管理"></a>二、数据管理</h2><h3 id="1-数据排序"><a href="#1-数据排序" class="headerlink" title="1 数据排序"></a>1 数据排序</h3><p><code>sort file</code>默认情况下，sort命令会依据会话所指定的默认语言的排序规则来对文本文件中的数据行进行排序<br><code>sort -n file</code> 将数字按值排序升序<br><code>sort -nr file</code> 将数字按值排序逆序<br><code>sort -M file</code> 含有时间戳日期的文件按默认的排序方法来排序  </p><h3 id="2数据搜索"><a href="#2数据搜索" class="headerlink" title="2数据搜索"></a>2数据搜索</h3><p><code>grep [options] pattern [file]</code>grep命令输出了匹配该模式的整行<br><code>grep -v t file</code> 输出不包含t的行<br><code>grep -n t file</code> 输出包含t的行及行号<br><code>grep -c t file</code> 输出包含t的行数<br><code>grep -e t -e r file</code> 输出包含t和r的行  </p><h3 id="3命令别名"><a href="#3命令别名" class="headerlink" title="3命令别名"></a>3命令别名</h3><p><code>alias -p</code> 查看能使用的别名<br><code>alias li=&#39;ls -i --color=auto&#39;</code> 创建别名并使用色彩自动编码<br><code>unalias li</code> 删除别名 如果被删除的别名不是你设置的，那么等下次重新登录系统的时候，该别名就会再次出现。可以通过修改环境文件永久地删除某个别名。  </p><p><font color="Chocolate"><em>这个在.bashrc文件中修改后，可以在每次启动终端的时候就运行命令，从而不用每次都要重新命名别名，在输入登录命令这种很长而且不用修改的命令的时候，指定一个别名会是一个优雅的操作</em></font></p><hr><h2 id="三、环境变量"><a href="#三、环境变量" class="headerlink" title="三、环境变量"></a>三、环境变量</h2><h3 id="设定变量"><a href="#设定变量" class="headerlink" title="设定变量"></a>设定变量</h3><p>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部环境变量则只对创建它的shell可见。</p><ul><li>设置局部变量<br><code>my_variable=&quot;Hello World&quot;</code> 在变量名、等号和值之间没有空格</li><li>设置全局变量<br><code>export my_variable=&quot;Hello World&quot;</code> export命令使其变成了全局环境变量。<br>这个可以作为在多个脚本之间变量的交换，在大型脚本中或许很有用</li></ul><p>-删除环境变量<br><code>unset my_variable</code> </p><hr><h2 id="四、构建基础脚本"><a href="#四、构建基础脚本" class="headerlink" title="四、构建基础脚本"></a>四、构建基础脚本</h2><p>让两个命令一起运行，可以将其放在同一行用分号隔开<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash </span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;0..8&#125;; <span class="hljs-keyword">do</span> <span class="hljs-built_in">cd</span> condor_prime1v2_<span class="hljs-variable">$&#123;i&#125;</span>; <span class="hljs-built_in">source</span> SplitAndRun.sh; <span class="hljs-built_in">cd</span> ..; <span class="hljs-keyword">done</span> <br></code></pre></td></tr></table></figure><h3 id="1-echo命令"><a href="#1-echo命令" class="headerlink" title="1 echo命令"></a>1 <strong>echo命令</strong></h3><ul><li>在默认情况下，无须使用引号将要显示的字符串划定出来<br><code>echo this is a test</code></li><li>echo命令可用单引号或双引号来划定字符串 <code>echo &quot;this&#39;s a test&quot;</code><br><code>echo -n</code> 字符串和命令输出显示在同一行中，即不换行</li></ul><h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2 自定义变量"></a>2 <strong>自定义变量</strong></h3><ul><li>变量名区分大小写  </li><li>使用等号为变量赋值。<strong>在变量、等号和值之间不能出现空格<code>a=1; str=&quot;test&quot;</code></strong></li></ul><h3 id="3-命令替换"><a href="#3-命令替换" class="headerlink" title="3 命令替换"></a>3 <strong>命令替换</strong></h3><p>从命令输出中提取信息并将其赋给变量 </p><ul><li>反引号(&#96;) <em>这个可以显示自己是个高手，但更推荐用下面那个，因为与其他变量命名格式类似</em></li><li>$()格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">today=$(<span class="hljs-built_in">date</span> +%y%m%d) <span class="hljs-comment">#会以两位数输出日期240116</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">log</span> &gt; <span class="hljs-built_in">log</span>.<span class="hljs-variable">$today</span><br></code></pre></td></tr></table></figure><p><em>Tips</em><br><code>yy</code>复制一行<br><code>p</code>粘贴一行<br><code>u</code>撤销上次操作<br><code>.</code>重复上次操作<br><code>/test</code>搜索test<br><code>:</code>末行模式，可以进行更多的操作<br><code>:1</code>定位到第一行<br><code>:$</code>定位到最后一行<br><code>:.,.+5w test.tst</code>当前行到之后的五行输出为test.txt</p><h3 id="4-数学运算"><a href="#4-数学运算" class="headerlink" title="4 数学运算"></a>4 <strong>数学运算</strong></h3><p>用方括号将数学运算的结果赋予变量<code>a=$[(1+1)*2]</code>  但bash shell只支持整数运算<br><em>浮点计算</em></p><ul><li>bc计算器<br>通过<code>bc</code>访问bash计算器，通过<code>quit</code>退出计算器  </li><li>在脚本中使用bc<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=4; 3.4 / 5&quot;</span> | bc) <span class="hljs-comment">#scale设置为4为小数</span><br></code></pre></td></tr></table></figure></li><li><strong>双括号(())</strong> 双括号里面的语句可以使用高级的数学表达式，并且不用转义大于号之类的 &gt; <ul><li><em>我觉得一般情况下可以无脑用双括号，浮点数用bc就行</em></li></ul></li></ul><p><strong>退出状态码</strong><br><code>echo $?</code> 保存最后一个已执行命令的退出状态码,无报错状态码为0  </p><hr><h2 id="五、结构化命令"><a href="#五、结构化命令" class="headerlink" title="五、结构化命令"></a>五、结构化命令</h2><h3 id="1-if-then"><a href="#1-if-then" class="headerlink" title="1 if-then"></a>1 if-then</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span> <span class="hljs-comment">#如果if语句行命令的退出状态值为0</span><br><span class="hljs-keyword">then</span> <br>commands <span class="hljs-comment">#那么代码块中的命会被执行</span><br><span class="hljs-keyword">else</span> <br>commands <span class="hljs-comment">#否则，会执行else部分</span><br><span class="hljs-keyword">fi</span> <br><span class="hljs-comment">#嵌套结构</span><br><span class="hljs-keyword">if</span> command1 <span class="hljs-keyword">then</span> <br>commands <span class="hljs-keyword">elif</span> command2 <span class="hljs-keyword">then</span><br>commands <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>数值比较</strong><br><em>用到方括号的语句不多，基本上除了条件判断时用到，其他都用圆括号</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$n1</span> -gt <span class="hljs-variable">$n2</span> ] <br><span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$n1</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$n2</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">condition</th><th align="center">describe</th></tr></thead><tbody><tr><td align="center">n1 -eq n2</td><td align="center">n1 &#x3D; n2</td></tr><tr><td align="center">n1 -ge n2</td><td align="center">n1 &gt;&#x3D; n2</td></tr><tr><td align="center">n1 -gt n2</td><td align="center">n1 &gt; n2</td></tr><tr><td align="center">n1 -le n2</td><td align="center">n1 &lt;&#x3D; n2</td></tr><tr><td align="center">n1 -lt n2</td><td align="center">n1 &lt; n2</td></tr><tr><td align="center">n1 -ne n2</td><td align="center">n1 !&#x3D; n2</td></tr></tbody></table></li><li><p><strong>字符串比较</strong></p></li></ul><table><thead><tr><th align="center">condition</th><th align="center">describe</th></tr></thead><tbody><tr><td align="center">str1 &#x3D; str2</td><td align="center">str1与str2是否一致</td></tr><tr><td align="center">str1 !&#x3D; str2</td><td align="center">str1与str2是否不一致</td></tr><tr><td align="center">str1 &lt; str2</td><td align="center">**</td></tr><tr><td align="center">str1 &gt; str2</td><td align="center">**</td></tr><tr><td align="center">-n str1</td><td align="center">检查str1的长度是否不为0</td></tr><tr><td align="center">-z str1</td><td align="center">检查str1的长度是否为0</td></tr></tbody></table><ul><li><p><em>一个字符串是否大于或小于另一个字符串</em>  </p><ul><li>大于号和小于号必须<strong>转义</strong><code>str1 \&gt; str2</code>，否则shell会将其视为重定向符  </li><li>大小比较的是字符的Unicode的编码值   </li><li>大于和小于顺序与sort命令所采用的不同</li></ul></li><li><p><strong>布尔运算符号</strong><br>&amp;&amp; and<br>|| or</p></li></ul><p> <strong>高级应用</strong>  </p><ul><li><strong>双括号(())</strong> 双括号里面的语句可以使用高级的数学表达式，并且不用转义大于号之类的 &gt;</li><li><strong>case命令</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">read</span> choice <br><span class="hljs-keyword">case</span> <span class="hljs-variable">$choice</span> <span class="hljs-keyword">in</span><br>    a)<br>    <span class="hljs-built_in">command</span><br>    ;;<br>    b)<br>    <span class="hljs-built_in">command</span><br>    ;;<br>    *)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;no choice&quot;</span><br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-for"><a href="#2-for" class="headerlink" title="2 for"></a>2 for</h3><ul><li>for a in <em>list</em>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">list=abc <span class="hljs-string">&quot;ab&#x27;c&quot;</span> <span class="hljs-string">&quot;ab c&quot;</span> <br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> abc <span class="hljs-string">&quot;ab&#x27;c&quot;</span> <span class="hljs-string">&quot;ab c&quot;</span><br><span class="hljs-keyword">do</span> <br>  <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br>file=<span class="hljs-string">&quot;list.txt&quot;</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> <span class="hljs-variable">$file</span>) <span class="hljs-comment">#会依据特定的字段分隔符遍历，分隔符：空格、制表符、换行符</span><br>IFS=$<span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment">#可以指定换行符为分隔符，这样就能跳过字段中的空格和制表符</span><br>IFS=$<span class="hljs-string">&#x27;\n:&#x27;</span> <span class="hljs-comment">#这样就指定换行符与冒号作为字段分隔符</span><br></code></pre></td></tr></table></figure></li><li>for a in <em>range</em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> ((a=<span class="hljs-number">1</span>,b=<span class="hljs-number">10</span>;a&lt;=<span class="hljs-number">10</span>;a++.b--)) <span class="hljs-comment">#仿c语言的shell命令</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="3-while与until"><a href="#3-while与until" class="headerlink" title="3 while与until"></a>3 <code>while</code>与<code>until</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=3<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span> <span class="hljs-comment">#这里只是展示可以放在while里面</span><br>  [ <span class="hljs-variable">$a</span> -ge 0 ] <span class="hljs-comment">#这里需要与方括号空一格</span><br><span class="hljs-keyword">do</span><br>  a=$[<span class="hljs-variable">$a</span>-1] <span class="hljs-comment">#这里赋值时不能空格，但可以与方括号空一格，或者按照之前说的惯例用圆括号赋值，这样方便记忆一点 a=$(($a-1))</span><br><span class="hljs-keyword">done</span><br><span class="hljs-keyword">until</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span> <br>  [ <span class="hljs-variable">$a</span> -eq 0 ]<br><span class="hljs-keyword">do</span><br>  a=$[<span class="hljs-variable">$a</span>-1]<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-break-and-continue"><a href="#4-break-and-continue" class="headerlink" title="4 break and continue"></a>4 <code>break</code> and <code>continue</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> ((a=<span class="hljs-number">1</span>;a&lt;<span class="hljs-number">4</span>;a++))<br><span class="hljs-keyword">do</span> <br>  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -eq 2 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">continue</span> <span class="hljs-comment">#continue会中止这次循环，从头开始</span><br>  <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">for</span> ((b=<span class="hljs-number">1</span>;b&lt;<span class="hljs-number">4</span>;b++))<br>  <span class="hljs-keyword">do</span> <br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$b</span> -eq 2 ]; <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">break</span> 2 <span class="hljs-comment">#默认下break只会终止一层循环，后面加数字2意味着终止向外的第二层循环</span><br>    <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span> &gt; test.txt <span class="hljs-comment">#你可以将循环结果输出到一个文件内，或用管道传给其他命令如：done | sort 即将输出进行排序</span><br></code></pre></td></tr></table></figure><h3 id="5-read"><a href="#5-read" class="headerlink" title="5 read"></a>5 <code>read</code></h3><p><code>echo -n</code> 字符串和命令输出显示在同一行中，即不换行<br><code>read -p</code> 可以指定提示字符<br><code>read -t 5</code> 当时间超过5s没有输入就会返回非0退出状态码<br><code>read -n 1</code> 统计输入的字符数为1时自动退出并赋值<br><code>read -s</code> 不会显示输入的数据，用于密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;enter your name:&quot;</span><br><span class="hljs-built_in">read</span> name<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;enter your name:&quot;</span> first last <span class="hljs-comment">#两个方式一样，但这种方式能分配多个变量</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">read</span> -t 5 -p <span class="hljs-string">&quot;enter your name:&quot;</span> first last<br><span class="hljs-keyword">then</span> <br><span class="hljs-keyword">else</span> <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;time out&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">read</span> -n 1 -p <span class="hljs-string">&quot;enter y/n&quot;</span> chose<br></code></pre></td></tr></table></figure><hr><h2 id="六-输出与输入"><a href="#六-输出与输入" class="headerlink" title="六.输出与输入"></a>六.输出与输入</h2><p>一个命令会将输出显示在终端显示器上，正确的输出会指向STDOUT文件，错误的输出会指向STDERR文件  </p><ul><li>标准文件描述符<br>0 标准输入 1 标准输出 2 标准错误<br><code>ls file1 file2 file3 1&gt;out 2&gt;err</code> 1指向正确的输出，2指向错误的输出 不指定的话正确与错误都会输出到终端上<br><code>ls file1 file2 file3 &amp;&gt;both</code> &amp;会输出二者</li><li>重定向输出<br>如果你有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。这只需要使用输出重定向符号将输出重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符索引值之前加一个&amp;：<br><code>echo &quot;This is an error message&quot; &gt;&amp;2</code></li><li>exec命令<br>exec命令会启动一个新shell并将STDOUT文件描述符重定向到指定文件，例如 <code>exec 2&gt;error</code><br><code>exec 0&lt;inputfile</code> 这让脚本可以在文件testfile中而不是键盘上获取输入，之前的read命令就是从STDIN读取数据0，即通过键盘输入的数据，这里将0重定向为inputfile就意味着会从这里读取数据。<br><code>exec 3&gt;file3out</code> 你可以自定义一个描述符 这样在之后就能让你想要输出的输出到3这个符号内<code>echo &quot;This should be stored in a file&quot; &gt;&amp;3</code>可以维持显示器的正常输出，并将特定信息重定向到指定文件（比如日志文件）  </li><li>神奇的小功能  <ul><li><p><code>/dev/null</code>就像是一个垃圾桶<br><code>echo &quot;This is an error message&quot; &gt; /dev/null</code>这样就能丢弃这个数据<br><code>cat /dev/null &gt; testfile</code> 这样就能直接清除文件内容，而不需要重新创建</p></li><li><p><code>mktemp testfile.XXXXXX</code>会任意填入字符并创建<em>文件</em><br><code>mktemp -t testfile.XXXXXX</code> 会在系统的临时目录&#x2F;tmp&#x2F;test.XXXXXX创建文件<br><code>mktemp -d testdir.XXXXXX</code>会任意填入字符并创建<em>文件夹</em></p></li><li><p><code>tee test</code>像是一个T转接口<br><code>data | tee test</code>这样会同时输出到屏幕上和test文件内(&gt;test)<br><code>data | tee -a test</code>不会覆盖test(&gt;&gt;test)</p></li></ul></li></ul><hr><h2 id="七、脚本运行"><a href="#七、脚本运行" class="headerlink" title="七、脚本运行"></a>七、脚本运行</h2><h3 id="1-系统信号与产生"><a href="#1-系统信号与产生" class="headerlink" title="1 系统信号与产生"></a>1 系统信号与产生</h3><table><thead><tr><th align="center">sig</th><th align="center">value</th><th align="center">mean</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIGHUP</td><td align="center">挂起</td></tr><tr><td align="center">2</td><td align="center">SIGINT</td><td align="center">中断 -&gt; Ctrl+C</td></tr><tr><td align="center">3</td><td align="center">SIGQUIT</td><td align="center">停止</td></tr><tr><td align="center">9</td><td align="center">SIGKILL</td><td align="center">无条件终止  -&gt; kill -9 PID</td></tr><tr><td align="center">20</td><td align="center">SIGTSTP</td><td align="center">停止或暂停但不终止 -&gt; Ctrl+Z</td></tr></tbody></table><ul><li>trap命令 trap <em>command</em> <em>signals</em><br><code>trap &quot;echo &#39;trapped Ctrl+C&#39;&quot; SIGINT</code> 输入Ctrl+C并不会停止脚本而是执行echo命令，这样可以防止命令被打断</li></ul><h3 id="2-脚本后台运行"><a href="#2-脚本后台运行" class="headerlink" title="2 脚本后台运行"></a>2 脚本后台运行</h3><p><code>&amp;</code>在一条命令后面加&amp;就能使命令后台运行，并通过对1，2的重定向，使终端不显示信息而达到完全静默<br><code>ps</code>可以查看目前的作业信息<br><code>jobs</code>更推荐jobs命令查看作业情况并有一些命令行选项<br>  <code>-l PID</code> | <code>-r running</code> | <code>-s stopped</code><br><em>Tips: jobs命令输出中的加号和减号。带有加号的作业为默认作业。如果作业控制命令没有指定作业号，则引用的就是该作业。<br>带有减号的作业会在默认作业结束之后成为下一个默认作业。任何时候，不管shell中运行着多少作业，带加号的作业只能有一个，带减号的作业也只能有一个。</em></p><hr><h2 id="八、高级脚本"><a href="#八、高级脚本" class="headerlink" title="八、高级脚本"></a>八、高级脚本</h2><ul><li>函数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> func1 &#123; <span class="hljs-comment">#定义一个函数</span><br>  <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;enter your number:&quot;</span> a<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> *2&quot;</span> |bc<br>&#125;<br>func1 <span class="hljs-comment">#直接调用func1</span><br>result=$(func1) <span class="hljs-comment">#将函数结果输出给$result</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\nyour result is <span class="hljs-variable">$result</span>&quot;</span> <span class="hljs-comment">#-e 为转义选项，转义\n</span><br><br><span class="hljs-keyword">function</span> func2 &#123;<br>  <span class="hljs-comment">#local result=$(echo &quot;$1 * $2&quot; |bc) #local保证了变量只在函数中有效，函数之外的同名变量互不影响</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span>&quot;</span> |bc<br>&#125;<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 2 ]; <span class="hljs-keyword">then</span>   <span class="hljs-comment">#`$#` 用于获取参数的个数</span><br>  result=$(func2 <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span>) <span class="hljs-comment">#你需要手动输入 例如：source test.sh 1.1 2</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;your result is <span class="hljs-variable">$result</span>&quot;</span> <br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;error&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure></li><li>数组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#输入数组</span><br><span class="hljs-keyword">function</span> func3 &#123;<br>  <span class="hljs-built_in">local</span> myarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)) <span class="hljs-comment">#`$@` 用于展开参数列表</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myarray[*]&#125;</span> <span class="hljs-comment">#表示将数组的所有元素作为单个参数展开，元素之间用第一个字符IFS的值分隔</span><br>&#125;<br>array=(1 2 3 4 5)<br><span class="hljs-comment">#array=(&quot;apple&quot; &quot;banana&quot; &quot;cat&quot;)</span><br>func3 <span class="hljs-variable">$&#123;array[*]&#125;</span><br><br><span class="hljs-comment">#输出数组</span><br><span class="hljs-keyword">function</span> func4 &#123;<br>  <span class="hljs-built_in">local</span> n=(<span class="hljs-variable">$#</span>)<br>  <span class="hljs-built_in">local</span> myarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>))<br>  <span class="hljs-built_in">local</span> newarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)) <span class="hljs-comment">#这里可能是想产生一个与myarray同样多数组的newarray，这样在之后的填入中才能做到依次替换</span><br>  <span class="hljs-keyword">for</span> (( i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-variable">$n</span>; i++))&#123;<br>    newarray[<span class="hljs-variable">$i</span>]=$((<span class="hljs-variable">$&#123;myarray[$i]&#125;</span> * <span class="hljs-number">2</span>))<br>  &#125;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;newarray[*]&#125;</span><br>&#125;<br>array=(1 2 3 4 5)<br>func4 <span class="hljs-variable">$&#123;array[*]&#125;</span><br></code></pre></td></tr></table></figure></li><li>递归<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> func5 &#123;<br>  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -eq 1 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">local</span> x=$(( <span class="hljs-variable">$1</span> - <span class="hljs-number">1</span> ))  <span class="hljs-comment">#得到n-1</span><br>    <span class="hljs-built_in">local</span> result=$(func5 <span class="hljs-variable">$x</span>)<br>    <span class="hljs-built_in">echo</span> $((<span class="hljs-variable">$result</span> * <span class="hljs-variable">$1</span>)) <span class="hljs-comment">#</span><br>  <span class="hljs-keyword">fi</span><br>&#125;<br><span class="hljs-built_in">read</span> a<br><span class="hljs-built_in">echo</span> $(func5 <span class="hljs-variable">$a</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="九、sed-命令"><a href="#九、sed-命令" class="headerlink" title="九、sed 命令"></a>九、sed 命令</h2><p><font color="Chocolate"><em>需要注意的是，sed命令不会修改原始文件，只是在终端中的输出发生变化，你可以用重定向来输出sed修改后的文件或者用 -i 选项直接修改文件内容</em></font></p><ul><li><p>用于批量修改文本<br><code>sed &#39;s/old/new/&#39; test.txt</code>  s为替换命令<br><code>sed -e &#39;s/old1/new1/; s/old2/new2/&#39; test.txt</code>  多个修改，注意分号和单引号<br><code>sed -f txt.sed test.txt</code> 将<code>s/old1/new1/</code>放进txt.sed中，用-f选项可以进行大量修改<br><code>sed &#39;d&#39; test.txt</code> d为删除命令 <font color="red"><em>慎用</em> </font><br><code>sed &#39;i\指定文本&#39;</code>与<code>sed &#39;a\指定文本&#39;</code>分别在指定行前和指定行后增加一行内容  </p></li><li><p>命令组  <em>如果需要在单行中执行多条命令，可以用花括号将其组合在一起</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -n <span class="hljs-string">&#x27;/test/&#123;            </span><br><span class="hljs-string">&gt; =  </span><br><span class="hljs-string">&gt; p  </span><br><span class="hljs-string">&gt; &#125;&#x27;</span> test.txt<br></code></pre></td></tr></table></figure></li><li><p>替换标志<br><code>sed &#39;s/pattern/replacement/flags</code> flag为替换标志 有四种 可以写在一起</p><ul><li>数字 指定文中的第几处<br><code>echo -e &quot;test1 test1 test2 \ntest3 test4&quot;|sed &#39;s/test1/new/2&#39;</code><br>-&gt;test1 new test2<br>-&gt;test3 test4</li><li>g 替换所有<br><code>echo -e &quot;test1 test1 test2 \ntest3 test4&quot;|sed &#39;s/test1/new/g&#39;</code><br>-&gt;new new test2<br>-&gt;test3 test4</li><li>p 打印出替换后的行 <em>-n的意思是只打印匹配的行</em><br><code>echo -e &quot;test1 test1 test2 \ntest3 test4&quot;|sed -n &#39;s/test1/new/gp&#39;</code><br>-&gt;new new test2</li><li>w <em>file</em> 将替换结果写入文件</li><li><em><code>sed &#39;s|//ccc0|\nchain-&gt;Add(\&quot;$&#123;FILE_PATH&#125;\&quot;)|g&#39;</code>当&#x2F;会引起混乱时，可以使用别的一些符号分隔</em></li></ul></li><li><p>指定行地址  <em>对i和a同样适用</em></p><ul><li><code>sed &#39;2s/test1/new/&#39;</code>指定第2行</li><li><code>sed &#39;2,4s/test1/new/&#39;</code>指定2到4行</li><li><code>sed &#39;2,$s/test1/new/&#39;</code>指定2行之后 <em>$代表最后一行</em></li></ul></li><li><p>打印</p><ul><li>p <em>打印文本</em></li><li>&#x3D; <em>打印行号</em></li><li>| <em>列出行，可以打印出不可打印字符，例如\t</em></li></ul></li><li><p><code>sed -n &#39;/test/p&#39;</code>这个和<code>grep test</code>类似 前者更高级一点，可以使用正则表达式，见十一章</p></li></ul><hr><h2 id="十、gawk-命令"><a href="#十、gawk-命令" class="headerlink" title="十、gawk 命令"></a>十、gawk 命令</h2><p><em>是awk的增强版本</em><br><code>gawk &#39;&#123;print &quot;hello&quot;&#125;&#39;</code> 设hello为显示一行固定的文本字符串，因此不管在数据流中输入什么文本，你都会得到同样的文本输出<br><code>echo &quot;me:hello world&quot; |awk  &#39;&#123;print $1&#125;&#39; </code> -&gt;me:hello   默认以空格作为分隔符<br><code>echo &quot;me:hello world&quot; |awk -F: &#39;&#123;print $1&#125;&#39; </code>-&gt;me <font color="Chocolate"> <strong>-F: 可以指定:为分隔符</strong></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<span class="hljs-keyword">for</span> test.gawk---<br>BEGIN &#123;<br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;title:character table&quot;</span><br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;character \t number&quot;</span><br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;---- \t ----&quot;</span><br>  &#125;<br>&#123;<br>  <span class="hljs-built_in">print</span> <span class="hljs-variable">$1</span> <span class="hljs-string">&quot;\t&quot;</span> <span class="hljs-variable">$2</span> <br>&#125;<br>END &#123;<br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;end&quot;</span><br> &#125; <br>---<br>gawk -f test.gawk test.txt <span class="hljs-comment">#与sed的-f选项类似，你可以将命令写入文件</span><br></code></pre></td></tr></table></figure><h4 id="一些常见处理"><a href="#一些常见处理" class="headerlink" title="一些常见处理"></a>一些常见处理</h4><ul><li>数学表达式<br><code>gawk &#39;$1 == 0 &#123;print $0&#125;&#39;</code>意味着第一列为0则输出整行</li><li>if 语句<br><code>gawk &#39;&#123;if ($1 &gt; 2) print $1&#125;&#39; </code><br><code>gawk &#39;&#123;if ($1 &gt; 2) &#123;a = $1 *2 ; print a&#125; else &#123;print $2&#125;&#125;&#39; test.txt </code></li><li>while,for 语句 <em>类似if</em></li></ul><h4 id="printf-格式化打印"><a href="#printf-格式化打印" class="headerlink" title="printf 格式化打印"></a>printf 格式化打印</h4><p><em>需要添加换行符，否则会在同一行输出</em></p><blockquote><p>printf “<em>format string”, var1, var2​​</em><br>  其中<em>format string</em>格式为 <em>%[modifier]control-letter</em><br>  <font color="Chocolate">%d或%i显示整数<br>  %e科学计数<br>  %f显示浮点 %2.1f保留一位小数<br>  %s显示字符串</font></p></blockquote><p><code>gawk &#39;BEGIN&#123;FS=&quot;,&quot;&#125; &#123;printf &quot;%s &quot;, $1&#125; END&#123;printf &quot;\n&quot;&#125;&#39; </code>设定,为分隔符，打印第一列字符，由于没有换行，在最后输出一个换行符，这样第一列的字符都会输出在同一行内   </p><p><code>gawk &#39;BEGIN&#123;FS=&quot;\n&quot;; RS=&quot;&quot;&#125; &#123;printf &quot;%-16s %s\n&quot;, $1, $4&#125;&#39; data2￼</code> %16s 即输出宽度为16字符右对齐 %-16s 左对齐</p><blockquote><p>Ima Test<br>123 Main Street<br>Chicago, IL 60601<br>(312)555-1234￼</p><p>Frank Tester￼<br>456 Oak Street<br>Indianapolis, IN 46201￼<br>(317)555-9876￼</p></blockquote><p><em>默认情况下，RS是换行符 \n，表示记录是一行。这里将RS设为空白意味着，出现空白行之前看为一行，以换行符为分隔符，第4列即为电话列</em></p><hr><h2 id="十一、正则表达式"><a href="#十一、正则表达式" class="headerlink" title="十一、正则表达式"></a>十一、正则表达式</h2><h3 id="能用在sed与gawk"><a href="#能用在sed与gawk" class="headerlink" title="&gt; 能用在sed与gawk"></a>&gt; 能用在sed与gawk</h3><ul><li>锚点字符<ul><li><code>^</code>锚定行首<br><code>sed -n &#39;/^this/p&#39;</code>这个只会匹配每行开头为this的行</li><li><code>$</code>锚定行尾<br><code>sed -n &#39;/end$/p&#39;</code>这个只会匹配每行结尾为this的行</li><li>组合锚点 删除空白行<br><code>sed &#39;/^$/d&#39;</code><font color="Chocolate">强烈推荐 </font></li></ul></li><li>点号字符<br><em>点号字符可以匹配除换行符之外的任意单个字符。点号字符必须匹配一个字符</em></li><li>字符组 []<br><code>echo &quot;Yes&quot; | sed -n &#39;/[Yy]es/p&#39;￼</code><br><code>sed -n &#39;^[0-9][0-9]$/p&#39;</code> 这样可以匹配两位数<br><code>sed -n &#39;[^ch]at$/p&#39;</code> ^放到方括号内代表将其排除在外</li><li>星号 <em>星号表明前面的字符可以出现0次或多次</em><br><code>echo &quot;ik&quot; | sed -n &#39;/ie*k/p&#39;</code> 这样依然可以匹配到</li></ul><h3 id="不能用在sed"><a href="#不能用在sed" class="headerlink" title="&gt; 不能用在sed"></a>&gt; 不能用在sed</h3><ul><li>问号 <em>问号表明前面的字符可以出现0次或1次</em></li><li>加号 <em>加号表明前面的字符可以出现1次或多次</em></li><li>花括号 {m,n} <em>表明前面的字符可以出现m次到n次</em><br>在默认情况下，gawk不识别正则表达式区间，必须指定gawk的命令行选项–re-interval才行。<br><code>echo &quot;beet&quot; | gawk --re-interval &#39;/be&#123;1&#125;t/&#123;print $0&#125;&#39;</code></li><li>竖线 <em>竖线代表or</em><br><code>gawk &#39;/cat|dog/&#123;print $0&#125;&#39;</code></li><li>表达式分组 ()<br><code>gawk &#39;/(c|b)a(b|t)/&#123;print $0&#125;&#39;￼</code></li></ul><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><em>一些乱七八糟的笔记，不保证正确性</em></p><p>du -sh .<br>sed -i “s&#x2F;forward0&#x2F;forward&#x2F;g” crab3_forward0_Ntuple.py<br><code>grep -o &quot;$FIELD&quot; &quot;$FILE&quot; | wc -l</code>   出现次数<br><code>grep -A 5 &quot;$FIELD&quot;  &quot;$FILE&quot;</code>   出现后5行内容<br>kill $(jobs -p)<br>condor_rm -all<br>condor_rm -all -name lpcschedd6.fnal.gov lpc上删除condor jobs</p><p>ls -lhtr  命令会以人类可读的方式，按照修改时间的倒序，列出当前工作目录中的所有文件和子目录的详细信息。这样可以方便地查看最近修改过的文件。<br>cat ion.C |wc 确定ioc的行数  </p><p>s&#x2F;old&#x2F;new&#x2F;gc 替换整个文件中出现的所有old，并在每次替换时提示。  </p><p>在终端中编写shell脚本.sh文件时，可以使用以下方法来实现多行同时缩进：</p><ol><li>使用vim打开你的shell脚本文件，然后按ESC键进入命令模式。</li><li>按下ctrl+v键进入可视块模式，然后使用上下键选中你想要缩进的多行代码。</li><li>按下shift+i键进入插入模式，然后连续敲击空格键来添加缩进（注意这个时候只有一行会显示缩进）。</li><li>最后按下esc键，你会发现所有选中的行都被缩进了1。<br>如果你想要删除多行前面的空格，可以按照以下步骤操作：</li><li>同样先按下ctrl+v键进入可视块模式，然后使用上下左右键选中你想要删除空格的多行代码以及前面的空格。</li><li>然后按下del键即可删除选中的空格1。</li></ol><p>chmod -R 755 public&#x2F;  设置文件夹及子文件夹的权限为rwxr-xr-x<br>r：read，可读取此文件的内容，即可以打开文件；<br>w：write，可编辑此文件的内容，如可以增加、删除、更改文件内容；<br>x：execute，可以执行此文件。<br>￼<img src="/postfigure/linux/4.png" alt="1"></p><p>将cds上的root数据文件拷到服务器上<br>xrdcp -d 1 -f root:&#x2F;&#x2F;xrootd-cms.infn.it&#x2F;&#x2F;</p><p>.h 头文件可以用crab那一步的cmsRun 产生的mymultilep.root文件获取<br>root &#x2F;path&#x2F;***.root<br>.ls      &#x2F;&#x2F;mkcands<br>mkcands-&gt;cd()<br>.ls      &#x2F;&#x2F;X_data<br>X_data-&gt;MakeClass(“myntuple”)<br><img src="/postfigure/linux/Attaching.png" alt="2"></p><p>Lpc会有时用不了有些命令<br>source &#x2F;cvmfs&#x2F;cms.cern.ch&#x2F;cmsset_default.sh<br>source &#x2F;cvmfs&#x2F;cms.cern.ch&#x2F;crab3&#x2F;crab.sh</p><p>修改路径；清除；<br>scramv1 b  ProjectRename<br>scramv1 b clean<br>scramv1 b  </p><p>删除重复行<br>cat hh.txt | sort -g -k7 | uniq</p><p>disown -h %1无敌的代码，我愿称之为神！后台挂起序号1的job，并且断线不发送停止代码，之前后台挂着，断线就会结束job</p><p><img src="/postfigure/linux/linux.png" alt="linux命令行与shell脚本编程大全"><br>本文参考这本书，如果有疑问请自行下载查阅<br><a href="https://zh.z-library.se/book/15316978/c14dce/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8-%E7%AC%AC3%E7%89%88-%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6.html">linux命令行与shell脚本编程大全</a></p><hr><p>END</p><div style="text-align: right;"> written by zhuf </div><hr><h1 id="linux-进阶与服务器管理"><a href="#linux-进阶与服务器管理" class="headerlink" title="linux 进阶与服务器管理"></a>linux 进阶与服务器管理</h1><h2 id="零、一些小知识对之前的补充"><a href="#零、一些小知识对之前的补充" class="headerlink" title="零、一些小知识对之前的补充"></a>零、一些小知识对之前的补充</h2><ul><li><p>语言<br><code>locale</code> 显示当前的语系<br>LANG&#x3D;”zh_CN.UTF-8”<br>LC_COLLATE&#x3D;”zh_CN.UTF-8”<br>LC_CTYPE&#x3D;”zh_CN.UTF-8”<br>LC_MESSAGES&#x3D;”zh_CN.UTF-8”<br>LC_MONETARY&#x3D;”zh_CN.UTF-8”<br>LC_NUMERIC&#x3D;”zh_CN.UTF-8”<br>LC_TIME&#x3D;”zh_CN.UTF-8”<br>LC_ALL&#x3D;</p><p><code>LANG=en_US.utf8</code> 修改输出信息为英文<br><code>export LC_ALL=en_US.utf8</code>同步更新LC_ALL</p></li><li><p>man指令<br>当你不知道一个命令的用法，“男人”一下，你就知道，显示的手册（manual）通常会分为以下的几个部分</p></li></ul><table><thead><tr><th align="center">代号</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">NAME</td><td align="center">简短的指令说明，左上角除了指令外括号里面还会有一些数字，这几个比较重要：1，使用者可执行指令或文件；5，配置文件或某文件的格式；8，系统管理员可用的指令</td></tr><tr><td align="center">SYNOPSIS</td><td align="center">简短的指令语法</td></tr><tr><td align="center">DESCRIPTION</td><td align="center">完整说明</td></tr><tr><td align="center">COMMANDS</td><td align="center">当程序执行时，可以在程序中下达这个指令</td></tr></tbody></table><ul><li><p>文件权限<br>linux的每个文件都有User,Group,Others三种身份的权限，<code>ls -al</code>查看文件权限<br><img src="/postfigure/linux/image-7.png" alt="Alt text"><img src="/postfigure/linux/image-8.png" alt="Alt text"><br>文件类型  [d] 目录  [-]文件 [l]链接文件 </p></li><li><p>改变文件属性</p><ul><li>chgrp 改变文件所属群组<br>在<code>/etc/group</code>中是存在的群组名，用<code>chgrp [group name] [file name]</code>就可以将对应文件</li><li>chown 改变文件拥有者<br>在<code>/etc/passwd</code>中是存在的使用者，用<code>chown -R [user name] [dirname/filename]</code>或者<code>chown -R [user name]:[group name] [dirname/filename]</code>可以修改群组和使用者所属，-R代表递归</li><li>chmod 改变文件的权限<br>文件权限用数字加和的方式表示 r:4 w:2 x:1<br><font color="Chocolate"><em>一些常用的权限数字</em></font><br>755 将文件变为可执行文件，但不让其他人修改<br>740 将文件不被别人看到</li></ul></li><li><p>一些指令<br><code>who</code>能看到谁在偷偷工作<br><code>df</code> 系统中设备的使用情况</p></li></ul><h2 id="一、linux-文件与目录"><a href="#一、linux-文件与目录" class="headerlink" title="一、linux 文件与目录"></a>一、linux 文件与目录</h2><h3 id="1-1-root-根目录"><a href="#1-1-root-根目录" class="headerlink" title="1.1  &#x2F; (root)根目录"></a>1.1  &#x2F; (root)根目录</h3><table><thead><tr><th align="center">目录</th><th align="center">放置文件内容</th></tr></thead><tbody><tr><td align="center">&#x2F;bin</td><td align="center">bin下放置的是一些操作指令，比如cat, mv,cp</td></tr><tr><td align="center">&#x2F;boot</td><td align="center">放置开机配置文件</td></tr><tr><td align="center">&#x2F;etc</td><td align="center">系统的配置文件，包括人员账号密码</td></tr><tr><td align="center">&#x2F;lib</td><td align="center">放置函数库</td></tr><tr><td align="center">&#x2F;tmp</td><td align="center">正如其名，是临时文件</td></tr><tr><td align="center">&#x2F;usr</td><td align="center">(Unix Software Resource)一些系统默认的软件，类似window的C盘</td></tr><tr><td align="center">&#x2F;dev</td><td align="center">linux中每个设备都被当成一个文件，这个就是设备文件</td></tr></tbody></table><p>软件源有很多，可以使用一些<a href="https://zhuanlan.zhihu.com/p/421178143">国内源</a><br><code>/etc/apt/sources.list</code> or <code>/etc/apt/sources.list.d/</code> 放的是软件源链接<br><code>sudo apt-get update</code>  通过这个命令更新软件源</p><h3 id="1-2-PATH-可执行文件路径的变量"><a href="#1-2-PATH-可执行文件路径的变量" class="headerlink" title="1.2 $PATH 可执行文件路径的变量"></a>1.2 $PATH 可执行文件路径的变量</h3><p>当执行一个指令的时候“ls”，系统会依照PATH的设置去每个定义的目录下寻找文件名为ls的可执行文件进行指令执行。<br>以$PATH<code>/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code>为例，如果用root权限将&#x2F;bin&#x2F;ls移动到&#x2F;root文件夹下，这样的情况下就不能执行<code>ls</code>命令了，只有当你用这样的命令<code>PATH=&quot;$&#123;PATH&#125;:/root&quot;</code>，将&#x2F;root下的ls路径加入到$PATH中之后，才能正确的执行ls命令<br>如果有两个ls，则在$PATH中的目录先搜索到的ls会被执行</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
